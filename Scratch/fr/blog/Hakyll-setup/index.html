<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>YBlog - Hakyll setup</title>
        <meta name="keywords" content="programming, hakyll, Haskell, nanoc" />

        <link rel="shortcut icon" type="image/x-icon" href="../../../../Scratch/img/favicon.ico" />
        <link rel="stylesheet" type="text/css" href="../../../../Scratch/css/scientific.css" />
        <link rel="stylesheet" type="text/css" href="../../../../Scratch/js/highlight/styles/solarized_dark.css" />
        <link rel="stylesheet" type="text/css" href="../../../../Scratch/css/solarized.css" />
		<!-- Font -->
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" />
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/yannespositocomfr" />
        <!--[if lt IE 9]>
        <script src="http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js"></script>
        <![endif]-->

    </head>
    <body lang="fr" class="article">
        <div id="content">
	        			<div id="header">
			    <div id="choix">
        	        <div id="choixlang">
                        <a href="../../../../Scratch/en/blog/Hakyll-setup/">Anglais</a> 
        	        </div>
					<div id="switchcss"><a href="#">Changer de theme</a></div>
                    <div class="tomenu"><a href="#navigation">↓ Menu ↓</a></div>
        	        <div class="flush"></div>
        	    </div>
			</div>

			<div id="titre">
				<h1>Hakyll setup</h1>
				
			</div>
			<div class="flush"></div>
			<div id="afterheader" class="article">
				<div class="corps">
					<div>
<img src="../../../../Scratch/img/blog/Hakyll-setup/main.png" alt="Main image" />
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Comment j’utilise <a href="http://jaspervdj.be/hakyll">hakyll</a>. Abréviations, corrections typographiques, multi-language, utilisation d’<code>index.html</code>, etc…</p>
</div>
<p>Ce site web est fait avec <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</p>
<p><a href="http://jaspervdj.be/hakyll">Hakyll</a> peut être vu comme un <span class="sc"><abbr title="Content Management System">cms</abbr></span> minimaliste. D’une façon plus générale, il s’agit d’une bibliothèque qui facilite la création automatique de fichiers.</p>
<p>D’un point de vue utilisateur voici comment j’écris mes articles&nbsp;:</p>
<ol style="list-style-type: decimal">
<li>J’ouvre un éditeur de texte (vim dans mon cas). J’édite un fichier markdow qui ressemble à ça :</li>
</ol>
<pre class="sourceCode markdown"><code class="sourceCode markdown">Un titre de page
================

Un titre de chapitre
--------------------

Azur, nos bêtes sont bondées d'un cri.
Je m'éveille songeant au fruit noir de l'anibe dans sa cupule
véruqueuse et tronquée.

Saint John Perse.

<span class="fu">### Titre 3</span>

&gt;<span class="dt"> C'est un blockquote.</span>
<span class="dt">&gt;</span>
<span class="dt">&gt; C'est un second paragraphe dans le blockquote</span>
<span class="dt">&gt;</span>
<span class="dt">&gt; ## C'est un H2 dans un blockquote</span></code></pre>
<ol start="2" style="list-style-type: decimal">
<li>J’ouvre mon navigateur et je rafraichis de temps en temps pour voir les changements.</li>
<li>Une fois satisfait, je lance un script minimal qui fait grosso modo un simple <code>git push</code>. Mon blog est hébergé sur <a href="http://github.com">github</a>.</li>
</ol>
<p>A ne pas y regarder de trop près, on peut réduire le rôle d’Hakyll à&nbsp;:</p>
<blockquote>
<p>Créer (resp. mettre à jour) un fichier <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> lorsque je crée (resp. modifie) un fichier markdown.</p>
</blockquote>
<p>Bien que cela semble facile, il y a de nombreux détails cachés&nbsp;:</p>
<ul>
<li>Ajouter des métadatas comme des mots clés</li>
<li>Créer un page archive qui contient la liste de tous les articles</li>
<li>Gérer les fichier statiques</li>
<li>Créer un flux <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span></li>
<li>Filtrer le contenu</li>
<li>Gérer les dépendances</li>
</ul>
<p>Le travail d’Hakyll est de vous aider avec tout ça. Commençons par expliquer les concepts basiques.</p>
<h2 id="les-concepts-et-la-syntaxe">Les concepts et la syntaxe</h2>
<div>
<img src="../../../../Scratch/img/blog/Hakyll-setup/overview.png" alt="Overview" />
</div>
<p>Pour chaque fichier que vous créer, il faut fournir&nbsp;:</p>
<ul>
<li>un chemin de destination</li>
<li>une liste de filtres du contenu</li>
</ul>
<p>Commençons par le cas le plus simple ; les fichiers statiques (images, fontes, etc…) Généralement, vous avec un répertoire source (ici le répertoire courant) et une répertoire destination <code>_site</code>.</p>
<p>Le code Hakyll est&nbsp;:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- pour chaque fichier dans le répertoire static</span>
match <span class="st">&quot;static/*&quot;</span> <span class="kw">do</span>
  <span class="co">-- on ne change pas le nom ni le répertoire</span>
  route   idRoute
  <span class="co">-- on ne modifie pas le contenu</span>
  compile copyFileCompiler</code></pre>
<p>Ce programme va copier <code>static/foo.jpg</code> dans <code>_site/static/foo.jpg</code>. C’est un peu lourd pour un simple <code>cp</code>. Maintenant comment faire pour transformer automatiquement un fichier markdown dans le bon <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- pour chaque fichier avec un extension md</span>
match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  <span class="co">-- changer son extension en html</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  <span class="co">-- utiliser la librairie pandoc pour compiler le markdown en html</span>
  compile <span class="fu">$</span> pandocCompiler</code></pre>
<p>Si vous créez un fichier <code>posts/toto.md</code>, cela créera un fichier <code>_site/posts/toto.html</code>.</p>
<p>Si le fichier <code>posts/foo.md</code> contient</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="fu"># Cthulhu</span>

ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn</code></pre>
<p>le fichier <code>_site/posts/foo.html</code>, contiendra</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>Cthulhu<span class="kw">&lt;/h1&gt;</span>
<span class="kw">&lt;p&gt;</span>ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn<span class="kw">&lt;/p&gt;</span></code></pre>
<p>Mais horreur ! <code>_site/posts/cthulhu.html</code> n’est pas un <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> complet. Il ne possède ni header, ni footer, etc… C’est ici que nous utilisons des templates. J’ajoute une nouvelle directive dans le bloc “compile”.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- use the template with the current content</span>
    <span class="highlight"><span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> defaultContext</span></code></pre>
<p>Maintenant si <code>templates/posts.html</code> contient:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span>How could I get the title?<span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="highlight">$body$</span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>Maintenant notre <code>ctuhlhu.html</code> contient</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span>How could I get the title?<span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="highlight"><span class="kw">&lt;h1&gt;</span>Cthulhu<span class="kw">&lt;/h1&gt;</span></span>
    <span class="highlight"><span class="kw">&lt;p&gt;</span>ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn<span class="kw">&lt;/p&gt;</span></span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>C’est facile. Mais il reste un problème à résoudre. Comment pouvons-nous changer le titre ? Ou par exemple, ajouter des mots clés ?</p>
<p>La solution est d’utiliser les <code>Context</code>s. Pour cela, nous devrons ajouter des <em>metadonnées</em> à notre markdown<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="highlight">--- </span>
<span class="highlight">title: Cthulhu</span>
<span class="highlight">--- </span>
<span class="fu"># Cthulhu</span>

ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn</code></pre>
<p>Et modifier légèrement notre template&nbsp;:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span><span class="highlight">$title$</span><span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    $body$
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>Super facile!</p>
<p>La suite de l’article est en Anglais. Je la traduirai volontier si suffisamment de personnes me le demande gentillement.</p>
<h2 id="real-customization">Real customization</h2>
<p>Now that we understand the basic functionality. How to:</p>
<ul>
<li>use SASS?</li>
<li>add keywords?</li>
<li>simplify <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>?</li>
<li>create an archive page?</li>
<li>create an <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> feed?</li>
<li>filter the content?</li>
<li>add abbreviations support?</li>
<li>manage two languages?</li>
</ul>
<h3 id="use-sass">Use SASS</h3>
<p>That’s easy. Simply call the executable using <code>unixFilter</code>. Of course you’ll have to install SASS (<code>gem install sass</code>). And we also use compressCss to gain some space.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;css/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    route   <span class="fu">$</span> setExtension <span class="st">&quot;css&quot;</span>
    compile <span class="fu">$</span> getResourceString <span class="fu">&gt;&gt;=</span>
              withItemBody (unixFilter <span class="st">&quot;sass&quot;</span> [<span class="st">&quot;--trace&quot;</span>]) <span class="fu">&gt;&gt;=</span>
              return <span class="fu">.</span> fmap compressCss</code></pre>
<h3 id="add-keywords">Add keywords</h3>
<p>In order to help to reference your website on the web, it is nice to add some keywords as meta datas to your <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> page.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">&quot;keywords&quot;</span>
<span class="ot">      content=</span><span class="st">&quot;Cthulhu, Yog-Sothoth, Shub-Niggurath&quot;</span><span class="kw">&gt;</span></code></pre>
<p>In order to add keywords, we could not directly use the markdown metadatas. Because, without any, there should be any meta tag in the <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>.</p>
<p>An easy answer is to create a <code>Context</code> that will contains the meta tag.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- metaKeywordContext will return a Context containing a String</span>
<span class="ot">metaKeywordContext ::</span> <span class="dt">Context</span> <span class="dt">String</span>
<span class="co">-- can be reached using $metaKeywords$ in the templates</span>
<span class="co">-- Use the current item (markdown file)</span>
metaKeywordContext <span class="fu">=</span> field <span class="st">&quot;metaKeywords&quot;</span> <span class="fu">$</span> \item <span class="ot">-&gt;</span> <span class="kw">do</span>
  <span class="co">-- tags contains the content of the &quot;tags&quot; metadata</span>
  <span class="co">-- inside the item (understand the source)</span>
  tags <span class="ot">&lt;-</span> getMetadataField (itemIdentifier item) <span class="st">&quot;tags&quot;</span>
  <span class="co">-- if tags is empty return an empty string</span>
  <span class="co">-- in the other case return</span>
  <span class="co">--   &lt;meta name=&quot;keywords&quot; content=&quot;$tags$&quot;&gt;</span>
  return <span class="fu">$</span> maybe <span class="st">&quot;&quot;</span> showMetaTags tags
    <span class="kw">where</span>
      showMetaTags t <span class="fu">=</span> <span class="st">&quot;&lt;meta name=\&quot;keywords\&quot; content=\&quot;&quot;</span>
                       <span class="fu">++</span> t <span class="fu">++</span> <span class="st">&quot;\&quot;&gt;\n&quot;</span></code></pre>
<p>Then we pass this <code>Context</code> to the <code>loadAndApplyTemplate</code> function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- use the template with the current content</span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>
            (defaultContext <span class="highlight"><span class="fu">&lt;&gt;</span> metaKeywordContext</span>)</code></pre>
<blockquote>
<p>☞ Here are the imports I use for this tutorial.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import           </span><span class="dt">Control.Monad</span>          (forM,forM_)
<span class="kw">import           </span><span class="dt">Data.List</span>              (sortBy,isInfixOf)
<span class="kw">import           </span><span class="dt">Data.Monoid</span>            ((&lt;&gt;),mconcat)
<span class="kw">import           </span><span class="dt">Data.Ord</span>               (comparing)
<span class="kw">import           </span><span class="dt">Hakyll</span>
<span class="kw">import           </span><span class="dt">System.Locale</span>          (defaultTimeLocale)
<span class="kw">import           </span><span class="dt">System.FilePath.Posix</span>  (takeBaseName,takeDirectory
                                         ,(<span class="fu">&lt;/&gt;</span>),splitFileName)</code></pre>
</blockquote>
<h3 id="simplify-url">Simplify <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span></h3>
<p>What I mean is to use url of the form:</p>
<pre><code>http://domain.name/post/title-of-the-post/</code></pre>
<p>I prefer this than having to add file with <code>.html</code> extension. We have to change the default Hakyll route behavior. We create another function <code>niceRoute</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- replace a foo/bar.md by foo/bar/index.html</span>
<span class="co">-- this way the url looks like: foo/bar in most browsers</span>
<span class="ot">niceRoute ::</span> <span class="dt">Routes</span>
niceRoute <span class="fu">=</span> customRoute createIndexRoute
  <span class="kw">where</span>
    createIndexRoute ident <span class="fu">=</span>
        takeDirectory p <span class="fu">&lt;/&gt;</span> takeBaseName p <span class="fu">&lt;/&gt;</span> <span class="st">&quot;index.html&quot;</span>
    <span class="kw">where</span> p<span class="fu">=</span>toFilePath ident</code></pre>
<p>Not too difficult. But! There might be a problem. What if there is a <code>foo/index.html</code> link instead of a clean <code>foo/</code> in some content?</p>
<p>Very simple, we simply remove all <code>/index.html</code> to all our links.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- replace url of the form foo/bar/index.html by foo/bar</span>
<span class="ot">removeIndexHtml ::</span> <span class="dt">Item</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)
removeIndexHtml item <span class="fu">=</span> return <span class="fu">$</span> fmap (withUrls removeIndexStr) item
  <span class="kw">where</span>
<span class="ot">    removeIndexStr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
    removeIndexStr url <span class="fu">=</span> <span class="kw">case</span> splitFileName url <span class="kw">of</span>
        (dir, <span class="st">&quot;index.html&quot;</span>) <span class="fu">|</span> isLocal dir <span class="ot">-&gt;</span> dir
        _                                 <span class="ot">-&gt;</span> url
        <span class="kw">where</span> isLocal uri <span class="fu">=</span> not (isInfixOf <span class="st">&quot;://&quot;</span> uri)</code></pre>
<p>And we apply this filter at the end of our compilation</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  <span class="highlight">route <span class="fu">$</span> niceRoute</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- use the template with the current content</span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> defaultContext
    <span class="highlight"><span class="fu">&gt;&gt;=</span> removeIndexHtml</span></code></pre>
<h3 id="create-an-archive-page">Create an archive page</h3>
<p>Creating an archive start to be difficult. There is an example in the default Hakyll example. Unfortunately, it assumes all posts prefix their name with a date like in <code>2013-03-20-My-New-Post.md</code>.</p>
<p>I migrated from an older blog and didn’t want to change my <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>. Also I prefer not to use any filename convention. Therefore, I add the date information in the metadata <code>published</code>. And the solution is here:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;archive.md&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
  route <span class="fu">$</span> niceRoute
  compile <span class="fu">$</span> <span class="kw">do</span>
    body <span class="ot">&lt;-</span> getResourceBody
    return <span class="fu">$</span> renderPandoc body
      <span class="highlight"><span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/archive.html&quot;</span> archiveCtx</span>
      <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="highlight"><span class="st">&quot;templates/base.html&quot;</span></span> defaultContext
      <span class="fu">&gt;&gt;=</span> removeIndexHtml</code></pre>
<p>Where <code>templates/archive.html</code> contains</p>
<pre class="sourceCode html"><code class="sourceCode html">$body$

<span class="kw">&lt;ul&gt;</span>
    $posts$
<span class="kw">&lt;/ul&gt;</span></code></pre>
<p>And <code>base.html</code> is a standard template (simpler than <code>post.html</code>).</p>
<p><code>archiveCtx</code> provide a context containing an <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> representation of a list of posts in the metadata named <code>posts</code>. It will be used in the <code>templates/archive.html</code> file with <code>$posts$</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">archiveCtx <span class="fu">=</span>
  defaultContext <span class="fu">&lt;&gt;</span>
  metaKeywordContext <span class="fu">&lt;&gt;</span>
  <span class="highlight">field <span class="st">&quot;posts&quot;</span> (\_ <span class="ot">-&gt;</span> postList createdFirst)</span></code></pre>
<p><code>postList</code> returns an <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> representation of a list of posts given an Item sort function. The representation will apply a minimal template on all posts. Then it concatenate all the results. The template is <code>post-item.html</code>:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;li&gt;&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$url$&quot;</span><span class="kw">&gt;</span>$published$ - $title$<span class="kw">&lt;/a&gt;&lt;/li&gt;</span></code></pre>
<p>Here is how it is done:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postList ::</span> [<span class="dt">Item</span> <span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Compiler</span> [<span class="dt">Item</span> <span class="dt">String</span>]
            <span class="ot">-&gt;</span> <span class="dt">Compiler</span> <span class="dt">String</span>
postList sortFilter <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- sorted posts</span>
    posts   <span class="ot">&lt;-</span> loadAll <span class="st">&quot;post/*&quot;</span> <span class="fu">&gt;&gt;=</span> sortFilter
    itemTpl <span class="ot">&lt;-</span> loadBody <span class="st">&quot;templates/post-item.html&quot;</span>
    <span class="co">-- we apply the template to all post</span>
    <span class="co">-- and we concatenate the result.</span>
    <span class="co">-- list is a string</span>
    list    <span class="ot">&lt;-</span> applyTemplateList itemTpl defaultContext posts
    return list</code></pre>
<p><code>createdFirst</code> sort a list of item and put it inside <code>Compiler</code> context. We need to be in the <code>Compiler</code> context to access metadatas.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createdFirst ::</span> [<span class="dt">Item</span> <span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Compiler</span> [<span class="dt">Item</span> <span class="dt">String</span>]
createdFirst items <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- itemsWithTime is a list of couple (date,item)</span>
  itemsWithTime <span class="ot">&lt;-</span> forM items <span class="fu">$</span> \item <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="co">-- getItemUTC will look for the metadata &quot;published&quot; or &quot;date&quot;</span>
    <span class="co">-- then it will try to get the date from some standard formats</span>
    utc <span class="ot">&lt;-</span> getItemUTC defaultTimeLocale <span class="fu">$</span> itemIdentifier item
    return (utc,item)
  <span class="co">-- we return a sorted item list</span>
  return <span class="fu">$</span> map snd <span class="fu">$</span> reverse <span class="fu">$</span> sortBy (comparing fst) itemsWithTime</code></pre>
<p>It wasn’t so easy. But it works pretty well.</p>
<h3 id="create-an-rss-feed">Create an <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> feed</h3>
<p>To create an <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> feed, we have to:</p>
<ul>
<li>select only the lasts posts.</li>
<li>generate partially rendered posts (no css, js, etc…)</li>
</ul>
<p>We could then render the posts twice. One for <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> rendering and another time for <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span>. Remark we need to generate the <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> version to create the <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> one.</p>
<p>One of the great feature of Hakyll is to be able to save snapshots. Here is how:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- save a snapshot to be used later in rss generation</span>
    <span class="highlight"><span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span></span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> defaultContext</code></pre>
<p>Now for each post there is a snapshot named “content” associated. The snapshots are created before applying a template and after applying pandoc. Furthermore feed don’t need a source markdown file. Then we create a new file from no one. Instead of using <code>match</code>, we use <code>create</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">create [<span class="st">&quot;feed.xml&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
      route idRoute
      compile <span class="fu">$</span> <span class="kw">do</span>
        <span class="co">-- load all &quot;content&quot; snapshots of all posts</span>
        loadAllSnapshots <span class="st">&quot;posts/*&quot;</span> <span class="st">&quot;content&quot;</span>
        <span class="co">-- take the latest 10</span>
        <span class="fu">&gt;&gt;=</span> (fmap (take <span class="dv">10</span>)) <span class="fu">.</span> createdFirst
        <span class="co">-- renderAntom feed using some configuration</span>
        <span class="fu">&gt;&gt;=</span> renderAtom feedConfiguration feedCtx
      <span class="kw">where</span>
<span class="ot">        feedCtx ::</span> <span class="dt">Context</span> <span class="dt">String</span>
        feedCtx <span class="fu">=</span>  defaultContext <span class="fu">&lt;&gt;</span>
                   <span class="co">-- $description$ will render as the post body</span>
                   <span class="highlight">bodyField <span class="st">&quot;description&quot;</span></span></code></pre>
<p>The <code>feedConfiguration</code> contains some general informations about the feed.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">feedConfiguration ::</span> <span class="dt">FeedConfiguration</span>
feedConfiguration <span class="fu">=</span> <span class="dt">FeedConfiguration</span>
  { feedTitle <span class="fu">=</span> <span class="st">&quot;Great Old Ones&quot;</span>
  , feedDescription <span class="fu">=</span> <span class="st">&quot;This feed provide information about Great Old Ones&quot;</span>
  , feedAuthorName <span class="fu">=</span> <span class="st">&quot;Abdul Alhazred&quot;</span>
  , feedAuthorEmail <span class="fu">=</span> <span class="st">&quot;abdul.alhazred@great-old-ones.com&quot;</span>
  , feedRoot <span class="fu">=</span> <span class="st">&quot;http://great-old-ones.com&quot;</span>
  }</code></pre>
<p>Great idea certainly steal from <a href="http://nanoc.ws">nanoc</a> (my previous blog engine)!</p>
<h3 id="filter-the-content">Filter the content</h3>
<p>As I just said, <a href="http://nanoc.ws">nanoc</a> was my preceding blog engine. It is written in Ruby and as Hakyll, it is quite awesome. And one thing Ruby does more naturally than Haskell is regular expressions. I had a <em>lot</em> of filters in nanoc. I lost some because I don’t use them much. But I wanted to keep some. Generally, filtering the content is just a way to apply to the body a function of type <code>String -&gt; String</code>.</p>
<p>Also we generally want prefilters (to filter the markdown) and postfilters (to filter the <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> after the pandoc compilation).</p>
<p>Here is how I do it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">markdownPostBehavior <span class="fu">=</span> <span class="kw">do</span>
  route <span class="fu">$</span> niceRoute
  compile <span class="fu">$</span> <span class="kw">do</span>
    body <span class="ot">&lt;-</span> getResourceBody
    <span class="highlight">prefilteredText <span class="ot">&lt;-</span> return <span class="fu">$</span> (fmap preFilters body)</span>
    <span class="highlight">return <span class="fu">$</span> renderPandoc prefilteredText</span>
    <span class="highlight"><span class="fu">&gt;&gt;=</span> applyFilter postFilters</span>
    <span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    yContext
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/boilerplate.html&quot;</span> yContext
    <span class="fu">&gt;&gt;=</span> relativizeUrls
    <span class="fu">&gt;&gt;=</span> removeIndexHtml</code></pre>
<p>Where</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">applyFilter strfilter str <span class="fu">=</span> return <span class="fu">$</span> (fmap <span class="fu">$</span> strfilter) str
<span class="ot">preFilters ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">postFilters ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Now we have a simple way to filter the content. Let’s augment the markdown ability.</p>
<h3 id="add-abbreviations-support">Add abbreviations support</h3>
<p>Comparing to <span style="text-transform: uppercase">L<sup style="vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em">a</sup>T<sub style="vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em">e</sub>X</span>, a very annoying markdown limitation is the lack of abbreviations.</p>
<p>Fortunately we can filter our content. And here is the filter I use:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">abbreviationFilter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
abbreviationFilter <span class="fu">=</span> replaceAll <span class="st">&quot;%[a-zA-Z0-9_]*&quot;</span> newnaming
  <span class="kw">where</span>
    newnaming matched <span class="fu">=</span> <span class="kw">case</span> M.lookup (tail matched) abbreviations <span class="kw">of</span>
                          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> matched
                          <span class="dt">Just</span> v <span class="ot">-&gt;</span> v
<span class="ot">abbreviations ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">String</span>
abbreviations <span class="fu">=</span> M.fromList
    [ (<span class="st">&quot;html&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;html&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;css&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;css&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;svg&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;svg&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;xml&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;xml&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;xslt&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;xslt&lt;/span&gt;&quot;</span>) ]</code></pre>
<p>It will search for all string starting by ‘%’ and it will search in the <code>Map</code> if there is a corresponding abbreviation. If there is one, we replace the content. Otherwise we do nothing.</p>
<p>Do you really believe I type</p>
<pre class="sourceCode html wrap"><code class="sourceCode html"><span class="kw">&lt;span</span><span class="ot"> style=</span><span class="st">&quot;text-transform: uppercase&quot;</span><span class="kw">&gt;</span>L<span class="kw">&lt;sup</span><span class="ot"> style=</span><span class="st">&quot;vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em&quot;</span><span class="kw">&gt;</span>a<span class="kw">&lt;/sup&gt;</span>T<span class="kw">&lt;sub</span><span class="ot"> style=</span><span class="st">&quot;vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em&quot;</span><span class="kw">&gt;</span>e<span class="kw">&lt;/sub&gt;</span>X<span class="kw">&lt;/span&gt;</span></code></pre>
<p>each time I write <span style="text-transform: uppercase">L<sup style="vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em">a</sup>T<sub style="vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em">e</sub>X</span>?</p>
<h3 id="manage-two-languages">Manage two languages</h3>
<p>Generally I write my post in English and French. And this is more difficult than it appears. For example, I need to filter the language in order to get the right list of posts. I also use some words in the templates and I want them to be translated.</p>
<p>A nice tip is to pass arguments to a context and use it in the template. Typically I write:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$otherLanguagePath$&quot;</span>
<span class="ot">	onclick=</span><span class="st">&quot;setLanguage('$otherlanguage$')&quot;</span><span class="kw">&gt;</span>
	<span class="highlight">$trad changeLanguage$</span> <span class="kw">&lt;/a&gt;</span></code></pre>
<p>First I create a Map containing all translations.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Trad</span> <span class="fu">=</span> <span class="dt">Trad</span> {<span class="ot"> frTrad ::</span> <span class="dt">String</span>,<span class="ot"> enTrad ::</span> <span class="dt">String</span> }

<span class="ot">trads ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Trad</span>
trads <span class="fu">=</span> M.fromList <span class="fu">$</span> map toTrad [
   (<span class="st">&quot;changeLanguage&quot;</span>,
      (<span class="st">&quot;English&quot;</span>
      , <span class="st">&quot;Français&quot;</span>))
  ,(<span class="st">&quot;switchCss&quot;</span>,
      (<span class="st">&quot;Changer de theme&quot;</span>
      ,<span class="st">&quot;Change Theme&quot;</span>))
  ,(<span class="st">&quot;socialPrivacy&quot;</span>,
      (<span class="st">&quot;Ces liens sociaux préservent votre vie privée&quot;</span>
      ,<span class="st">&quot;These social sharing links preserve your privacy&quot;</span>))
  ]
  <span class="kw">where</span>
    toTrad (key,(french,english)) <span class="fu">=</span>
      (key, <span class="dt">Trad</span> { frTrad <span class="fu">=</span> french , enTrad <span class="fu">=</span> english })</code></pre>
<p>Then I create a context taking an argument:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tradsContext ::</span> <span class="dt">Context</span> a
tradsContext <span class="fu">=</span> functionField <span class="st">&quot;trad&quot;</span> <span class="fu">$</span> \args item <span class="ot">-&gt;</span> <span class="kw">do</span>
  <span class="co">-- get the key</span>
  k <span class="ot">&lt;-</span> getArgs args
  <span class="co">-- get its value (a Trad object)</span>
  v <span class="ot">&lt;-</span> getValue k trads
  <span class="co">-- get the current item language</span>
  lang <span class="ot">&lt;-</span> itemLang item
  <span class="kw">case</span> lang <span class="kw">of</span>
    <span class="st">&quot;en&quot;</span> <span class="ot">-&gt;</span> return (enTrad v)
    <span class="st">&quot;fr&quot;</span> <span class="ot">-&gt;</span> return (frTrad v)
    _    <span class="ot">-&gt;</span> fail <span class="fu">$</span> lang <span class="fu">++</span> <span class="st">&quot; is not a supported language&quot;</span>
  <span class="kw">where</span>
    getArgs [k] <span class="fu">=</span> return k
    getArgs _   <span class="fu">=</span> fail <span class="st">&quot;Wrong arg for trad&quot;</span>
    <span class="co">-- search the Trad associated the key</span>
    getValue key hmap <span class="fu">=</span>
        <span class="kw">case</span> M.lookup key hmap <span class="kw">of</span>
          <span class="dt">Just</span> value <span class="ot">-&gt;</span> return value
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;Traduction not found&quot;</span></code></pre>
<p>In the real code source I also need more functions. But I just wanted to show how to pass parameters to a metadata tag.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The full code is <a href="http://github.com/yogsototh/yblog.git">here</a>. And except from the main file, I use literate Haskell. This way the code should be easier to understand.</p>
<p>If you want to know why I switched from nanoc:</p>
<p>My preceding nanoc website was a bit too messy. So much in fact, that the dependency system recompiled the entire website for any change.</p>
<p>So I had to do something about it. I had two choices:</p>
<ol style="list-style-type: decimal">
<li>Correct my old code (in Ruby)</li>
<li>Duplicate the core functionalities with Hakyll (in Haskell)</li>
</ol>
<p>I added too much functionalities in my nanoc system. Starting from scratch (almost) remove efficiently a lot of unused crap.</p>
<p>So far I am very happy with the switch. A complete build is about 4x faster. I didn’t broke the dependency system this time. As soon as I modify and save the markdown source, I can reload the page in the browser.</p>
<p>I removed a lot of feature thought. Some of them will be difficult to achieve with Hakyll. A typical example:</p>
<p>In nanoc I could take a file like this as source:</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="fu"># Title</span>

content

&lt;code file=&quot;foo.hs&quot;&gt;
main = putStrLn &quot;Cthulhu!&quot;
&lt;/code&gt;</code></pre>
<p>And it will create a file <code>foo.hs</code> which could then be downloaded.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>Title<span class="kw">&lt;/h1&gt;</span>

<span class="kw">&lt;p&gt;</span>content<span class="kw">&lt;/p&gt;</span>

<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;code/foo.hs&quot;</span><span class="kw">&gt;</span>Download foo.hs<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;pre&gt;&lt;code&gt;</span>main = putStrLn &quot;Cthulhu!&quot;<span class="kw">&lt;/code&gt;&lt;/pre&gt;</span></code></pre>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Nous pouvons aussi ajouter ces métadonnées dans un fichier externe (<code>toto.md.metadata</code>).<a href="#fnref1">↩</a></p></li>
</ol>
</div>
				</div>
                <div id="afterarticle">
                    <div id="social">
                        <a target="_blank" href="http://feeds.feedburner.com/yannespositocomfr" class="social">r</a>
                        ·
                         <a target="_blank" href="https://twitter.com/home?status=http://yannesposito.com/Scratch/fr/blog/Hakyll-setup/%20via%20@yogsototh" class="social">t</a>
                        ·
                        <a target="_blank" href="http://www.facebook.com/sharer/sharer.php?u=/Scratch/fr/blog/Hakyll-setup/" class="social">`</a>
                        ·
                         <a target="_blank" href="https://plus.google.com/share?url=http://yannesposito.com/Scratch/fr/blog/Hakyll-setup/" class="social">g</a>
                        <br />
                        <a class="message" href="../../../../Scratch/fr/blog/Social-link-the-right-way/">Ces liens sociaux préservent votre vie privée</a>
                    </div>
        	        <div id="navigation">
                        <a href="../../../../">Accueil</a>
                        <span class="sep">¦</span>
        	            <a href="../../../../Scratch/fr/blog">Blog</a>
                        <span class="sep">¦</span>
                        <a href="../../../../Scratch/fr/softwares">Logiciels</a>
                        <span class="sep">¦</span>
                        <a href="../../../../Scratch/fr/about">Auteur</a>
        	        </div>
                    <div id="totop"><a href="#header">↑ Top ↑</a></div>
				    <div class="corps" id="comment">
            	        <h2 class="first">Comments</h2>
				    	<div id="disqus_thread"></div>
        		    	<script type="text/javascript">
        		    	    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        		    	    var disqus_shortname = 'yannesposito'; // required: replace example with your forum shortname
                            var disqus_identifier = '/Scratch/fr/blog/Hakyll-setup/index.html';

        		    	    /* * * DON'T EDIT BELOW THIS LINE * * */
        		    	    (function() {
        		    	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        		    	        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        		    	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        		    	    })();
        		    	</script>
        		    	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        		    	<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
				    </div>
                    <div class="tomenu"><a>↑ Menu ↑</a></div>
				    <div id="bottom">
            	        <div>
            	            Published on 2013-03-16
            	        </div>
            	        <div>
            	            <a href="https://twitter.com/yogsototh">Follow @yogsototh</a>
            	        </div>
            	        <div>
                            <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Yann Esposito©</a>
            	        </div>
            	        <div>
            	            Done with
            	            <a href="http://www.vim.org" target="_blank">Vim</a>
				    		<span class="pala">&amp;</span>
                            <a href="http://nanoc.ws" target="_blank"><span class="strike">nanoc</span></a>
				    		<a href="http://jaspervdj.be/hakyll" target="_blank">Hakyll</a>
            	        </div>
            	    </div>
                </div>
			</div>

        </div>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.0/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/Scratch/js/vendor/jquery-1.10.0.min.js"><\/script>')</script>
        <script src="../../../../Scratch/js/jquery.scrolldepth.min.js"></script>
        <script src="../../../../Scratch/js/jquery.cookie.js"></script>
        <script src="../../../../Scratch/js/index.js"></script>
        <script src="../../../../Scratch/js/highlight/highlight.pack.js"></script>
        <script src="../../../../Scratch/js/article.js"></script>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </body>
</html>
