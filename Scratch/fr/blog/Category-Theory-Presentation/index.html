<!doctype html><html lang=fr><meta charset=utf-8><title>YBlog - Category Theory Presentation</title><meta name=keywords content="category theory,math,functor"><link rel="shortcut icon" type=image/x-icon href=../../../../Scratch/img/favicon.ico><link rel=stylesheet href=../../../../Scratch/css/brutalist.css><link rel=stylesheet href=../../../../Scratch/css/pandoc-solarized.css><link rel=alternate type=application/rss+xml title=RSS href=../../../../Scratch/fr/blog/feed/feed.xml><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon href=../../../../Scratch/img/about/FlatAvatar@2x.png><link href=https://twitter.com/yogsototh rel=me><link href=https://github.com/yogsototh rel=me><link href=mailto:yann.esposito@gmail.com rel=me><link rel=pgpkey href=../../../../pubkey.txt><body lang=fr class=article><div id=content><div id=header><div id=choix><span id=choixlang><a href=../../../../Scratch/en/blog/Category-Theory-Presentation/>Anglais</a></span>
<span class=tomenu><a href=#navigation>↓ Menu ↓</a></span>
<span class=flush></span></div></div><div id=titre><h1>Category Theory Presentation</h1></div><div class=flush></div><div id=afterheader class=article><div class=corps><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-hask-endofunctor.png alt="Cateogry of Hask's endofunctors"><p>Yesterday I was happy to make a presentation about Category Theory at <a href=http://www.meetup.com/riviera-scala-clojure>Riviera Scala Clojure Meetup</a> (note I used only Haskell for my examples).<ul><li><a href=http://yogsototh.github.com/Category-Theory-Presentation/categories.html>Click here to go to the HTML presentation.</a><li><a href=http://yogsototh.github.com/Category-Theory-Presentation/categories.pdf>Click Here to download the PDF slides (<span style=text-transform:uppercase>L<sup style=vertical-align:.15em;margin-left:-.36em;margin-right:-.15em;font-size:.85em>a</sup>T<sub style=vertical-align:-.5ex;margin-left:-.1667em;margin-right:-.125em;font-size:1em>e</sub>X</span> not rendered properly)</a></ul><p>If you don't want to read them through an HTML presentations framework or downloading a big PDF
just continue to read as a standard web page.<div style=display:none>\(\newcommand{\F}{\mathbf{F}}\)
\(\newcommand{\E}{\mathbf{E}}\)
\(\newcommand{\C}{\mathcal{C}}\)
\(\newcommand{\D}{\mathcal{D}}\)
\(\newcommand{\id}{\mathrm{id}}\)
\(\newcommand{\ob}[1]{\mathrm{ob}(#1)}\)
\(\newcommand{\hom}[1]{\mathrm{hom}(#1)}\)
\(\newcommand{\Set}{\mathbf{Set}}\)
\(\newcommand{\Mon}{\mathbf{Mon}}\)
\(\newcommand{\Vec}{\mathbf{Vec}}\)
\(\newcommand{\Grp}{\mathbf{Grp}}\)
\(\newcommand{\Rng}{\mathbf{Rng}}\)
\(\newcommand{\ML}{\mathbf{ML}}\)
\(\newcommand{\Hask}{\mathbf{Hask}}\)
\(\newcommand{\Cat}{\mathbf{Cat}}\)
\(\newcommand{\fmap}{\mathtt{fmap}}\)</div><section class=slide style=text-align:center><h1 style=position:relative>Category Theory <span class=and>&</span> Programming</h1><div><em class=base01>for</em> <a href=http://www.meetup.com/riviera-scala-clojure>Rivieria Scala Clojure</a> (Note this presentation uses Haskell)</div><author><em class=base01>by</em> <a href=http://yannesposito.com>Yann Esposito</a></author><div style="font-size:.8em;margin:5em auto"><twitter><a href=http://twitter.com/yogsototh>@yogsototh</a>,</twitter>
<googleplus><a href=https://plus.google.com/117858550730178181663>+yogsototh</a></googleplus></div><div class=flush></div></section><section class=slide><h2>Plan</h2><ul style=font-size:2em;font-weight:700><li><span class=orange>General overview<li>Definitions<li>Applications</ul><div class=flush></div></section><section class=slide><h2 id=not-really-about-cat-glory>Not really about: Cat <span class=and>&</span> glory</h2><figure><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/categlory.jpg alt="Cat n glory"><figcaption>credit to Tokuhiro Kawai (川井徳寛)</figcaption></figure><div class=flush></div></section><section class=slide><h2 id=general-overview>General Overview</h2><div style=float:right;width:18%><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/eilenberg.gif alt="Samuel Eilenberg"> <img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/maclaine.jpg alt="Saunders Mac Lane"></div><p><em>Recent Math Field</em><br>1942-45, Samuel Eilenberg <span class=and>&</span> Saunders Mac Lane<p>Certainly one of the more abstract branches of math<ul><li><em>New math foundation</em><br>formalism abstraction, package entire theory<sup>★</sup><li><em>Bridge between disciplines</em><br>Physics, Quantum Physics, Topology, Logic, Computer Science<sup>☆</sup></ul><p class=base01 style="border-top:solid 1px;width:70%;font-size:.7em">★: <a href=http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf>When is one thing equal to some other thing?, Barry Mazur, 2007</a><br>☆: <a href=http://math.ucr.edu/home/baez/rosetta.pdf>Physics, Topology, Logic and Computation: A Rosetta Stone, John C. Baez, Mike Stay, 2009</a><div class=flush></div></section><section class=slide><h2 id=from-a-programmer-perspective>From a Programmer perspective</h2><blockquote><p>Category Theory is a new language/framework for Math</blockquote><ul><li>Another way of thinking<li>Extremely efficient for generalization</ul><div class=flush></div></section><section class=slide><h2 id=math-programming-relation>Math Programming relation</h2><img class=right src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/buddha.gif alt="Buddha Fractal"><p>Programming <em><span class=orange>is</span></em> doing Math<p>Strong relations between type theory and category theory.<p>Not convinced?<br>Certainly a <em>vocabulary</em> problem.<p>One of the goal of Category Theory is to create a <em>homogeneous vocabulary</em> between different disciplines.<div class=flush></div></section><section class=slide><h2 id=vocabulary>Vocabulary</h2><img class=right src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mindblown.gif alt="mind blown"><p>Math vocabulary used in this presentation:<blockquote style=width:55%><p>Category, Morphism, Associativity, Preorder, Functor, Endofunctor, Categorial property, Commutative diagram, Isomorph, Initial, Dual, Monoid, Natural transformation, Monad, Klesli arrows, κατα-morphism, ...</blockquote><div class=flush></div></section><section class=slide><h2 id=programmer-translation>Programmer Translation</h2><img class=right src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/readingcat.jpg alt=lolcat><table style=width:50%><tr><th>Mathematician<th>Programmer<tr><td>Morphism<td>Arrow<tr><td>Monoid<td>String-like<tr><td>Preorder<td>Acyclic graph<tr><td>Isomorph<td>The same<tr><td>Natural transformation<td>rearrangement function<tr><td>Funny Category<td>LOLCat</table><div class=flush></div></section><section class=slide><h2>Plan</h2><ul style=font-size:2em;font-weight:700><li>General overview<li><span class=orange>Definitions</span><ul class=base01 style="border-left:2px solid;padding-left:1em;font-size:.6em;float:right;font-weight:700;margin:0 0 0 1em;width:17em"><li>Category<li>Intuition<li>Examples<li>Functor<li>Examples</ul><li>Applications</ul><div class=flush></div></section><section class=slide><h2>Category</h2><p>A way of representing <strong><em>things</em></strong> and <strong><em>ways to go between things</em></strong>.<p>A Category \(\mathcal{C}\) is defined by:<ul><li><em>Objects <span class=orange>\(\ob{C}\)</span></em>,<li><em>Morphisms <span class=orange>\(\hom{C}\)</span></em>,<li>a <em>Composition law <span class=orange>(∘)</span></em><li>obeying some <em>Properties</em>.</ul><div class=flush></div></section><section class=slide><h2>Category: Objects</h2><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/objects.png alt=objects><p>\(\ob{\mathcal{C}}\) is a collection<div class=flush></div></section><section class=slide><h2>Category: Morphisms</h2><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/morphisms.png alt=morphisms><p>\(A\) and \(B\) objects of \(\C\)<br>\(\hom{A,B}\) is a collection of morphisms<br>\(f:A→B\) denote the fact \(f\) belongs to \(\hom{A,B}\)<p>\(\hom{\C}\) the collection of all morphisms of \(\C\)<div class=flush></div></section><section class=slide><h2>Category: Composition</h2><p>Composition (∘): associate to each couple \(f:A→B, g:B→C\)
$$g∘f:A\rightarrow C$$</p><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/composition.png alt=composition><div class=flush></div></section><section class=slide><h2>Category laws: neutral element</h2><p>for each object \(X\), there is an \(\id_X:X→X\),<br>such that for each \(f:A→B\):</p><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/identity.png alt=identity><div class=flush></div></section><section class=slide><h2>Category laws: Associativity</h2><p>Composition is associative:</p><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/associativecomposition.png alt="associative composition"><div class=flush></div></section><section class=slide><h2>Commutative diagrams</h2><p>Two path with the same source and destination are equal.<figure class=left style=max-width:40%;margin-left:5%><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/commutative-diagram-assoc.png alt="Commutative Diagram (Associativity)"><figcaption>\((h∘g)∘f = h∘(g∘f) \)</figcaption></figure><figure class=right style=max-width:31%;margin-right:10%><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/commutative-diagram-id.png alt="Commutative Diagram (Identity law)"><figcaption>\(id_B∘f = f = f∘id_A \)</figcaption></figure><div class=flush></div></section><section class=slide><h2>Question Time!</h2><figure style="width:70%;margin:0 auto"><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/batquestion.jpg width=100%><figcaption><em>- French-only joke -</em></figcaption></figure><div class=flush></div></section><section class=slide><h2>Can this be a category?</h2><p>\(\ob{\C},\hom{\C}\) fixed, is there a valid ∘?<figure class=left><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example1.png alt="Category example 1"><figcaption class=slide><span class=green>YES</span></figcaption></figure><figure class=left><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example2.png alt="Category example 2"><figcaption class=slide>no candidate for \(g∘f\)<br><span class=red>NO</span></figcaption></figure><figure class=left><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example3.png alt="Category example 3"><figcaption class=slide><span class=green>YES</span></figcaption></figure><div class=flush></div></section><section class=slide><h2>Can this be a category?</h2><figure class=left><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example4.png alt="Category example 4"><figcaption class=slide>no candidate for \(f:C→B\)<br><span class=red>NO</span></figcaption></figure><figure class=right style=min-width:50%><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example5.png alt="Category example 5"><figcaption class=slide>\((h∘g)∘f=\id_B∘f=f\)<br>\(h∘(g∘f)=h∘\id_A=h\)<br>but \(h≠f\)<br><span class=red>NO</span></figcaption></figure><div class=flush></div></section><section class=slide><h2>Categories Examples</h2><figure style="width:70%;margin:0 auto"><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/basket_of_cats.jpg alt="Basket of cats"><figcaption><em>- Basket of Cats -</em></figcaption></figure><div class=flush></div></section><section class=slide><h2>Category \(\Set\)</h2><ul><li>\(\ob{\Set}\) are <em>all</em> the sets<li>\(\hom{E,F}\) are <em>all</em> functions from \(E\) to \(F\)<li>∘ is functions composition</ul><ul class=slide><li>\(\ob{\Set}\) is a proper class ; not a set<li>\(\hom{E,F}\) is a set<li>\(\Set\) is then a <em>locally <b>small</b> category</em></ul><div class=flush></div></section><section class=slide><h2>Categories Everywhere?</h2><img class=right src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/cats-everywhere.jpg alt="Cats everywhere"><ul><li>\(\Mon\): (monoids, monoid morphisms,∘)<li>\(\Vec\): (Vectorial spaces, linear functions,∘)<li>\(\Grp\): (groups, group morphisms,∘)<li>\(\Rng\): (rings, ring morphisms,∘)<li>Any deductive system <i>T</i>: (theorems, proofs, proof concatenation)<li>\( \Hask\): (Haskell types, functions, <code>(.)</code> )<li>...</ul><div class=flush></div></section><section class=slide><h2>Smaller Examples</h2><h3>Strings</h3><img class=right style=max-width:17% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/strings.png alt="Monoids are one object categories"><ul><li>\(\ob{Str}\) is a singleton<li>\(\hom{Str}\) each string<li>∘ is concatenation <code>(++)</code></ul><ul><li><code>"" ++ u = u = u ++ ""</code><li><code>(u ++ v) ++ w = u ++ (v ++ w)</code></ul><div class=flush></div></section><section class=slide><h2>Finite Example?</h2><h3>Graph</h3><figure class=right style=max-width:40%><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/graph-category.png alt="Each graph is a category"></figure><ul><li>\(\ob{G}\) are vertices<li>\(\hom{G}\) each path<li>∘ is path concatenation</ul><ul><li>\(\ob{G}=\{X,Y,Z\}\),<li>\(\hom{G}=\{ε,α,β,γ,αβ,βγ,...\}\)<li>\(αβ∘γ=αβγ\)</ul><div class=flush></div></section><section class=slide><h2>Number construction</h2><h3>Each Numbers as a whole category</h3><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/numbers.png alt="Each number as a category"><div class=flush></div></section><section class=slide><h2>Degenerated Categories: Monoids</h2><img class=right style=max-width:17% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/monoid.png alt="Monoids are one object categories"><p>Each Monoid \((M,e,⊙): \ob{M}=\{∙\},\hom{M}=M,\circ = ⊙\)<p class=orange>Only one object.<p>Examples:<ul><li><code>(Integer,0,+)</code>, <code>(Integer,1,*)</code>,<li><code>(Strings,"",++)</code>, for each <code>a</code>, <code>([a],[],++)</code></ul><div class=flush></div></section><section class=slide><h2>Degenerated Categories: Preorders \((P,≤)\)</h2><ul><li>\(\ob{P}={P}\),<li>\(\hom{x,y}=\{x≤y\} ⇔ x≤y\),<li>\((y≤z) \circ (x≤y) = (x≤z) \)</ul><p><em class=orange>At most one morphism between two objects.</em></p><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/preorder.png alt="preorder category"><div class=flush></div></section><section class=slide><h2>Degenerated Categories: Discrete Categories</h2><img class=right src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/set.png alt="Any set can be a category"><h3>Any Set</h3><p>Any set \(E: \ob{E}=E, \hom{x,y}=\{x\} ⇔ x=y \)<p class=orange>Only identities<div class=flush></div></section><section class=slide><h2 id=choice>Choice</h2><p>The same object can be seen in many different way as a category.<p>You can choose what are object, morphisms and composition.<p>ex: <strong>Str</strong> and discrete(Σ<sup>*</sup>)<div class=flush></div></section><section class=slide><h2 class=base1>Categorical Properties</h2><p class=base1>Any property which can be expressed in term of category, objects, morphism and composition.<ul><li><em class=orange>Dual</em>: \(\D\) is \(\C\) with reversed morphisms.<li><em class=orange>Initial</em>: \(Z\in\ob{\C}\) s.t. \(∀Y∈\ob{\C}, \#\hom{Z,Y}=1\)<br>Unique ("up to isormophism")<li><em class=orange>Terminal</em>: \(T\in\ob{\C}\) s.t. \(T\) is initial in the dual of \(\C\)<li><em class=orange>Functor</em>: structure preserving mapping between categories<li>...</ul><div class=flush></div></section><section class=slide><h2 id=isomorph>Isomorph</h2><p><img class=right alt="isomorph cats" src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/isomorph-cats.jpg> <em class=orange>isomorphism</em>: \(f:A→B\) which can be "undone" <em>i.e.</em><br>\(∃g:B→A\), \(g∘f=id_A\) <span class=and>&</span> \(f∘g=id_B\)<br>in this case, \(A\) <span class=and>&</span> \(B\) are <em class=orange>isomorphic</em>.<p><span class=orange>A≌B</span> means A and B are essentially the same.<br>In Category Theory, <span class=orange>=</span> is in fact mostly <span class=orange>≌</span>.<br>For example in commutative diagrams.<div class=flush></div></section><section class=slide><h2>Functor</h2><p>A functor is a mapping between two categories.
Let \(\C\) and \(\D\) be two categories.
A <em>functor</em> <span class=orange>\(\F\)</span> from <span class=blue>\(\C\)</span> to <span class=green>\(\D\)</span>:<ul><li>Associate objects: <span class=backblue>\(A\in\ob{\C}\)</span> to <span class=backgreen>\(\F(A)\in\ob{\D}\)</span><li>Associate morphisms: <span class=backblue>\(f:A\to B\)</span> to <span class=backgreen>\(\F(f) : \F(A) \to \F(B)\)</span>
such that<ul><li>\( \F (\)<span class="backblue blue">\(\id_X\)</span>\()= \)<span class=backgreen><span class=green>\(\id\)</span>\(\vphantom{\id}_{\F(}\)<span class=blue>\(\vphantom{\id}_X\)</span>\(\vphantom{\id}_{)} \)</span>,<li>\( \F (\)<span class="backblue blue">\(g∘f\)</span>\()= \)<span class=backgreen>\( \F(\)<span class=blue>\(g\)</span>\() \)<span class=green>\(\circ\)</span>\( \F(\)<span class=blue>\(f\)</span>\() \)</span></ul></ul><div class=flush></div></section><section class=slide><h2>Functor Example (ob → ob)</h2><img width=65% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/functor.png alt=Functor><div class=flush></div></section><section class=slide><h2>Functor Example (hom → hom)</h2><img width=65% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/functor-morphism.png alt=Functor><div class=flush></div></section><section class=slide><h2>Functor Example</h2><img width=65% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/functor-morphism-color.png alt=Functor><div class=flush></div></section><section class=slide><h2>Endofunctors</h2><p>An <em>endofunctor</em> for \(\C\) is a functor \(F:\C→\C\).</p><img width=75% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/endofunctor.png alt=Endofunctor><div class=flush></div></section><section class=slide><h2>Category of Categories</h2><img style=min-width:43%;width:43% class=right src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/fractalcat.jpg><p>Categories and functors form a category: \(\Cat\)<ul><li>\(\ob{\Cat}\) are categories<li>\(\hom{\Cat}\) are functors<li>∘ is functor composition</ul><div class=flush></div></section><section class=slide><h2>Plan</h2><ul style=font-size:2em;font-weight:700><li>General overview<li>Definitions<li><span class=orange>Applications<ul class=base01 style="border-left:2px solid;padding-left:1em;font-size:.6em;float:right;font-weight:700;margin:-4em 0 0 1em;width:17em"><li>\(\Hask\) category<li>Functors<li>Natural transformations<li>Monads<li>κατα-morphisms</ul></ul><div class=flush></div></section><section class=slide><h2>Hask</h2><p>Category \(\Hask\):</p><img class=right style=max-width:30% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask.png alt="Haskell Category Representation"><ul><li>\(\ob{\Hask} = \) Haskell types<li>\(\hom{\Hask} = \) Haskell functions<li>∘ = <code>(.)</code> Haskell function composition</ul><p>Forget glitches because of <code>undefined</code>.<div class=flush></div></section><section class=slide><h2 id=haskell-kinds>Haskell Kinds</h2><p>In Haskell some types can take type variable(s). Typically: <code>[a]</code>.<p>Types have <em>kinds</em>; The kind is to type what type is to function. Kind are the types for types (so meta).<pre><code>Int, Char :: *
[], Maybe :: * -&gt; *
(,), (-&gt;) :: * -&gt; * -&gt; *
[Int], Maybe Char, Maybe [Int] :: *</code></pre><div class=flush></div></section><section class=slide><h2 id=haskell-types>Haskell Types</h2><p>Sometimes, the type determine a lot about the function<sup>★</sup>:<pre class=haskell><code>fst :: (a,b) -> a -- Only one choice
snd :: (a,b) -> b -- Only one choice
f :: a -> [a]     -- Many choices
-- Possibilities: f x=[], or [x], or [x,x] or [x,...,x]

? :: [a] -> [a] -- Many choices
-- can only rearrange: duplicate/remove/reorder elements
-- for example: the type of addOne isn't [a] -> [a]
addOne l = map <span class=red>(+1)</span> l
-- The (+1) force 'a' to be a Num.</code></pre><p><p><span class="small base01">★:<a href=http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf>Theorems for free!, Philip Wadler, 1989</a></span><div class=flush></div></section><section class=slide><h2>Haskell Functor vs \(\Hask\) Functor</h2><p>A Haskell Functor is a type <code>F :: * -> *</code> which belong to the type class <code>Functor</code> ; thus instantiate
<code>fmap :: (a -> b) -> (F a -> F b)</code>.<p><span style=visibility:hidden><span class=and>&</span></span> <code>F</code>: \(\ob{\Hask}→\ob{\Hask}\)<br><span class=and>&</span> <code>fmap</code>: \(\hom{\Hask}→\hom{\Hask}\)<p>The couple <code>(F,fmap)</code> is a \(\Hask\)'s functor if for any <code>x :: F a</code>:<ul><li><code>fmap id x = x</code><li><code>fmap (f.g) x= (fmap f . fmap g) x</code></ul><div class=flush></div></section><section class=slide><h2>Haskell Functors Example: Maybe</h2><pre class=haskell><code>data Maybe a = Just a | Nothing
instance Functor Maybe where
    fmap :: (a -> b) -> (Maybe a -> Maybe b)
    fmap f (Just a) = Just (f a)
    fmap f Nothing = Nothing</code></pre><pre class=haskell><code>fmap (+1) (Just 1) == Just 2
fmap (+1) Nothing  == Nothing
fmap head (Just [1,2,3]) == Just 1</code></pre><div class=flush></div></section><section class=slide><h2>Haskell Functors Example: List</h2><pre class=haskell><code>instance Functor ([]) where
	fmap :: (a -> b) -> [a] -> [b]
	fmap = map</pre></code><pre class=haskell><code>fmap (+1) [1,2,3]           == [2,3,4]
fmap (+1) []                == []
fmap head [[1,2,3],[4,5,6]] == [1,4]</code></pre><div class=flush></div></section><section class=slide><h2 id=haskell-functors-for-the-programmer>Haskell Functors for the programmer</h2><p><code>Functor</code> is a type class used for types that can be mapped over.<ul><li>Containers: <code>[]</code>, Trees, Map, HashMap...<li>"Feature Type":<ul><li><code>Maybe a</code>: help to handle absence of <code>a</code>.<br>Ex: <code>safeDiv x 0 ⇒ Nothing</code><li><code>Either String a</code>: help to handle errors<br>Ex: <code>reportDiv x 0 ⇒ Left "Division by 0!"</code></ul></ul><div class=flush></div></section><section class=slide><h2>Haskell Functor intuition</h2><p>Put normal function inside a container. Ex: list, trees...<p><img width=70% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/boxfunctor.png alt="Haskell Functor as a box play"><div class=flush></div></section><section class=slide><h2>Haskell Functor properties</h2><p>Haskell Functors are:<ul><li><em>endofunctors</em> ; \(F:\C→\C\) here \(\C = \Hask\),<li>a couple <b>(Object,Morphism)</b> in \(\Hask\).</ul><div class=flush></div></section><section class=slide><h2>Functor as boxes</h2><p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types look like a fractal:</p><img width=70% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask-endofunctor.png alt="Haskell functor representation"><div class=flush></div></section><section class=slide><h2>Functor as boxes</h2><p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types look like a fractal:</p><img width=70% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask-endofunctor-objects.png alt="Haskell functor representation"><div class=flush></div></section><section class=slide><h2>Functor as boxes</h2><p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types look like a fractal:</p><img width=70% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask-endofunctor-morphisms.png alt="Haskell functor representation"><div class=flush></div></section><section class=slide><h2 id=non-haskell-hasks-functors>"Non Haskell" Hask's Functors</h2><p>A simple basic example is the \(id_\Hask\) functor. It simply cannot be expressed as a couple (<code>F</code>,<code>fmap</code>) where<ul><li><code>F::* -> *</code><li><code>fmap :: (a -> b) -> (F a) -> (F b)</code></ul><p>Another example:<ul><li>F(<code>T</code>)=<code>Int</code><li>F(<code>f</code>)=<code>\_->0</code></ul><div class=flush></div></section><section class=slide><h2 id=also-functor-inside-hask>Also Functor inside \(\Hask\)</h2><p>\(\mathtt{[a]}∈\ob{\Hask}\)</code> but is also a category. Idem for <code>Int</code>.<p><code>length</code> is a Functor from the category <code>[a]</code> to the category <code>Int</code>:<ul class=left style=max-width:40%><li>\(\ob{\mathtt{[a]}}=\{∙\}\)<li>\(\hom{\mathtt{[a]}}=\mathtt{[a]}\)<li>\(∘=\mathtt{(++)}\)</ul><p class=left style="margin:2em 3em">⇒<ul class=left style=max-width:40%><li>\(\ob{\mathtt{Int}}=\{∙\}\)<li>\(\hom{\mathtt{Int}}=\mathtt{Int}\)<li>\(∘=\mathtt{(+)}\)</ul><div class=flush></div><ul><li>id: <code>length [] = 0</code><li>comp: <code>length (l ++ l') = (length l) + (length l')</code></ul><div class=flush></div></section><section class=slide><h2 id=category-of-hask-endofunctors>Category of \(\Hask\) Endofunctors</h2><img width=50% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-hask-endofunctor.png alt="Category of Hask endofunctors"><div class=flush></div></section><section class=slide><h2 id=category-of-functors>Category of Functors</h2><p>If \(\C\) is <em>small</em> (\(\hom{\C}\) is a set). All functors from \(\C\) to some category \(\D\) form the category \(\mathrm{Func}(\C,\D)\).<ul><li>\(\ob{\mathrm{Func}(\C,\D)}\): Functors \(F:\C→\D\)<li>\(\hom{\mathrm{Func}(\C,\D)}\): <em>natural transformations</em><li>∘: Functor composition</ul><p>\(\mathrm{Func}(\C,\C)\) is the category of endofunctors of \(\C\).<div class=flush></div></section><section class=slide><h2 id=natural-transformations>Natural Transformations</h2><p>Let \(F\) and \(G\) be two functors from \(\C\) to \(\D\).<p><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/natural-transformation.png alt="Natural transformation commutative diagram" class=right> <em>A natural transformation:</em> familly η ; \(η_X\in\hom{\D}\) for \(X\in\ob{\C}\) s.t.<p>ex: between Haskell functors; <code>F a -> G a</code><br>Rearragement functions only.<div class=flush></div></section><section class=slide><h2 id=natural-transformation-examples-14>Natural Transformation Examples (1/4)</h2><pre><code class="haskell small">data List a = Nil | Cons a (List a)
toList :: [a] -> List a
toList [] = Nil
toList (x:xs) = Cons x (toList xs)</code></pre><p><code>toList</code> is a natural transformation. It is also a morphism from <code>[]</code> to <code>List</code> in the Category of \(\Hask\) endofunctors.</p><img style=float:left;width:30%;margin-left:1em src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-list-tree.png alt="natural transformation commutative diagram"><figure style=float:right;width:50%><img style=width:40% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/list-tree-endofunctor-morphism.png alt="natural transformation commutative diagram"></figure><div class=flush></div></section><section class=slide><h2 id=natural-transformation-examples-24>Natural Transformation Examples (2/4)</h2><pre><code class="haskell small">data List a = Nil | Cons a (List a)
toHList :: List a -> [a]
toHList Nil = []
toHList (Cons x xs) = x:toHList xs</code></pre><p><code>toHList</code> is a natural transformation. It is also a morphism from <code>List</code> to <code>[]</code> in the Category of \(\Hask\) endofunctors.</p><img style=float:left;width:30%;margin-left:1em src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-tree-list.png alt="natural transformation commutative diagram"><figure style=float:right;width:50%><img style=width:40% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/tree-list-endofunctor-morphism.png alt="natural transformation commutative diagram"><figcaption><code>toList . toHList = id</code> <span class=and>&</span> <code>toHList . toList = id</code> <span style=visibility:hidden><span class=and>&</span></span><br>therefore <code>[]</code> <span class=and>&</span> <code>List</code> are <span class=orange>isomorph</span>.</figcaption></figure><div class=flush></div></section><section class=slide><h2 id=natural-transformation-examples-34>Natural Transformation Examples (3/4)</h2><pre><code class="haskell small">toMaybe :: [a] -> Maybe a
toMaybe [] = Nothing
toMaybe (x:xs) = Just x</code></pre><p><code>toMaybe</code> is a natural transformation. It is also a morphism from <code>[]</code> to <code>Maybe</code> in the Category of \(\Hask\) endofunctors.</p><img style=float:left;width:30%;margin-left:1em src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-list-maybe.png alt="natural transformation commutative diagram"><figure style=float:right;width:50%><img style=width:40% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/list-maybe-endofunctor-morphism.png alt="natural transformation commutative diagram"></figure><div class=flush></div></section><section class=slide><h2 id=natural-transformation-examples-44>Natural Transformation Examples (4/4)</h2><pre><code class="haskell small">mToList :: Maybe a -> [a]
mToList Nothing = []
mToList Just x  = [x]</code></pre><p><code>toMaybe</code> is a natural transformation. It is also a morphism from <code>[]</code> to <code>Maybe</code> in the Category of \(\Hask\) endofunctors.</p><img style=float:left;width:30%;margin-left:1em src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-maybe-list.png alt="natural transformation commutative diagram"><figure style=float:right;width:50%><img style=width:40% src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/maybe-list-endofunctor-morphsm.png alt="relation between [] and Maybe"><figcaption>There is <span class=red>no isomorphism</span>.<br>Hint: <code>Bool</code> lists longer than 1.</figcaption></figure><div class=flush></div></section><section class=slide><h2 id=composition-problem>Composition problem</h2><p>The Problem; example with lists:<pre class=haskell><code>f x = [x]       ⇒ f 1 = [1]   ⇒ (f.f) 1 = [[1]] ✗
g x = [x+1]     ⇒ g 1 = [2]   ⇒ (g.g) 1 = ERROR [2]+1 ✗
h x = [x+1,x*3] ⇒ h 1 = [2,3] ⇒ (h.h) 1 = ERROR [2,3]+1 ✗ </code></pre><p>The same problem with most <code>f :: a -> F a</code> functions and functor <code>F</code>.<div class=flush></div></section><section class=slide><h2 id=composition-fixable>Composition Fixable?</h2><p>How to fix that? We want to construct an operator which is able to compose:<p><code>f :: a -> F b</code> <span class=and>&</span> <code>g :: b -> F c</code>.<p>More specifically we want to create an operator ◎ of type<p><code>◎ :: (b -> F c) -> (a -> F b) -> (a -> F c)</code><p>Note: if <code>F</code> = I, ◎ = <code>(.)</code>.<div class=flush></div></section><section class=slide><h2 id=fix-composition-12>Fix Composition (1/2)</h2><p>Goal, find: <code>◎ :: (b -> F c) -> (a -> F b) -> (a -> F c)</code><br><code>f :: a -> F b</code>, <code>g :: b -> F c</code>:<ul><li><code>(g ◎ f) x</code> ???<li>First apply <code>f</code> to <code>x</code> ⇒ <code>f x :: F b</code><li>Then how to apply <code>g</code> properly to an element of type <code>F b</code>?</ul><div class=flush></div></section><section class=slide><h2 id=fix-composition-22>Fix Composition (2/2)</h2><p>Goal, find: <code>◎ :: (b -> F c) -> (a -> F b) -> (a -> F c)</code><br><code>f :: a -> F b</code>, <code>g :: b -> F c</code>, <span class=orange><code>f x :: F b</code></span>:<ul><li>Use <code>fmap :: (t -> u) -> (F t -> F u)</code>!<li><code>(fmap g) :: F b -> F (F c)</code> ; (<code>t=b</code>, <code>u=F c</code>)<li><code>(fmap g) (f x) :: F (F c)</code> it almost WORKS!<li>We lack an important component, <code>join :: F (F c) -> F c</code><li><code>(g ◎ f) x = join ((fmap g) (f x))</code> ☺<br>◎ is the Kleisli composition; in Haskell: <code>&lt;=&lt;</code> (in <code>Control.Monad</code>).</ul><div class=flush></div></section><section class=slide><h2 id=necessary-laws>Necessary laws</h2><p>For ◎ to work like composition, we need join to hold the following properties:<ul><li><code>join (join (F (F (F a))))=join (F (join (F (F a))))</code><li>abusing notations denoting <code>join</code> by ⊙; this is equivalent to<br><span class=orange><code>(F ⊙ F) ⊙ F = F ⊙ (F ⊙ F)</code></span><li>There exists <code>η :: a -> F a</code> s.t.<br><span class=orange><code>η⊙F=F=F⊙η</code></span></ul><div class=flush></div></section><section class=slide><h2 id=klesli-composition>Klesli composition</h2><p>Now the composition works as expected. In Haskell ◎ is <code>&lt;=&lt;</code> in <code>Control.Monad</code>.<p><code>g &lt;=&lt; f = \x -> join ((fmap g) (f x))</code><pre class=haskell><code>f x = [x]       ⇒ f 1 = [1]   ⇒ (f <=< f) 1 = [1] ✓
g x = [x+1]     ⇒ g 1 = [2]   ⇒ (g <=< g) 1 = [3] ✓
h x = [x+1,x*3] ⇒ h 1 = [2,3] ⇒ (h <=< h) 1 = [3,6,4,9] ✓</code></pre><div class=flush></div></section><section class=slide><h2 id=we-reinvented-monads>We reinvented Monads!</h2><p>A monad is a triplet <code>(M,⊙,η)</code> where<ul><li>\(M\) an <span class=orange>Endofunctor</span> (to type <code>a</code> associate <code>M a</code>)<li>\(⊙:M×M→M\) a <span class=orange>nat. trans.</span> (i.e. <code>⊙::M (M a) → M a</code> ; <code>join</code>)<li>\(η:I→M\) a <span class=orange>nat. trans.</span> (\(I\) identity functor ; <code>η::a → M a</code>)</ul><p>Satisfying<ul><li>\(M ⊙ (M ⊙ M) = (M ⊙ M) ⊙ M\)<li>\(η ⊙ M = M = M ⊙ η\)</ul><div class=flush></div></section><section class=slide><h2 id=compare-with-monoid>Compare with Monoid</h2><p>A Monoid is a triplet \((E,∙,e)\) s.t.<ul><li>\(E\) a set<li>\(∙:E×E→E\)<li>\(e:1→E\)</ul><p>Satisfying<ul><li>\(x∙(y∙z) = (x∙y)∙z, ∀x,y,z∈E\)<li>\(e∙x = x = x∙e, ∀x∈E\)</ul><div class=flush></div></section><section class=slide><h2 id=monads-are-just-monoids>Monads are just Monoids</h2><blockquote><p>A Monad is just a monoid in the category of endofunctors, what's the problem?</blockquote><p>The real sentence was:<blockquote><p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</blockquote><div class=flush></div></section><section class=slide><h2 id=example-list>Example: List</h2><ul><li><code>[] :: * -> *</code> an <span class=orange>Endofunctor</span><li>\(⊙:M×M→M\) a nat. trans. (<code>join :: M (M a) -> M a</code>)<li>\(η:I→M\) a nat. trans.</ul><pre class=haskell><code>-- In Haskell ⊙ is "join" in "Control.Monad"
join :: [[a]] -> [a]
join = concat

-- In Haskell the "return" function (unfortunate name)
η :: a -> [a]
η x = [x]</code></pre><div class=flush></div></section><section class=slide><h2 id=example-list-law-verification>Example: List (law verification)</h2><p>Example: <code>List</code> is a functor (<code>join</code> is ⊙)<ul><li>\(M ⊙ (M ⊙ M) = (M ⊙ M) ⊙ M\)<li>\(η ⊙ M = M = M ⊙ η\)</ul><pre class="nohighlight small"><code>join [ join [[x,y,...,z]] ] = join [[x,y,...,z]]
                            = join (join [[[x,y,...,z]]])
join (η [x]) = [x] = join [η x]</code></pre><p>Therefore <code>([],join,η)</code> is a monad.<div class=flush></div></section><section class=slide><h2 id=monads-utility>Monads useful?</h2><p>A <em>LOT</em> of monad tutorial on the net. Just one example; the State Monad<p><code>DrawScene</code> to <code><span class=orange>State Screen</span> DrawScene</code> ; still <b>pure</b>.<pre class="haskell left smaller" style=width:40%><code>main = drawImage (width,height)

drawImage :: Screen -&gt; DrawScene
drawImage <span class=orange>screen</span> = do
    drawPoint p <span class=orange>screen</span>
    drawCircle c <span class=orange>screen</span>
    drawRectangle r <span class=orange>screen</span>

drawPoint point <span class=orange>screen</span> = ...
drawCircle circle <span class=orange>screen</span> = ...
drawRectangle rectangle <span class=orange>screen</span> = ...</code></pre><pre class="haskell right smaller" style=width:40%><code>main = do
    <span class=orange>put (Screen 1024 768)</span>
    drawImage

drawImage :: State Screen DrawScene
drawImage = do
    drawPoint p
    drawCircle c
    drawRectangle r

drawPoint :: Point -&gt;
               State Screen DrawScene
drawPoint p = do
    <span class=orange>Screen width height &lt;- get</span>
    ...</code></pre><div class=flush></div></section><section class=slide><h2 id=fold><code>fold</code></h2><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/tower_folded.gif alt=fold style=width:50%;max-width:50%><div class=flush></div></section><section class=slide><h2 id=κατα-morphism>κατα-morphism</h2><img src=http://yogsototh.github.com/Category-Theory-Presentation/categories/img/earth_catamorphed.gif alt=catamorphism style=width:90%;max-width:90%><div class=flush></div></section><section class=slide><h2 id=κατα-morphism-fold-generalization>κατα-morphism: fold generalization</h2><p><code>acc</code> type of the "accumulator":<br><code>fold :: (acc -> a -> acc) -> acc -> [a] -> acc</code><p>Idea: put the accumulated value inside the type.<pre class=haskell><code>-- Equivalent to fold (+1) 0 "cata"
(Cons 'c' (Cons 'a' (Cons 't' (Cons 'a' Nil))))
(Cons 'c' (Cons 'a' (Cons 't' (Cons 'a' <span style="border:solid 1px">0</span>))))
(Cons 'c' (Cons 'a' (Cons 't' <span style="border:solid 1px">1</span>)))
(Cons 'c' (Cons 'a' <span style="border:solid 1px">2</span>))
(Cons 'c' <span style="border:solid 1px">3</span>)
<span style="border:solid 1px">4</span></code></pre><p>But where are all the informations? <code>(+1)</code> and <code>0</code>?<div class=flush></div></section><section class=slide><h2 id=κατα-morphism-missing-information>κατα-morphism: Missing Information</h2><p>Where is the missing information?<ul><li>Functor operator <code>fmap</code><li>Algebra representing the <code>(+1)</code> and also knowing about the <code>0</code>.</ul><p>First example, make <code>length</code> on <code>[Char]</code><div class=flush></div></section><section class=slide><h2 id=κατα-morphism-type-work>κατα-morphism: Type work</h2><pre class=haskell><code>
data StrF a = Cons Char a | Nil
data Str' = StrF Str'

-- generalize the construction of Str to other datatype
-- Mu: type fixed point
-- Mu :: (* -> *) -> *

data Mu f = InF { outF :: f (Mu f) }
data Str = Mu StrF

-- Example
foo=InF { outF = Cons 'f'
        (InF { outF = Cons 'o'
            (InF { outF = Cons 'o'
                (InF { outF = Nil })})})}</code></pre><div class=flush></div></section><section class=slide><h2 id=κατα-morphism-missing-information-retrieved>κατα-morphism: missing information retrieved</h2><pre class=haskell><code>type Algebra f a = f a -> a
instance Functor (StrF a) =
    fmap f (Cons c x) = Cons c (f x)
    fmap _ Nil = Nil</code></pre><pre class=haskell><code>cata :: Functor f => Algebra f a -> Mu f -> a
cata f = f . fmap (cata f) . outF</code></pre><div class=flush></div></section><section class=slide><h2 id=κατα-morphism-finally-length>κατα-morphism: Finally length</h2><p>All needed information for making length.<pre><code>instance Functor (StrF a) =
    fmap f (Cons c x) = Cons c (f x)
    fmap _ Nil = Nil

length' :: Str -&gt; Int
length' = cata phi where
    phi :: Algebra StrF Int -- StrF Int -&gt; Int
    phi (Cons a b) = 1 + b
    phi Nil = 0

main = do
    l &lt;- length' $ stringToStr &quot;Toto&quot;
    ...</code></pre><div class=flush></div></section><section class=slide><h2 id=κατα-morphism-extension-to-trees>κατα-morphism: extension to Trees</h2><p>Once you get the trick, it is easy to extent to most Functor.<pre><code>type Tree = Mu TreeF
data TreeF x = Node Int [x]

instance Functor TreeF where
  fmap f (Node e xs) = Node e (fmap f xs)

depth = cata phi where
  phi :: Algebra TreeF Int -- TreeF Int -&gt; Int
  phi (Node x sons) = 1 + foldr max 0 sons</code></pre><div class=flush></div></section><section class="slide last"><h2 id=conclusion>Conclusion</h2><p>Category Theory oriented Programming:<ul><li>Focus on the type and operators<li>Extreme generalisation<li>Better modularity<li>Better control through properties of types</ul><p><span class=smaller>No cat were harmed in the making of this presentation.</span><div class=flush></div></section></div><div id=afterarticle><div id=social><a href=../../../../Scratch/fr/blog/feed/feed.xml target=_blank rel="noopener noreferrer nofollow" class=social>RSS</a>
·
<a href="https://twitter.com/home?status=http%3A%2F%2Fyannesposito.com/Scratch/fr/blog/Category-Theory-Presentation/%20via%20@yogsototh" target=_blank rel="noopener noreferrer nofollow" class=social>Tweet</a>
·
<a href="http://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fyannesposito.com/Scratch/fr/blog/Category-Theory-Presentation/" target=_blank rel="noopener noreferrer nofollow" class=social>FB</a><br><a class=message href=../../../../Scratch/fr/blog/Social-link-the-right-way/>Ces liens sociaux préservent votre vie privée</a></div><div id=navigation><a href=../../../../>Accueil</a>
<span class=sep>¦</span>
<a href=../../../../Scratch/fr/blog>Blog</a>
<span class=sep>¦</span>
<a href=../../../../Scratch/fr/softwares>Logiciels</a>
<span class=sep>¦</span>
<a href=../../../../Scratch/fr/about>Auteur</a></div><div id=totop><a href=#header>↑ Top ↑</a></div><div id=bottom><div>Published on 2012-12-12</div><div><a href=https://twitter.com/yogsototh>Follow @yogsototh</a></div><div><a rel=license href=http://creativecommons.org/licenses/by/3.0/deed.en_US>Yann Esposito©</a></div><div>Done with
<a href=http://www.vim.org target=_blank rel="noopener noreferrer nofollow"><strike>Vim</strike></a>
<a href=http://spacemacs.org target=_blank rel="noopener noreferrer nofollow">spacemacs</a>
<span class=pala>&</span>
<a href=http://nanoc.ws target=_blank rel="noopener noreferrer nofollow"><strike>nanoc</strike></a>
<a href=http://jaspervdj.be/hakyll target=_blank rel="noopener noreferrer nofollow">Hakyll</a></div><hr><div style=max-width:100%><a href=https://cardanohub.org><img src=../../../../Scratch/img/ada-logo.png class=simple style=height:16px;border-radius:50%;vertical-align:middle;display:inline-block>
ADA:</a>
<code style=display:inline-block;word-wrap:break-word;text-align:left;vertical-align:top;max-width:85%>DdzFFzCqrhtAvdkmATx5Fm8NPJViDy85ZBw13p4XcNzVzvQg8e3vWLXq23JQWFxPEXK6Kvhaxxe7oJt4VMYHxpA2vtCFiP8fziohN6Yp</code></div></div></div></div></div>