<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>yannesposito.com</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/feed/feed.xml" rel="self" />
    <link href="http://yannesposito.com" />
    <id>http://yannesposito.com/Scratch/fr/blog/feed/feed.xml</id>
    <author>
        <name>Yann Esposito</name>
        <email>yann.esposito@gmail.com</email>
    </author>
    <updated>2014-12-07T00:00:00Z</updated>
    <entry>
    <title>Vim as IDE</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Vim-as-IDE/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Vim-as-IDE/index.html</id>
    <published>2014-12-07T00:00:00Z</published>
    <updated>2014-12-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Vim-as-IDE/vim_spock.jpg" alt="Main image"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Comment utiliser vim comme une IDE très efficace</p>
<p>In <a href="/Scratch/en/blog/Learn-Vim-Progressively/">Learn Vim Progressively</a> I’ve show how Vim is great for editing text, and navigating in the same file (buffer). In this short article you’ll see how I use Vim as an IDE. Mainly by using some great plugins.</p>
</div>
<h2 id="vim-plugin-manager">Vim Plugin Manager</h2>
<p>There are a <em>lot</em> of Vim plugins. To manage them I use <a href="https://github.com/junegunn/vim-plug"><code>vim-plug</code></a>.</p>
<p>To install it:</p>
<pre class="zsh"><code>mkdir -p ~/.vim/autoload
curl -fLo ~/.vim/autoload/plug.vim \
             https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre>
<div class="small">
<p>☞ Note I have two parts in my <code>.vimrc</code>. The first part contains the list of all my plugins. The second part contains the personal preferences I setted for each plugin. I’ll separate each part by <code>...</code> in the code.</p>
</div>
<h2 id="survival">Survival</h2>
<h3 id="colorscheme">Colorscheme</h3>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/solarized.png" alt="Solarized theme"/>
</div>
<p>Before anything, you should protect your eyes using a readable and low contrast colorscheme.</p>
<p>For this I use <a href="http://ethanschoonover.com/solarized">solarized dark</a>. To add it, you only have to write this in your <code>~/.vimrc</code> file:</p>
<pre class="vim"><code>call plug#begin(&#39;~/.vim/plugged&#39;)

Plug &#39;altercation/vim-colors-solarized&#39;

call plug#end()

&quot; -- solarized personal conf
set background=dark
try
    colorscheme solarized
catch
endtry</code></pre>
<h3 id="minimal-hygiene">Minimal hygiene</h3>
<p>You should be able to see and destroy trailing whitespaces.</p>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/trim.gif" alt="Trim whitespaces"/>
</div>
<pre class="vim"><code>Plug &#39;bronson/vim-trailing-whitespace&#39;</code></pre>
<p>You can clean trailing whitespace with <code>:FixWhitespace</code>.</p>
<p>And also you should see your 80th column.</p>
<pre class="vim"><code>if (exists(&#39;+colorcolumn&#39;))
    set colorcolumn=80
    highlight ColorColumn ctermbg=9
endif</code></pre>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/80thcolumn.png" alt="80th column"/>
</div>
<h2 id="file-management">File Management</h2>
<p>One of the most important hidden skills in programming is the ability to search and find files in your projects.</p>
<p>The majority of people use something like <code>NERDTree</code>. This is the classical left column with a tree of files of your project. <em>I stopped to use this</em>. And you should probably too.</p>
<p>I switched to <em>unite</em>. No left column lost. Faster to find files. Mainly it works like Spotlight on OS X.</p>
<p>First install <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code> (the silver search)</a>. If you don’t know <code>ack</code> or <code>ag</code> your life is going to be upgraded. This is a simple but essential tool. It is mostly a <code>grep</code> on steroids.</p>
<pre class="vim"><code>&quot; Unite
&quot;   depend on vimproc
&quot;   ------------- VERY IMPORTANT ------------
&quot;   you have to go to .vim/plugin/vimproc.vim and do a ./make
&quot;   -----------------------------------------
Plug &#39;Shougo/vimproc.vim&#39;
Plug &#39;Shougo/unite.vim&#39;

...

let g:unite_source_history_yank_enable = 1
try
  let g:unite_source_rec_async_command=&#39;ag --nocolor --nogroup -g &quot;&quot;&#39;
  call unite#filters#matcher_default#use([&#39;matcher_fuzzy&#39;])
catch
endtry
&quot; search a file in the filetree
nnoremap &lt;space&gt;&lt;space&gt; :split&lt;cr&gt; :&lt;C-u&gt;Unite -start-insert file_rec/async&lt;cr&gt;
&quot; reset not it is &lt;C-l&gt; normally
:nnoremap &lt;space&gt;r &lt;Plug&gt;(unite_restart)</code></pre>
<p>Now type space twice. A list of files appears. Start to type some letters of the file you are searching for. Select it, type return and bingo the file opens in a new horizontal split.</p>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/unite.gif" alt="Unite example"/>
</div>
<p>If something goes wrong just type <code>&lt;space&gt;r</code> to reset the unite cache.</p>
<p>Now you are able to search file by name easily and efficiently.</p>
<p>Now search text in many files. For this you use <a href="https://github.com/ggreer/the_silver_searcher"><code>ag</code></a>:</p>
<pre class="vim"><code>Plug &#39;rking/ag.vim&#39;
...
&quot; --- type ° to search the word in all files in the current dir
nmap ° :Ag &lt;c-r&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;cr&gt;&lt;cr&gt;
nnoremap &lt;space&gt;/ :Ag</code></pre>
<p>Don’t forget to add a space after the <code>:Ag</code>.</p>
<p>These are two of the most powerful shortcut for working in a project. using <code>°</code> which is nicely positioned on my <code>azerty</code> keyboard. You should use a key close to <code>*</code>.</p>
<p>So what <code>°</code> is doing? It reads the string under the cursor and search for it in all files. Really useful to search where a function is used.</p>
<p>If you type <code>&lt;space&gt;/</code> followed by a string, it will search for all occurrences of this string in the project files.</p>
<p>So with this you should already be able to navigate between files very easily.</p>
<h2 id="language-agnostic-plugins">Language Agnostic Plugins</h2>
<h3 id="git">Git</h3>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/git-gutter.png" alt="Show modified lines"/>
</div>
<p>Show which line changed since your last commit.</p>
<pre class="vim"><code>Plug &#39;airblade/vim-gitgutter&#39;</code></pre>
<p>And the “defacto” git plugin:</p>
<pre class="vim"><code>Plug &#39;tpope/vim-fugitive&#39;</code></pre>
<p>You can reset your changes from the latest git commit with <code>:Gread</code>. You can stage your changes with <code>:Gwrite</code>.</p>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/Gread.gif" alt="Reset changes"/>
</div>
<h3 id="align-things">Align things</h3>
<pre class="vim"><code>Plug &#39;junegunn/vim-easy-align&#39;

...

&quot; Easy align interactive
vnoremap &lt;silent&gt; &lt;Enter&gt; :EasyAlign&lt;cr&gt;</code></pre>
<p>Just select and type <code>Return</code> then <code>space</code>. Type <code>Return</code> many type to change the alignments.</p>
<p>If you want to align the second column, <code>Return</code> then <code>2</code> then <code>space</code>.</p>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/easy-align.gif" alt="Easy align example"/>
</div>
<h3 id="basic-auto-completion-c-n-c-p">Basic auto completion: <code>C-n</code> &amp; <code>C-p</code></h3>
<p>Vim has a basic auto completion system. The shortcuts are <code>C-n</code> and <code>C-p</code> while you are in insert mode. This is generally good enough in most cases. For example when I open a file not in my configured languages.</p>
<h2 id="haskell">Haskell</h2>
<p>My current Haskell programming environment is great!</p>
<p>Each time I save a file, I get a comment pointing to my errors or proposing me how to improve my code.</p>
<p>So here we go:</p>
<blockquote>
<p>☞ Don’t forget to install <code>ghc-mod</code> with: <code>cabal install ghc-mod</code></p>
</blockquote>
<pre class="vim"><code>&quot; ---------- VERY IMPORTANT -----------
&quot; Don&#39;t forget to install ghc-mod with:
&quot; cabal install ghc-mod
&quot; -------------------------------------

Plug &#39;scrooloose/syntastic&#39;             &quot; syntax checker
&quot; --- Haskell
Plug &#39;yogsototh/haskell-vim&#39;            &quot; syntax indentation / highlight
Plug &#39;enomsg/vim-haskellConcealPlus&#39;    &quot; unicode for haskell operators
Plug &#39;eagletmt/ghcmod-vim&#39;
Plug &#39;eagletmt/neco-ghc&#39;
Plug &#39;Twinside/vim-hoogle&#39;
Plug &#39;pbrisbin/html-template-syntax&#39;    &quot; Yesod templates

...

&quot; -------------------
&quot;       Haskell
&quot; -------------------
let mapleader=&quot;-&quot;
let g:mapleader=&quot;-&quot;
set tm=2000
nmap &lt;silent&gt; &lt;leader&gt;ht :GhcModType&lt;CR&gt;
nmap &lt;silent&gt; &lt;leader&gt;hh :GhcModTypeClear&lt;CR&gt;
nmap &lt;silent&gt; &lt;leader&gt;hT :GhcModTypeInsert&lt;CR&gt;
nmap &lt;silent&gt; &lt;leader&gt;hc :SyntasticCheck ghc_mod&lt;CR&gt;:lopen&lt;CR&gt;
let g:syntastic_mode_map={&#39;mode&#39;: &#39;active&#39;, &#39;passive_filetypes&#39;: [&#39;haskell&#39;]}
let g:syntastic_always_populate_loc_list = 1
nmap &lt;silent&gt; &lt;leader&gt;hl :SyntasticCheck hlint&lt;CR&gt;:lopen&lt;CR&gt;

&quot; Auto-checking on writing
autocmd BufWritePost *.hs,*.lhs GhcModCheckAndLintAsync

&quot;  neocomplcache (advanced completion)
autocmd BufEnter *.hs,*.lhs let g:neocomplcache_enable_at_startup = 1
function! SetToCabalBuild()
    if glob(&quot;*.cabal&quot;) != &#39;&#39;
        set makeprg=cabal\ build
    endif
endfunction
autocmd BufEnter *.hs,*.lhs :call SetToCabalBuild()

&quot; -- neco-ghc
let $PATH=$PATH.&#39;:&#39;.expand(&quot;~/.cabal/bin&quot;)</code></pre>
<p>Just enjoy!</p>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/vim-lint.gif" alt="hlint on save"/>
</div>
<p>I use <code>-</code> for my leader because I use <code>,</code> a lot for its native usage.</p>
<ul>
<li><code>-ht</code> will highlight and show the type of the block under the cursor.</li>
<li><code>-hT</code> will insert the type of the current block.</li>
<li><code>-hh</code> will unhighlight the selection.</li>
</ul>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/auto-typing.gif" alt="Auto typing on save"/>
</div>
<h2 id="clojure">Clojure</h2>
<div>
<img src="/Scratch/img/blog/Vim-as-IDE/clojure.gif" alt="Rainbow parenthesis"/>
</div>
<p>My main language at work is Clojure. And my current vim environment is quite good. I lack the automatic integration to <code>lein-kibit</code> thought. If I have the courage I might do it myself one day. But due to the very long startup time of clojure, I doubt I’ll be able to make a useful vim plugin.</p>
<p>So mainly you’ll have real rainbow-parenthesis (the default values are broken for solarized).</p>
<p>I used the vim <code>paredit</code> plugin before. But it is too restrictive. Now I use <code>sexp</code> which feel more coherent with the spirit of vim.</p>
<pre class="vim"><code>&quot; &quot; -- Clojure
Plug &#39;kien/rainbow_parentheses.vim&#39;
Plug &#39;guns/vim-clojure-static&#39;
Plug &#39;guns/vim-sexp&#39;
Plug &#39;tpope/vim-repeat&#39;
Plug &#39;tpope/vim-fireplace&#39;

...

autocmd BufEnter *.cljs,*.clj,*.cljs.hl RainbowParenthesesActivate
autocmd BufEnter *.cljs,*.clj,*.cljs.hl RainbowParenthesesLoadRound
autocmd BufEnter *.cljs,*.clj,*.cljs.hl RainbowParenthesesLoadSquare
autocmd BufEnter *.cljs,*.clj,*.cljs.hl RainbowParenthesesLoadBraces
autocmd BufEnter *.cljs,*.clj,*.cljs.hl setlocal iskeyword+=?,-,*,!,+,/,=,&lt;,&gt;,.,:
&quot; -- Rainbow parenthesis options
let g:rbpt_colorpairs = [
	\ [&#39;darkyellow&#39;,  &#39;RoyalBlue3&#39;],
	\ [&#39;darkgreen&#39;,   &#39;SeaGreen3&#39;],
	\ [&#39;darkcyan&#39;,    &#39;DarkOrchid3&#39;],
	\ [&#39;Darkblue&#39;,    &#39;firebrick3&#39;],
	\ [&#39;DarkMagenta&#39;, &#39;RoyalBlue3&#39;],
	\ [&#39;darkred&#39;,     &#39;SeaGreen3&#39;],
	\ [&#39;darkyellow&#39;,  &#39;DarkOrchid3&#39;],
	\ [&#39;darkgreen&#39;,   &#39;firebrick3&#39;],
	\ [&#39;darkcyan&#39;,    &#39;RoyalBlue3&#39;],
	\ [&#39;Darkblue&#39;,    &#39;SeaGreen3&#39;],
	\ [&#39;DarkMagenta&#39;, &#39;DarkOrchid3&#39;],
	\ [&#39;Darkblue&#39;,    &#39;firebrick3&#39;],
	\ [&#39;darkcyan&#39;,    &#39;SeaGreen3&#39;],
	\ [&#39;darkgreen&#39;,   &#39;RoyalBlue3&#39;],
	\ [&#39;darkyellow&#39;,  &#39;DarkOrchid3&#39;],
	\ [&#39;darkred&#39;,     &#39;firebrick3&#39;],
	\ ]</code></pre>
<p>Working with Clojure will becomre quite smoother. You can eval any part of your code, you must launch a Clojure REPL manually in another terminal thought.</p>
<h2 id="last-words">Last words</h2>
<p>I hope it will be useful.</p>
<p>Last but not least, if you want to use my vim configuration you can get it here:</p>
<p><a href="http://github.com/yogsototh/vimrc"><code>github.com/yogsototh/vimrc</code></a></p>]]></summary>
</entry>
<entry>
    <title>Installer Haskell</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Safer-Haskell-Install/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Safer-Haskell-Install/index.html</id>
    <published>2014-08-16T00:00:00Z</published>
    <updated>2014-08-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Safer-Haskell-Install/main.jpg" alt="to Haskell and Beyond!!!"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Pour installer Haskell (OS X et Linux) copiez/collez les lignes suivante dans un terminal&nbsp;:</p>
<pre><code>curl -O https://raw.githubusercontent.com/yogsototh/install-haskell/master/install-haskell.sh
chmod ugo+x install-haskell.sh
sudo ./install-haskell.sh $USER</code></pre>
<p>Si vous êtes sous windows, téléchargez Haskell Platform et suivez les instructions pour utiliser <a href="http://www.stackage.org/lts">Haskell LTS</a>.</p>
<p>Si vous voulez savoir le pourquoi et le comment ; lisez le reste de l’article.</p>
</div>
<h2 id="pourquoi">Pourquoi ?</h2>
<p>La plus grande faiblesse d’Haskell n’a rien à voir avec le langage en lui-même mais avec son écosystème.</p>
<p>The main problem I’ll try to address is the one known as <em>cabal hell</em>. The community is really active in fixing the issue. I am very confident that in less than a year this problem will be one of the past. But to work today, I provide an install method that should reduce greatly two effects of cabal hell:</p>
<ul>
<li>dependency error</li>
<li>lost time in compilation (poor polar bears)</li>
</ul>
<p>With my actual installation method, you should minimize your headache and almost never hit a dependency error. But there could exists some. If you encounter any dependency error, ask gently to the package manager to port its package to <a href="http://www.stackage.org">stackage</a>.</p>
<p>So to install copy/paste the following three lines in your terminal:</p>
<pre><code>curl -O https://raw.githubusercontent.com/yogsototh/install-haskell/master/install-haskell.sh
chmod ugo+x install-haskell.sh
sudo ./install-haskell.sh $USER</code></pre>
<h2 id="how">How?</h2>
<p>You can read the script and you will see that this is quite straightforward.</p>
<ol style="list-style-type: decimal">
<li>It downloads the latest <code>GHC</code> binary for you system and install it.</li>
<li>It does the same with the <code>cabal</code> program.</li>
<li>It updates your cabal config file to use <a href="http://www.stackage.org/lts">Haskell LTS</a>.</li>
<li>It enable profiling to libraries and executables.</li>
<li>It installs some useful binaries that might cause compilation error if not present.</li>
</ol>
<p>As the version of libraries is fixed up until you update the <a href="http://www.stackage.org/lts">Haskell LTS</a> version, you should never use cabal sandbox. That way, you will only compile each needed library once. The compiled objects/binaries will be in your <code>~/.cabal</code> directory.</p>
<h2 id="some-last-words">Some Last Words</h2>
<p>This script use the latest <a href="http://www.stackage.org/lts">Haskell LTS</a>. So if you use this script at different dates, the Haskell LTS might have changed.</p>
<p>While it comes to cabal hell, some solutions are sandboxes and <code>nix</code>. Unfortunately, sandboxes didn’t worked good enough for me after some time. Furthermore, sandboxes forces you to re-compile everything by project. If you have three yesod projects for example it means a lot of time and CPU. Also, <code>nix</code> didn’t worked as expected on OS X. So fixing the list of package to a stable list of them seems to me the best pragmatic way to handle the problem today.</p>
<p>From my point of view, <a href="http://www.stackage.org/lts">Haskell LTS</a> is the best step in the right direction. The actual cabal hell problem is more a human problem than a tool problem. This is a bias in most programmer to prefer resolve social issues using tools. There is nothing wrong with hackage and cabal. But for a package manager to work in a static typing language as Haskell, packages much work all together. This is a great strength of static typed languages that they ensure that a big part of the API between packages are compatible. But this make the job of package managing far more difficult than in dynamic languages.</p>
<p>People tend not to respect the rules in package numbering<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. They break their API all the time. So we need a way to organize all of that. And this is precisely what <a href="http://www.stackage.org/lts">Haskell LTS</a> provide. A set of stable packages working all together. So if a developer break its API, it won’t work anymore in stackage. And whether the developer fix its package or all other packages upgrade their usage. During this time, <a href="http://www.stackage.org/lts">Haskell LTS</a> end-users will be able to develop without dependency issues.</p>
<hr />
<p class="small">
<a href="https://www.flickr.com/photos/nesster/4198442186/">The image of the cat about to jump that I slightly edited can found here</a>
</p>




<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I myself am guilty of such behavior. It was a beginner error.<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Sacré Haskell Projet</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Holy-Haskell-Starter/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Holy-Haskell-Starter/index.html</id>
    <published>2013-11-14T00:00:00Z</published>
    <updated>2013-11-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/holy-grail-monty-python.jpg" alt="Monty Python Holy Grail"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Apprenez comment commencer un nouveau projet Haskell. Avec en exemple le créateur de projet Haskell lui-même.</p>
<blockquote>
<p>“Good Sir Knight, will you come with me to Camelot, and join us at the Round Table?”</p>
</blockquote>
<p>In order to work properly with Haskell you need to initialize your environment. Typically, you need to use a cabal file, create some test for your code. Both, unit test and propositional testing (random and exhaustive up to a certain depth). You need to use <code>git</code> and generally hosting it on github. Also, it is recommended to use cabal sandboxes. And as bonus, an auto-update tool that recompile and retest on each file save.</p>
<p>In this article, we will create such an environment using a zsh script. Then we will write a Haskell project which does the same work as the zsh script. You will then see how to work in such an environment.</p>
<p>If you are starting to understand Haskell but consider yourself a beginner, this tutorial will show you how to make a real application using quite surprisingly a lot of features:</p>
<ul>
<li>use colorized output</li>
<li>interact with a user in command line</li>
<li>read/write files</li>
<li>kind of parse a file (in fact, simply split it)</li>
<li>use a templating system (mustache: fill a data structure, write files)</li>
<li>make a HTTP GET request then parse the JSON answer and use it</li>
<li>use random</li>
<li>create a cabal package</li>
<li>add and use non source files to a cabal package</li>
<li>Test your code (both unit testing and property testing)</li>
</ul>
<p><strong>☞</strong> zsh is by its nature more suitable to file manipulation. But the Haskell code is clearly more organized while quite terse for a multi-purpose language.</p>
<p><strong>☞</strong> holy-project is on hackage. It can be installed with <code>cabal update &amp;&amp; cabal install holy-project</code>.</p>
</div>
<p>I recently read this excellent article: <a href="http://jabberwocky.eu/2013/10/24/how-to-start-a-new-haskell-project/">How to Start a New Haskell Project</a>.</p>
<p>While the article is very good, I lacked some minor informations<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Inspired by it, I created a simple script to initialize a new Haskell project. During the process I improved some things a bit.</p>
<p>If you want to use this script, the steps are:</p>
<ol style="list-style-type: decimal">
<li><a href="http://wwW.haskell.org/platform">Install Haskell</a></li>
<li>Make sure you have the latest <code>cabal-install</code> (at least 1.18)</li>
</ol>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">cabal</span> install cabal-install</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Download and run the script</li>
</ol>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Download the script</span>
<span class="kw">git</span> clone https://github.com/yogsototh/init-haskell-project.git
<span class="co"># Copy the script in a directory of you PATH variable</span>
<span class="kw">cp</span> init-haskell-project/holy-haskell.sh ~/bin
<span class="co"># Go to the directory containing all your projects</span>
<span class="kw">cd</span> my/projects/directory
<span class="co"># Launch thcript</span>
<span class="kw">holy-haskell.sh</span></code></pre>
<p>What does this script do that <code>cabal init</code> doesn’t do?</p>
<ul>
<li>Use cabal sandbox</li>
<li>It initialize <code>git</code> with the right <code>.gitignore</code> file.</li>
<li>Use <code>tasty</code> to organize your tests (HUnit, QuickCheck and SmallCheck).</li>
<li>Use <code>-Wall</code> for <code>ghc</code> compilation.</li>
<li>Will make references to Holy Grail</li>
<li>Search your default github username via <a href="http://developer.github.com/v3/search/#search-users">github api</a>.</li>
</ul>
<h2 id="zsh-really"><code>zsh</code> really?</h2>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/french-insult.jpg" alt="French insult"/>
</div>
<p>Developing the script in <code>zsh</code> was easy. But considering its size, it is worth to rewrite it in Haskell. Furthermore, it will be a good exercise.</p>
<h3 id="patricide">Patricide</h3>
<p>In a first time, we initialize a new Haskell project with <code>holy-haskell.sh</code>:</p>
<pre>
> ./holy-haskell.sh
<span class="green">Bridgekeeper: Stop!
Bridgekeeper: Who would cross the Bridge of Death
Bridgekeeper: must answer me these questions three,
Bridgekeeper: ere the other side he see.</span>
<span class="yellow">You: Ask me the questions, bridgekeeper, I am not afraid.</span>

<span class="green">Bridgekeeper: What is the name of your project?</span>
> Holy project
<span class="green">Bridgekeeper: What is your name?</span> (Yann Esposito (Yogsototh))
>
<span class="green">Bridgekeeper: What is your email?</span> (Yann.Esposito@gmail.com)
>
<span class="green">Bridgekeeper: What is your github user name?</span> (yogsototh)
>
<span class="green">Bridgekeeper: What is your project in less than ten words?</span>
> Start your Haskell project with cabal, git and tests.
Initialize git
Initialized empty Git repository in .../holy-project/.git/
Create files
    .gitignore
    holy-project.cabal
    Setup.hs
    LICENSE (MIT)
    test/Test.hs
    test/HolyProject/Swallow/Test.hs
    src/HolyProject/Swallow.hs
    test/HolyProject/Coconut/Test.hs
    src/HolyProject/Coconut.hs
    src/HolyProject.hs
    src/Main.hs
Cabal sandboxing, install and test
...
  many compilations lines
...
Running 1 test suites...
Test suite Tests: RUNNING...
Test suite Tests: PASS
Test suite logged to: dist/test/holy-project-0.1.0.0-Tests.log
1 of 1 test suites (1 of 1 test cases) passed.
All Tests
  Swallow
    swallow test:     <span class="green">OK</span>
  coconut
    coconut:          <span class="green">OK</span>
    coconut property: <span class="green">OK</span>
      148 tests completed

<span class="green">All 3 tests passed</span>



<span class="green">Bridgekeeper: What... is the air-speed velocity of an unladen swallow?</span>
<span class="yellow">You: What do you mean? An African or European swallow?</span>
<span class="green">Bridgekeeper: Huh? I... I don't know that.</span>
[the bridgekeeper is thrown over]
<span class="green">Bridgekeeper: Auuuuuuuuuuuugh</span>
Sir Bedevere: How do you know so much about swallows?
<span class="yellow">You: Well, you have to know these things when you're a king, you know.</span>
</pre>

<p>The different steps are:</p>
<ul>
<li>small introduction quotes</li>
<li>ask five questions – <em>three question sir…</em></li>
<li>create the directory for the project</li>
<li>init git</li>
<li>create files</li>
<li>sandbox cabal</li>
<li>cabal install and test</li>
<li>run the test directly in the terminal</li>
<li>small goodbye quotes</li>
</ul>
<p>Features to note:</p>
<ul>
<li>color in the terminal</li>
<li>check some rules on the project name</li>
<li>random message if error</li>
<li>use <code>~/.gitconfig</code> file in order to provide a default name and email.</li>
<li>use the github API which returns JSON to get the default github user name.</li>
</ul>
<p>So, apparently nothing too difficult to achieve.</p>
<p>We should now have an initialized Haskell environment for us to work. The first thing you should do, is to go into this new directory and launch ‘./auto-update’ in some terminal. I personally use <code>tmux</code> on Linux or the splits in <code>iTerm 2</code> on Mac OS X. Now, any modification of a source file will relaunch a compilation and a test.</p>
<h3 id="the-dialogs">The dialogs</h3>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/bridge-of-death.jpg" alt="Bridge of Death"/>
</div>
<p>To print the introduction text in <code>zsh</code>:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># init colors</span>
<span class="kw">autoload</span> colors
<span class="kw">colors</span>
<span class="kw">for</span> <span class="kw">COLOR</span> in RED GREEN YELLOW BLUE MAGENTA CYAN BLACK WHITE<span class="kw">;</span> <span class="kw">do</span>
    <span class="kw">eval</span> <span class="ot">$COLOR</span>=<span class="st">&#39;$fg_no_bold[${(L)COLOR}]&#39;</span>
    <span class="kw">eval</span> BOLD_<span class="ot">$COLOR</span>=<span class="st">&#39;$fg_bold[${(L)COLOR}]&#39;</span>
<span class="kw">done</span>
<span class="kw">eval</span> RESET=<span class="st">&#39;$reset_color&#39;</span>
<span class="co"># functions</span>
<span class="fu">bk()</span>{<span class="kw">print</span> -- <span class="st">&quot;</span><span class="ot">${GREEN}</span><span class="st">Bridgekeeper: </span><span class="ot">$*${RESET}</span><span class="st">&quot;</span>}
<span class="fu">bkn()</span>{<span class="kw">print</span> -n -- <span class="st">&quot;</span><span class="ot">${GREEN}</span><span class="st">Bridgekeeper: </span><span class="ot">$*${RESET}</span><span class="st">&quot;</span>}
<span class="fu">you()</span>{<span class="kw">print</span> -- <span class="st">&quot;</span><span class="ot">${YELLOW}</span><span class="st">You: </span><span class="ot">$*${RESET}</span><span class="st">&quot;</span>}
<span class="kw">...</span>
<span class="co"># the introduction dialog</span>
<span class="kw">bk</span> <span class="st">&quot;Stop!&quot;</span>
<span class="kw">bk</span> <span class="st">&quot;Who would cross the Bridge of Death&quot;</span>
<span class="kw">bk</span> <span class="st">&quot;must answer me these questions three,&quot;</span>
<span class="kw">bk</span> <span class="st">&quot;ere the other side he see.&quot;</span>
<span class="kw">you</span> <span class="st">&quot;Ask me the questions, bridgekeeper, I am not afraid.\n&quot;</span>
<span class="kw">...</span>
<span class="co"># the final dialog</span>
<span class="kw">print</span> <span class="st">&quot;\n\n&quot;</span>
<span class="kw">bk</span> <span class="st">&quot;What... is the air-speed velocity of an unladen swallow?&quot;</span>
<span class="kw">you</span> <span class="st">&quot;What do you mean? An African or European swallow?&quot;</span>
<span class="kw">bk</span> <span class="st">&quot;Huh? I... I don&#39;t know that.&quot;</span>
<span class="kw">log</span> <span class="st">&quot;[the bridgekeeper is thrown over]&quot;</span>
<span class="kw">bk</span> <span class="st">&quot;Auuuuuuuuuuuugh&quot;</span>
<span class="kw">log</span> <span class="st">&quot;Sir Bedevere: How do you know so much about swallows?&quot;</span>
<span class="kw">you</span> <span class="st">&quot;Well, you have to know these things when you&#39;re a king, you know.&quot;</span></code></pre>
<p>In the first Haskell version I don’t use colors. We see we can almost copy/paste. I just added the types.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bk ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
bk str <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Bridgekeeper: &quot;</span> <span class="fu">++</span> str

<span class="ot">bkn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
bkn str <span class="fu">=</span> pustStr <span class="fu">$</span> <span class="st">&quot;Bridgekeeper: &quot;</span> <span class="fu">++</span> str

<span class="ot">you ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
you str <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="st">&quot;You: &quot;</span> <span class="fu">++</span> str

<span class="ot">intro ::</span> <span class="dt">IO</span> ()
intro <span class="fu">=</span> <span class="kw">do</span>
    bk <span class="st">&quot;Stop!&quot;</span>
    bk <span class="st">&quot;Who would cross the Bridge of Death&quot;</span>
    bk <span class="st">&quot;must answer me these questions three,&quot;</span>
    bk <span class="st">&quot;ere the other side he see.&quot;</span>
    you <span class="st">&quot;Ask me the questions, bridgekeeper, I am not afraid.\n&quot;</span>

<span class="ot">end ::</span> <span class="dt">IO</span> ()
end <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;\n\n&quot;</span>
    bk <span class="st">&quot;What... is the air-speed velocity of an unladen swallow?&quot;</span>
    you <span class="st">&quot;What do you mean? An African or European swallow?&quot;</span>
    bk <span class="st">&quot;Huh? I... I don&#39;t know that.&quot;</span>
    putStrLn <span class="st">&quot;[the bridgekeeper is thrown over]&quot;</span>
    bk <span class="st">&quot;Auuuuuuuuuuuugh&quot;</span>
    putStrLn <span class="st">&quot;Sir Bedevere: How do you know so much about swallows?&quot;</span>
    you <span class="st">&quot;Well, you have to know these things when you&#39;re a king, you know.&quot;</span></code></pre>
<p>Now let’s just add the colors using the <a href="http://hackage.haskell.org/package/ansi-terminal"><code>ansi-terminal</code></a> package. So we have to add <code>ansi-terminal</code> as a build dependency in our cabal file.</p>
<p>Edit <code>holy-project.cabal</code> to add it.</p>
<pre><code>...
build-depends:  base &gt;=4.6 &amp;&amp; &lt;4.7
                <span class="highlight">, ansi-terminal</span>
...</code></pre>
<p>Now look at the modified Haskell code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="highlight"><span class="kw">import </span><span class="dt">System.Console.ANSI</span></span>

<span class="ot">colorPutStr ::</span> <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
colorPutStr color str <span class="fu">=</span> <span class="kw">do</span>
    setSGR  [ <span class="dt">SetColor</span> <span class="dt">Foreground</span> <span class="dt">Dull</span> color
            , <span class="dt">SetConsoleIntensity</span> <span class="dt">NormalIntensity</span>
            ]
    putStr str
    setSGR []


<span class="ot">bk ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
bk str <span class="fu">=</span> <span class="highlight">colorPutStr <span class="dt">Green</span></span> (<span class="st">&quot;Bridgekeeper: &quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;\n&quot;</span>)
<span class="ot">bkn ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
bkn str <span class="fu">=</span> <span class="highlight">colorPutStr <span class="dt">Green</span></span> (<span class="st">&quot;Bridgekeeper: &quot;</span> <span class="fu">++</span> str)
<span class="ot">you ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
you str <span class="fu">=</span> <span class="highlight">colorPutStr <span class="dt">Yellow</span></span> (<span class="st">&quot;You: &quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;\n&quot;</span>)

<span class="ot">intro ::</span> <span class="dt">IO</span> ()
intro <span class="fu">=</span> <span class="kw">do</span>
    bk <span class="st">&quot;Stop!&quot;</span>
    bk <span class="st">&quot;Who would cross the Bridge of Death&quot;</span>
    bk <span class="st">&quot;must answer me these questions three,&quot;</span>
    bk <span class="st">&quot;ere the other side he see.&quot;</span>
    you <span class="st">&quot;Ask me the questions, bridgekeeper, I am not afraid.\n&quot;</span>

<span class="ot">end ::</span> <span class="dt">IO</span> ()
end <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;\n\n&quot;</span>
    bk <span class="st">&quot;What... is the air-speed velocity of an unladen swallow?&quot;</span>
    you <span class="st">&quot;What do you mean? An African or European swallow?&quot;</span>
    bk <span class="st">&quot;Huh? I... I don&#39;t know that.&quot;</span>
    putStrLn <span class="st">&quot;[the bridgekeeper is thrown over]&quot;</span>
    bk <span class="st">&quot;Auuuuuuuuuuuugh&quot;</span>
    putStrLn <span class="st">&quot;Sir Bedevere: How do you know so much about swallows?&quot;</span>
    you <span class="st">&quot;Well, you have to know these things when you&#39;re a king, you know.&quot;</span></code></pre>
<p>We could put this code in <code>src/Main.hs</code>. Declare a main function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    intro
    end</code></pre>
<p>Make <code>cabal install</code> and run <code>cabal run</code> (or <code>./.cabal-sandbox/bin/holy-project</code>). It works!</p>
<h2 id="five-questions-three-questions-sir">Five Questions – Three questions Sir!</h2>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/bring-out-your-dead.jpg" alt="Bring out your dead!"/>
</div>
<p>In order to ask questions, here is how we do it in shell script:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">print</span> -- <span class="st">&quot;What is your name?&quot;</span>
<span class="kw">read</span> <span class="ot">name</span></code></pre>
<p>If we want to abstract things a bit, the easiest way in shell is to use a global variable<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> which will get the value of the user input like this:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="ot">answer=</span><span class="st">&quot;&quot;</span>
<span class="fu">ask()</span><span class="kw">{</span>
    <span class="kw">local</span> <span class="ot">info=</span><span class="st">&quot;</span><span class="ot">$1</span><span class="st">&quot;</span>
    <span class="kw">bk</span> <span class="st">&quot;What is your </span><span class="ot">$info</span><span class="st">?&quot;</span>
    <span class="kw">print</span> -n <span class="st">&quot;&gt; &quot;</span>
    <span class="kw">read</span> <span class="ot">answer</span>
<span class="kw">}</span>
<span class="kw">...</span>
<span class="kw">ask</span> name
<span class="ot">name=</span><span class="st">&quot;</span><span class="ot">$answer</span><span class="st">&quot;</span></code></pre>
<p>In Haskell we won’t need any global variable:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.IO</span> (hFlush, stdout)
<span class="fu">...</span>
<span class="ot">ask ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
ask info <span class="fu">=</span> <span class="kw">do</span>
    bk <span class="fu">$</span> <span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> info <span class="fu">++</span> <span class="st">&quot;?&quot;</span>
    putStr <span class="st">&quot;&gt; &quot;</span>
    hFlush stdout <span class="co">-- Because we want to ask on the same line.</span>
    getLine</code></pre>
<p>Now our main function might look like:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    intro
    _ <span class="ot">&lt;-</span> ask <span class="st">&quot;project name&quot;</span>
    _ <span class="ot">&lt;-</span> ask <span class="st">&quot;name&quot;</span>
    _ <span class="ot">&lt;-</span> ask <span class="st">&quot;email&quot;</span>
    _ <span class="ot">&lt;-</span> ask <span class="st">&quot;github account&quot;</span>
    _ <span class="ot">&lt;-</span> ask <span class="st">&quot;project in less than a dozen word&quot;</span>
    end</code></pre>
<p>You could test it with <code>cabal install</code> and then <code>./.cabal-sandbox/bin/holy-project</code>.</p>
<p>We will see later how to guess the answer using the <code>.gitconfig</code> file and the github API.</p>
<h2 id="using-answers">Using answers</h2>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/castle-of-hhhhaaaarr.jpg" alt="Castle of Aaaaarrrr????"/>
</div>
<h3 id="create-the-project-name">Create the project name</h3>
<p>I don’t really like the ability to use capital letter in a package name. So in shell I transform the project name like this:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># replace all spaces by dashes then lowercase the string</span>
<span class="ot">project=</span>${<span class="ot">${project:gs</span><span class="er">/ /-/</span><span class="ot">}</span>:<span class="kw">l</span>}</code></pre>
<p>In order to achieve the same result in Haskell (don’t forget to add the <code>split</code> package):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Char</span>        (toLower)
<span class="kw">import </span><span class="dt">Data.List</span>        (intercalate)
<span class="kw">import </span><span class="dt">Data.List.Split</span>  (splitOneOf)
<span class="fu">...</span>
<span class="ot">projectNameFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
projectNameFromString str <span class="fu">=</span> intercalate <span class="st">&quot;-&quot;</span> (splitOneOf <span class="st">&quot; -&quot;</span> (map toLower str))</code></pre>
<p>One important thing to note is that in zsh the transformation occurs on strings but in haskell we use list as intermediate representation:</p>
<pre><code>zsh:
&quot;Holy grail&quot; ==( ${project:gs/ /-/} )=&gt; &quot;Holy<span class="highlight">-</span>grail&quot;
             ==( ${project:l}       )=&gt; &quot;<span class="highlight">h</span>oly-grail&quot;

haskell
&quot;Holy grail&quot; ==( map toLower     )=&gt; &quot;<span class="highlight">h</span>oly grail&quot;
             ==( splitOneOf &quot; -&quot; )=&gt; <span class="highlight">[</span>&quot;holy&quot;<span class="highlight">,</span>&quot;grail&quot;<span class="highlight">]</span>
             ==( intercalate &quot;-&quot; )=&gt; <span class="highlight">&quot;</span>holy<span class="highlight">-</span>grail<span class="highlight">&quot;</span></code></pre>
<h3 id="create-the-module-name">Create the module name</h3>
<p>The module name is a capitalized version of the project name where we remove dashes.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># Capitalize a string</span>
<span class="fu">capitalize()</span><span class="kw">{</span>
    <span class="kw">local</span> <span class="ot">str=</span><span class="st">&quot;</span><span class="ot">$(</span><span class="kw">print</span> -- <span class="st">&quot;</span><span class="ot">$*</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="kw">sed</span> <span class="st">&#39;s/-/ /g&#39;</span><span class="ot">)</span><span class="st">&quot;</span>
    <span class="kw">print</span> -- $<span class="dt">{(C)str}</span> <span class="kw">|</span> <span class="kw">sed</span> <span class="st">&#39;s/ //g&#39;</span>
<span class="kw">}</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | transform a chain like &quot;Holy project&quot; in &quot;HolyProject&quot;</span>
<span class="ot">capitalize ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
capitalize str <span class="fu">=</span> concatMap capitalizeWord (splitOneOf <span class="st">&quot; -&quot;</span> str)
    <span class="kw">where</span>
<span class="ot">        capitalizeWord ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
        capitalizeWord (x<span class="fu">:</span>xs)   <span class="fu">=</span> toUpper x<span class="fu">:</span>map toLower xs
        capitalizeWord  _       <span class="fu">=</span> []</code></pre>
<p>The haskell version is made by hand where zsh already had a capitalize operation on string with many words. Here is the difference between the shell and haskell way (note I splitted the effect of <code>concatMap</code> as <code>map</code> and <code>concat</code>):</p>
<pre><code>shell:
&quot;Holy-grail&quot; ==( sed &#39;s/-/ /g&#39; )=&gt; &quot;Holy<span class="highlight"> </span>grail&quot;
             ==( ${(C)str}     )=&gt; &quot;Holy <span class="highlight">G</span>rail&quot;
             ==( sed &#39;s/ //g&#39;  )=&gt; &quot;HolyGrail&quot;

haskell:
&quot;Holy-grail&quot; ==( splitOneOf &quot; -&quot;    )=&gt; <span class="highlight">[</span>&quot;Holy&quot;<span class="highlight">,</span>&quot;grail&quot;<span class="highlight">]</span>
             ==( map capitalizeWord )=&gt; [&quot;Holy&quot;,&quot;<span class="highlight">G</span>rail&quot;]
             ==( concat             )=&gt; &quot;HolyGrail&quot;</code></pre>
<p>As the preceding example, in shell we work on strings while Haskell use temporary lists representations.</p>
<h3 id="check-the-project-name">Check the project name</h3>
<p>Also I want to be quite restrictive on the kind of project name we can give. This is why I added a check function.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ioassert ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
ioassert <span class="dt">True</span> _ <span class="fu">=</span> return ()
ioassert <span class="dt">False</span> str <span class="fu">=</span> error str

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  intro
  project <span class="ot">&lt;-</span> ask <span class="st">&quot;project name&quot;</span>
  ioassert (checkProjectName project)
       <span class="st">&quot;Use only letters, numbers, spaces ans dashes please&quot;</span>
  <span class="kw">let</span> projectname <span class="fu">=</span> projectNameFromString project
      modulename <span class="fu">=</span> capitalize project</code></pre>
<p>Which verify the project name is not empty and use only letter, numbers and dashes:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | verify if project name is conform</span>
<span class="ot">checkProjectName ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
checkProjectName [] <span class="fu">=</span> <span class="dt">False</span>
checkProjectName str <span class="fu">=</span>
    all (\c <span class="ot">-&gt;</span> isLetter c <span class="fu">||</span> isNumber c <span class="fu">||</span> c<span class="fu">==</span><span class="ch">&#39;-&#39;</span> <span class="fu">||</span> c<span class="fu">==</span><span class="ch">&#39; &#39;</span>) str</code></pre>
<h2 id="create-the-project">Create the project</h2>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/giant-three-head.jpg" alt="Giant with three heads and mustaches"/>
</div>
<p>Making a project will consists in creating files and directories whose name and content depends on the answer we had until now.</p>
<p>In shell, for each file to create, we used something like:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">&gt;</span> <span class="kw">file-to-create</span> cat &lt;&lt;END
fil<span class="kw">e</span> <span class="kw">content</span> here.
We can use <span class="ot">$variables</span> here
END</code></pre>
<p>In Haskell, while possible, we shouldn’t put the file content in the source code. We have a relatively easy way to include external file in a cabal package. This is what we will be using.</p>
<p>Furthermore, we need a templating system to replace small part of the static file by computed values. For this task, I choose to use <a href="http://hackage.haskell.org/package/hastache"><code>hastache</code></a>, a Haskell implementation of Mustache templates<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</p>
<h3 id="add-external-files-in-a-cabal-project">Add external files in a cabal project</h3>
<p>Cabal provides a way to add files which are not source files to a package. You simply have to add a <code>Data-Files:</code> entry in the header of the cabal file:</p>
<pre><code>data-files: scaffold/LICENSE
            , scaffold/Setup.hs
            , scaffold/auto-update
            , scaffold/gitignore
            , scaffold/interact
            , scaffold/project.cabal
            , scaffold/src/Main.hs
            , scaffold/src/ModuleName.hs
            , scaffold/src/ModuleName/Coconut.hs
            , scaffold/src/ModuleName/Swallow.hs
            , scaffold/test/ModuleName/Coconut/Test.hs
            , scaffold/test/ModuleName/Swallow/Test.hs
            , scaffold/test/Test.hs</code></pre>
<p>Now we simply have to create our files at the specified path. Here is for example the first lines of the LICENSE file.</p>
<pre class="mustache"><code>The MIT License (MIT)

Copyright (c) <span class="highlight">{{year}}</span> <span class="highlight">{{author}}</span>

Permission is hereby granted, free of charge, to any person obtaining a copy
...</code></pre>
<p>It will be up to our program to replace the <code>{{year}}</code> and <code>{{author}}</code> at runtime. We have to find the files. Cabal will create a module named <code>Paths_holy_project</code>. If we import this module we have the function <code>genDataFileName</code> at our disposal. Now we can read the files at runtime like this:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="fu">...</span>
  <span class="kw">do</span>
    pkgFilePath     <span class="ot">&lt;-</span> <span class="highlight">getDataFileName <span class="st">&quot;scaffold/LICENSE&quot;</span></span>
    templateContent <span class="ot">&lt;-</span> readFile pkgFilePath
    <span class="fu">...</span></code></pre>
<h3 id="create-files-and-directories">Create files and directories</h3>
<p>A first remark is for portability purpose we shouldn’t use String for file path. For example on Windows <code>/</code> isn’t considered as a subdirectory character. To resolve this problem we will use <code>FilePath</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Directory</span>
<span class="kw">import </span><span class="dt">System.FilePath.Posix</span>        (takeDirectory,(&lt;/&gt;))
<span class="fu">...</span>
createProject <span class="fu">...</span> <span class="fu">=</span> <span class="kw">do</span>
      <span class="fu">...</span>
      <span class="highlight">createDirectory</span> projectName     <span class="co">-- mkdir</span>
      <span class="highlight">setCurrentDirectory</span> projectName <span class="co">-- cd</span>
      genFile <span class="st">&quot;LICENSE&quot;</span> <span class="st">&quot;LICENSE&quot;</span>
      genFile <span class="st">&quot;gitignore&quot;</span> <span class="st">&quot;.gitignore&quot;</span>
      genFile <span class="st">&quot;src/Main.hs&quot;</span> (<span class="st">&quot;src&quot;</span> <span class="fu">&lt;/&gt;</span> <span class="st">&quot;Main.hs&quot;</span>)

genFile dataFilename outputFilename <span class="fu">=</span> <span class="kw">do</span>
    pkgfileName <span class="ot">&lt;-</span> getDataFileName (<span class="st">&quot;scaffold/&quot;</span> <span class="fu">++</span> filename)
    template <span class="ot">&lt;-</span> readFile pkgfileName
    transformedFile <span class="ot">&lt;-</span> <span class="fu">???</span> <span class="co">-- hastache magic here</span>
    <span class="highlight">createDirectoryIfMissing</span> <span class="dt">True</span> (takeDirectory outputFileName)
    <span class="highlight">writeFile</span> outputFileName transformedFile</code></pre>
<h3 id="use-hastache">Use Hastache</h3>
<p>In order to use hastache we can either create a context manually or use generics to create a context from a record. This is the last option we will show here. So in a first time, we need to import some modules and declare a record containing all necessary informations to create our project.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class="fu">...</span>
<span class="kw">import </span><span class="dt">Data.Data</span>
<span class="kw">import </span><span class="dt">Text.Hastache</span>
<span class="kw">import </span><span class="dt">Text.Hastache.Context</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString</span>            <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">LZ</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Project</span> <span class="fu">=</span> <span class="dt">Project</span> {
<span class="ot">    projectName   ::</span> <span class="dt">String</span>
    ,<span class="ot"> moduleName    ::</span> <span class="dt">String</span>
    ,<span class="ot"> author        ::</span> <span class="dt">String</span>
    ,<span class="ot"> mail          ::</span> <span class="dt">String</span>
    ,<span class="ot"> ghaccount     ::</span> <span class="dt">String</span>
    ,<span class="ot"> synopsis      ::</span> <span class="dt">String</span>
    ,<span class="ot"> year          ::</span> <span class="dt">String</span>
    } <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>)</code></pre>
<p>Once we have declared this, we should populate our Project record with the data provided by the user. So our main function should look like:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    intro
    project <span class="ot">&lt;-</span> ask <span class="st">&quot;project name&quot;</span>
    ioassert (checkProjectName project)
             <span class="st">&quot;Use only letters, numbers, spaces ans dashes please&quot;</span>
    <span class="kw">let</span> projectname <span class="fu">=</span> projectNameFromString project
        modulename  <span class="fu">=</span> capitalize project
    <span class="highlight">in_author</span>       <span class="ot">&lt;-</span> ask <span class="st">&quot;name&quot;</span>
    <span class="highlight">in_email</span>        <span class="ot">&lt;-</span> ask <span class="st">&quot;email&quot;</span>
    <span class="highlight">in_ghaccount</span>    <span class="ot">&lt;-</span> ask <span class="st">&quot;github account&quot;</span>
    <span class="highlight">in_synopsis</span>     <span class="ot">&lt;-</span> ask <span class="st">&quot;project in less than a dozen word?&quot;</span>
    <span class="highlight">current_year</span>    <span class="ot">&lt;-</span> getCurrentYear
    createProject <span class="fu">$</span> <span class="highlight"><span class="dt">Project</span> projectname modulename in_author in_email</span>
                            <span class="highlight">in_ghaccount in_synopsis current_year</span>
    end</code></pre>
<p>Finally we could use hastache this way:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createProject ::</span> <span class="highlight"><span class="dt">Project</span></span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
createProject <span class="highlight">p</span> <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> <span class="highlight">context</span> <span class="fu">=</span> <span class="highlight">mkGenericContext p</span>
    createDirectory (<span class="highlight">projectName p</span>)
    setCurrentDirectory (<span class="highlight">projectName p</span>)
    genFile <span class="highlight">context</span> <span class="st">&quot;gitignore&quot;</span>      <span class="fu">$</span> <span class="st">&quot;.gitignore&quot;</span>
    genFile <span class="highlight">context</span> <span class="st">&quot;project.cabal&quot;</span>  <span class="fu">$</span> (projectName p) <span class="fu">++</span> <span class="st">&quot;.cabal&quot;</span>
    genFile <span class="highlight">context</span> <span class="st">&quot;src/Main.hs&quot;</span>)   <span class="fu">$</span> <span class="st">&quot;src&quot;</span> <span class="fu">&lt;/&gt;</span> <span class="st">&quot;Main.hs&quot;</span>
    <span class="fu">...</span>

<span class="ot">genFile ::</span> <span class="dt">MuContext</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
genFile context filename outputFileName <span class="fu">=</span> <span class="kw">do</span>
    pkgfileName <span class="ot">&lt;-</span> getDataFileName (<span class="st">&quot;scaffold/&quot;</span><span class="fu">++</span>filename)
    template <span class="ot">&lt;-</span> <span class="highlight"><span class="dt">BS</span><span class="fu">.</span></span>readFile pkgfileName
    transformedFile <span class="ot">&lt;-</span> <span class="highlight">hastacheStr defaultConfig template context</span>
    createDirectoryIfMissing <span class="dt">True</span> (takeDirectory outputFileName)
    <span class="highlight"><span class="dt">LZ</span><span class="fu">.</span></span>writeFile outputFileName transformedFile</code></pre>
<p>We use external files in mustache format. We ask question to our user to fill a data structure. We use this data structure to create a context. Hastache use this context with the external files to create the project files.</p>
<h2 id="git-and-cabal">Git and Cabal</h2>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/tim.jpg" alt="Tim"/>
</div>
<p>We need to initialize git and cabal. For this we simply call external command with the <code>system</code> function.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Cmd</span>

<span class="fu">...</span>
main <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">...</span>
    _ <span class="ot">&lt;-</span> system <span class="st">&quot;git init .&quot;</span>
    _ <span class="ot">&lt;-</span> system <span class="st">&quot;cabal sandbox init&quot;</span>
    _ <span class="ot">&lt;-</span> system <span class="st">&quot;cabal install&quot;</span>
    _ <span class="ot">&lt;-</span> system <span class="st">&quot;cabal test&quot;</span>
    _ <span class="ot">&lt;-</span> system <span class="fu">$</span> <span class="st">&quot;./.cabal-sandbox/bin/test-&quot;</span> <span class="fu">++</span> projectName</code></pre>
<h2 id="ameliorations">Ameliorations</h2>
<p>Our job is almost finished. Now, we only need to add some nice feature to make the application more enjoyable.</p>
<h3 id="better-error-message">Better error message</h3>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/rabbit.jpg" alt="Rabbit"/>
</div>
<p>The first one would be to add a better error message.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.Random</span>

<span class="ot">holyError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
holyError str <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> randomIO
    <span class="kw">if</span> r
        <span class="kw">then</span>
            <span class="kw">do</span>
                bk <span class="st">&quot;What... is your favourite colour?&quot;</span>
                you <span class="st">&quot;Blue. No, yel...&quot;</span>
                putStrLn <span class="st">&quot;[You are thrown over the edge into the volcano]&quot;</span>
                you <span class="st">&quot;You: Auuuuuuuuuuuugh&quot;</span>
                bk <span class="st">&quot; Hee hee heh.&quot;</span>
        <span class="kw">else</span>
            <span class="kw">do</span>
                bk <span class="st">&quot;What is the capital of Assyria?&quot;</span>
                you <span class="st">&quot;I don&#39;t know that!&quot;</span>
                putStrLn <span class="st">&quot;[You are thrown over the edge into the volcano]&quot;</span>
                you <span class="st">&quot;Auuuuuuuuuuuugh&quot;</span>
    error (<span class="ch">&#39;\n&#39;</span><span class="fu">:</span>str)</code></pre>
<p>And also update where this can be called</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ioassert ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
ioassert <span class="dt">True</span> _ <span class="fu">=</span> return ()
ioassert <span class="dt">False</span> str <span class="fu">=</span> holyError str</code></pre>
<h3 id="use-.gitconfig">Use <code>.gitconfig</code></h3>
<p>We want to retrieve the <code>~/.gitconfig</code> file content and see if it contains a name and email information. We will need to access to the <code>HOME</code> environment variable. Also, as we use bytestring package for hastache, let’s take advantage of this library.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Maybe</span>           (fromJust)
<span class="kw">import </span><span class="dt">System.Environment</span>   (getEnv)
<span class="kw">import </span><span class="dt">Control.Exception</span>
<span class="kw">import </span><span class="dt">System.IO.Error</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>        (guard)

<span class="ot">safeReadGitConfig ::</span> <span class="dt">IO</span> <span class="dt">LZ.ByteString</span>
safeReadGitConfig <span class="fu">=</span> <span class="kw">do</span>
    e <span class="ot">&lt;-</span> tryJust (guard <span class="fu">.</span> isDoesNotExistError)
                 (<span class="kw">do</span>
                    home <span class="ot">&lt;-</span> getEnv <span class="st">&quot;HOME&quot;</span>
                    LZ.readFile <span class="fu">$</span> home <span class="fu">++</span> <span class="st">&quot;/.gitconfig&quot;</span> )
    return <span class="fu">$</span> either (const (LZ.empty)) id e
<span class="fu">...</span>
main <span class="fu">=</span> <span class="kw">do</span>
    gitconfig <span class="ot">&lt;-</span> safeReadGitConfig
    <span class="kw">let</span> (name,email) <span class="fu">=</span> <span class="highlight">getNameAndMail</span> gitconfig
    project <span class="ot">&lt;-</span> ask <span class="st">&quot;project name&quot;</span> <span class="dt">Nothing</span>
    <span class="fu">...</span>
    in_author       <span class="ot">&lt;-</span> ask <span class="st">&quot;name&quot;</span> name
    <span class="fu">...</span></code></pre>
<p>We could note I changed the ask function slightly to take a maybe parameter.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">String</span> <span class="highlight"><span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span></span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span>
ask info hint <span class="fu">=</span> <span class="kw">do</span>
    bk <span class="fu">$</span> <span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> info <span class="fu">++</span> <span class="st">&quot;?&quot;</span> <span class="fu">++</span> <span class="highlight">(maybe <span class="st">&quot;&quot;</span> (\h <span class="ot">-&gt;</span> <span class="st">&quot; (&quot;</span><span class="fu">++</span>h<span class="fu">++</span><span class="st">&quot;)&quot;</span>) hint)</span>
    <span class="fu">...</span></code></pre>
<p>Concerning the parsing of <code>.gitconfig</code>, it is quite minimalist.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getNameAndMail ::</span> <span class="dt">LZ.ByteString</span> <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> <span class="dt">String</span>,<span class="dt">Maybe</span> <span class="dt">String</span>)
getNameAndMail gitConfigContent <span class="fu">=</span> (getFirstValueFor splitted <span class="st">&quot;name&quot;</span>,
                                   getFirstValueFor splitted <span class="st">&quot;email&quot;</span>)
    <span class="kw">where</span>
        <span class="co">-- make lines of words</span>
<span class="ot">        splitted ::</span> [[<span class="dt">LZ.ByteString</span>]]
        splitted <span class="fu">=</span> map LZ.words (LZ.lines gitConfigContent)

<span class="co">-- Get the first line which start with</span>
<span class="co">-- &#39;elem =&#39; and return the third field (value)</span>
<span class="ot">getFirstValueFor ::</span> [[<span class="dt">LZ.ByteString</span>]] <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
getFirstValueFor splitted key <span class="fu">=</span> firstJust (map (getValueForKey key) splitted)

<span class="co">-- return the first Just value of a list of Maybe</span>
<span class="ot">firstJust ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
firstJust l <span class="fu">=</span> <span class="kw">case</span> dropWhile (<span class="fu">==</span><span class="dt">Nothing</span>) l <span class="kw">of</span>
    [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    (j<span class="fu">:</span>_) <span class="ot">-&gt;</span> j

<span class="co">-- Given a line of words (&quot;word1&quot;:&quot;word2&quot;:rest)</span>
<span class="co">-- getValue will return rest if word1 == key</span>
<span class="co">-- &#39;elem =&#39; or Nothing otherwise</span>
<span class="ot">getValueForKey ::</span> <span class="dt">String</span>            <span class="co">-- key</span>
                  <span class="ot">-&gt;</span> [<span class="dt">LZ.ByteString</span>] <span class="co">-- line of words</span>
                  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>    <span class="co">-- the value if found</span>
getValueForKey el (n<span class="fu">:</span>e<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> (n <span class="fu">==</span> (LZ.pack el)) <span class="fu">&amp;&amp;</span> (e <span class="fu">==</span> (LZ.pack <span class="st">&quot;=&quot;</span>))
                        <span class="kw">then</span> <span class="dt">Just</span> (LZ.unpack (LZ.unwords xs))
                        <span class="kw">else</span> <span class="dt">Nothing</span>
getValueForKey _ _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<p>We could notice, <code>getNameAndMail</code> doesn’t read the full file and stop at the first occurrence of name and mail.</p>
<h3 id="use-the-github-api">Use the github API</h3>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/coconut.jpg" alt="Coconut and Swallow"/>
</div>
<p>The task seems relatively easy, but we’ll see there will be some complexity hidden. Make a request on <code>https://api.github.com/search/users?q=&lt;email&gt;</code>. Parse the JSON and get the <code>login</code> field of the first item.</p>
<p>So the first problem to handle is to connect an URL. For this we will use the <code>http-conduit</code> package.</p>
<p>Generally, for simple request, we should use:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span>
    body <span class="ot">&lt;-</span> simpleHTTP <span class="st">&quot;https://api.github.com/search/users?q=&quot;</span><span class="fu">++</span>email
    <span class="fu">...</span></code></pre>
<p>But, after some research, I discovered we must declare an User-Agent in the HTTP header to be accepted by the github API. So we have to change the HTTP Header, and our code became slightly more complex:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="fu">...</span>
<span class="ot">simpleHTTPWithUserAgent ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">LZ.ByteString</span>
simpleHTTPWithUserAgent url <span class="fu">=</span> <span class="kw">do</span>
    r  <span class="ot">&lt;-</span> parseUrl url
    <span class="kw">let</span> request <span class="fu">=</span> r { requestHeaders <span class="fu">=</span>  [ (<span class="st">&quot;User-Agent&quot;</span>,<span class="st">&quot;HTTP-Conduit&quot;</span>) ] }
    withManager <span class="fu">$</span> (return<span class="fu">.</span>responseBody) <span class="fu">&lt;=&lt;</span> httpLbs request

<span class="ot">getGHUser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)
getGHUser <span class="st">&quot;&quot;</span>    <span class="fu">=</span> return <span class="dt">Nothing</span>
getGHUser email <span class="fu">=</span> <span class="kw">do</span>
            <span class="kw">let</span> url <span class="fu">=</span> <span class="st">&quot;https://api.github.com/search/users?q=&quot;</span> <span class="fu">++</span> email
            body <span class="ot">&lt;-</span> simpleHTTPWithUserAgent url
            <span class="fu">...</span></code></pre>
<p>So now, we have a String containing a JSON representation. In javascript we would have used <code>login=JSON.parse(body).items[0].login</code>. How does Haskell will handle it (knowing the J in JSON is for Javascript)?</p>
<p>First we will need to add the <code>lens-aeson</code> package and use it that way:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Lens.Operators</span>           ((^?))
<span class="kw">import </span><span class="dt">Control.Lens.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Encode</span>                (fromValue)
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span>         <span class="kw">as</span> <span class="dt">TLZ</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy.Builder</span> <span class="kw">as</span> <span class="dt">TLB</span>

<span class="ot">getGHUser ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)
getGHUser email <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> url <span class="fu">=</span> <span class="st">&quot;https://api.github.com/search/users?q=&quot;</span> <span class="fu">++</span> email
    body <span class="ot">&lt;-</span> simpleHTTPWithUserAgent url
    <span class="kw">let</span> login <span class="fu">=</span> <span class="highlight">body <span class="fu">^?</span> key <span class="st">&quot;items&quot;</span> <span class="fu">.</span> nth <span class="dv">0</span> <span class="fu">.</span> key <span class="st">&quot;login&quot;</span></span>
    return <span class="fu">$</span> fmap jsonValueToString login
    <span class="kw">where</span>
        jsonValueToString <span class="fu">=</span> TLZ.unpack <span class="fu">.</span> TLB.toLazyText <span class="fu">.</span> fromValue</code></pre>
<p>It looks ugly, but it’s terse. In fact each function <code>(^?)</code>, <code>key</code> and <code>nth</code> has some great mathematical properties and everything is type safe. Unfortunately I had to make my own <code>jsonValueToString</code>. I hope I simply missed a simpler existing function.</p>
<p>You can read <a href="https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms">this article on <code>lens-aeson</code> and prisms</a> to know more.</p>
<h4 id="concurrency">Concurrency</h4>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/priest.jpg" alt="Priests"/>
</div>
<p>We now have all the feature provided by the original <code>zsh</code> script shell. But here is a good occasion to use some Haskell great feature.</p>
<p>We will launch the API request sooner and in parallel to minimize our wait time:</p>
<pre><code>import Control.Concurrent
...
main :: IO ()
main = do
    intro
    gitconfig &lt;- safeReadGitConfig
    let (name,email) = getNameAndMail gitconfig
    <span class="highlight">earlyhint &lt;- newEmptyMVar</span>
    <span class="highlight">maybe   (putMVar earlyhint Nothing)</span> -- if no email found put Nothing
            <span class="highlight">(\hintmail -&gt; do</span>  -- in the other case request the github API
                <span class="highlight">forkIO (putMVar earlyhint =&lt;&lt; getGHUser hintmail)</span>
                <span class="highlight">return ())</span>
            <span class="highlight">email</span>
    project &lt;- ask &quot;project name&quot; Nothing
    ioassert (checkProjectName project)
             &quot;Use only letters, numbers, spaces ans dashes please&quot;
    let projectname = projectNameFromString project
        modulename  = capitalize project
    in_author       &lt;- ask &quot;name&quot; name
    in_email        &lt;- ask &quot;email&quot; email
    <span class="highlight">ghUserHint      &lt;- if (maybe &quot;&quot; id email) /= in_email</span>
                            <span class="highlight">then getGHUser in_email</span>
                            <span class="highlight">else takeMVar earlyhint</span>
    in_ghaccount    &lt;- ask &quot;github account&quot; ghUserHint
    in_synopsis     &lt;- ask &quot;project in less than a dozen word?&quot; Nothing
    current_year    &lt;- getCurrentYear
    createProject $ Project projectname modulename in_author in_email
                            in_ghaccount in_synopsis current_year
    end</code></pre>
<p>While it might feel a bit confusing, it is in fact quite simple.</p>
<ol style="list-style-type: decimal">
<li>declare an <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html"><code>MVar</code></a>. Mainly a variable which either is empty or contains something.</li>
<li>If we didn’t found any email hint, put Nothing in the <code>MVar</code>.</li>
<li>If we have an email hint, ask on the github API in a new process and once finished put the result in the <code>MVar</code>.</li>
<li>If the user enter an email different from the hint email, then just request the github api now.</li>
<li>If the user enter the same email, then wait for the MVar to be filled and ask the next question with the result.</li>
</ol>
<p>If you have a github account and had set correctly your <code>.gitconfig</code>, you might not even wait.</p>
<h2 id="project-structure">Project Structure</h2>
<p>We have a working product. But, I don’t consider our job finished. The code is about 335 lines.</p>
<p>Considering that we:</p>
<ul>
<li>have 29 lines of import and 52 lines of comments (rest 255 lines)</li>
<li>ask questions</li>
<li>use a templating system to generate files</li>
<li>call an asynchronous HTTP request</li>
<li>parse JSON</li>
<li>parse <code>.gitconfig</code></li>
<li>use colored output</li>
</ul>
<p>This is quite few.</p>
<h3 id="modularizing">Modularizing</h3>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/black-knight.jpg" alt="The Black Knight"/>
</div>
<p>For short programs it is not obvious to split them into different modules. But my personal preference is to split it anyway.</p>
<p>First we put all content of <code>src/Main.hs</code> in <code>src/HolyProject.hs</code>. We rename the <code>main</code> function by <code>holyStarter</code>. And our <code>src/Main.hs</code> should contains:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">HolyProject</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> holyStarter</code></pre>
<p>Of course you have to remember to rename the module of <code>src/HolyProject.hs</code>. I separated all functions in different submodules:</p>
<ul>
<li><code>HolyProject.GitConfig</code>
<ul>
<li><code>getNameAndMailFromGitConfig</code>: retrieve name an email from <code>.gitconfig</code> file</li>
</ul></li>
<li><code>HolyProject.GithubAPI</code>
<ul>
<li><code>searchGHUser</code>: retrieve github user name using github API.</li>
</ul></li>
<li><code>HolyProject.MontyPython</code>
<ul>
<li><code>bk</code>: bridge keeper speaks</li>
<li><code>you</code>: you speak</li>
<li><code>ask</code>: Ask a question and wait for an answer</li>
</ul></li>
<li><code>HolyProject.StringUtils</code>: String helper functions
<ul>
<li><code>projectNameFromString</code></li>
<li><code>capitalize</code></li>
<li><code>checkProjectName</code></li>
</ul></li>
</ul>
<p>The <code>HolyProject.hs</code> file contains mostly the code that ask questions, show errors and copy files using hastache.</p>
<p>One of the benefits in modularizing the code is that our main code is clearer. Some functions are declared only in a module and are not exported. This help us hide technical details. For example, the modification of the HTTP header to use the github API.</p>
<h3 id="documenting">Documenting</h3>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/holy-grenade.jpg" alt="The Holy Grenade"/>
</div>
<p>We didn’t take much advantage of the project structure yet. A first thing is to generate some documentation. Before most function I added comment starting with <code>-- |</code>. These comment will be used by haddock to create a documentation. First, you need to install <code>haddock</code> manually.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> install haddock</code></pre>
<p>Be sure to have <code>haddock</code> in your <code>PATH</code>. You could for example add it like this:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># You might want to add this line in your .profile</span>
<span class="kw">export</span> <span class="ot">PATH=$PATH</span>:./.cabal-sandbox/bin</code></pre>
<p>And if you are at the root of your project you’ll get it. And now just launch:</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> haddock</code></pre>
<p>And magically, you’ll have a documentation in <code>dist/doc/html/holy-project/index.html</code>.</p>
<h3 id="tests">Tests</h3>
<p>While the Haskell static typing is quite efficient to prevent entire classes of bugs, Haskell doesn’t discard the need to test to minimize the number of bugs.</p>
<h4 id="unit-testing-with-hunit">Unit Testing with HUnit</h4>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/witch.jpg" alt="A Witch! A Witch!"/>
</div>
<p>It is generally said to test we should use unit testing for code in IO and QuickCheck or SmallCheck for pure code.</p>
<p>A unit test example on pure code is in the file <code>test/HolyProject/Swallow/Test.hs</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">HolyProject.Swallow.Test</span>
    (swallowSuite)
<span class="kw">where</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span> (testGroup, <span class="dt">TestTree</span>)
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">HolyProject.Swallow</span> (<span class="highlight">swallow</span>)

<span class="ot">swallowSuite ::</span> <span class="dt">TestTree</span>
swallowSuite <span class="fu">=</span> testGroup <span class="st">&quot;Swallow&quot;</span>
    [testCase <span class="st">&quot;swallow test&quot;</span> testSwallow]

<span class="co">-- in Swallow: swallow = (++)</span>
<span class="ot">testSwallow ::</span> <span class="dt">Assertion</span>
testSwallow <span class="fu">=</span> <span class="st">&quot;something&quot;</span> <span class="fu">@=?</span> <span class="highlight">swallow</span> <span class="st">&quot;some&quot;</span> <span class="st">&quot;thing&quot;</span></code></pre>
<p>Note <code>swallow</code> is <code>(++)</code>. We group tests by group. Each group can contain some test suite. Here we have a test suite with only one test. The <code>(@=?)</code> verify the equality between its two parameters.</p>
<p>So now, we could safely delete the directory <code>test/HolyProject/Swallow</code> and the file <code>src/HolyProject/Swallow.hs</code>. And we are ready to make our own real world unit test. We will first test the module <code>HolyProject.GithubAPI</code>. Let’s create a file <code>test/HolyProject/GithubAPI/Test.hs</code> with the following content:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">HolyProject.GithubAPI.Test</span>
( githubAPISuite
) <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Test.Tasty</span> (testGroup, <span class="dt">TestTree</span>)
<span class="kw">import </span><span class="dt">Test.Tasty.HUnit</span>
<span class="kw">import </span><span class="dt">HolyProject.GithubAPI</span>

<span class="ot">githubAPISuite ::</span> <span class="dt">TestTree</span>
githubAPISuite <span class="fu">=</span> testGroup <span class="st">&quot;GithubAPI&quot;</span>
    [ testCase <span class="st">&quot;Yann&quot;</span> <span class="fu">$</span> ioTestEq
            (searchGHUser <span class="st">&quot;Yann.Esposito@gmail.com&quot;</span>)
            (<span class="dt">Just</span> <span class="st">&quot;\&quot;yogsototh\&quot;&quot;</span>)
    , testCase <span class="st">&quot;Jasper&quot;</span> <span class="fu">$</span> ioTestEq
            (searchGHUser <span class="st">&quot;Jasper Van der Jeugt&quot;</span>)
            (<span class="dt">Just</span> <span class="st">&quot;\&quot;jaspervdj\&quot;&quot;</span>)
    ]

<span class="co">-- | Test if some IO action returns some expected value</span>
<span class="ot">ioTestEq ::</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Assertion</span>
ioTestEq action expected <span class="fu">=</span> action <span class="fu">&gt;&gt;=</span> assertEqual <span class="st">&quot;&quot;</span> expected</code></pre>
<p>You have to modify your cabal file. More precisely, you have to add <code>HolyProject.GithubAPI</code> in the exposed modules of the library secion). You also have to update the <code>test/Test.hs</code> file to use <code>GithubAPI</code> instead of <code>Swallow</code>.</p>
<p>So we have our example of unit testing using IO. We search the github nickname for some people I know and we verify github continue to give the same answer as expected.</p>
<h4 id="property-testing-with-smallcheck-and-quickcheck">Property Testing with SmallCheck and QuickCheck</h4>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/zoot.jpg" alt="My name is Zoot. Just Zoot"/>
</div>
<p>When it comes to pure code, a very good method is to use QuickCheck and SmallCheck. SmallCheck will verify all cases up to some depth about some property. While QuickCheck will verify some random cases.</p>
<p>As this kind of verification of property is mostly doable on pure code, we will test the <code>StringUtils</code> module.</p>
<p>So don’t forget to declare <code>HolyProject.StringUtils</code> in the exposed modules in the library section of your cabal file. Remove all references to the <code>Coconut</code> module.</p>
<p>Modify the <code>test/Test.hs</code> to remove all references about <code>Coconut</code>. Create a <code>test/HolyProject/StringUtils/Test.hs</code> file containing:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">HolyProject.StringUtils.Test</span>
( stringUtilsSuite
) <span class="kw">where</span>
<span class="kw">import              </span><span class="dt">Test.Tasty</span>                      (testGroup, <span class="dt">TestTree</span>)
<span class="kw">import              </span><span class="dt">Test.Tasty.SmallCheck</span>           (forAll)
<span class="kw">import qualified</span>    <span class="dt">Test.Tasty.SmallCheck</span>       <span class="kw">as</span>  <span class="dt">SC</span>
<span class="kw">import qualified</span>    <span class="dt">Test.Tasty.QuickCheck</span>       <span class="kw">as</span>  <span class="dt">QC</span>
<span class="kw">import              </span><span class="dt">Test.SmallCheck.Series</span>          (<span class="dt">Serial</span>)
<span class="kw">import              </span><span class="dt">HolyProject.StringUtils</span>

<span class="ot">stringUtilsSuite ::</span> <span class="dt">TestTree</span>
stringUtilsSuite <span class="fu">=</span> testGroup <span class="st">&quot;StringUtils&quot;</span>
    [ SC.testProperty <span class="st">&quot;SC projectNameFromString idempotent&quot;</span> <span class="fu">$</span>
            idempotent projectNameFromString
    , SC.testProperty <span class="st">&quot;SC capitalize idempotent&quot;</span> <span class="fu">$</span>
            deeperIdempotent capitalize
    , QC.testProperty <span class="st">&quot;QC projectNameFromString idempotent&quot;</span> <span class="fu">$</span>
            idempotent capitalize
    ]

idempotent f <span class="fu">=</span> \s <span class="ot">-&gt;</span> f s <span class="fu">==</span> f (f s)

<span class="ot">deeperIdempotent ::</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> a, <span class="dt">Serial</span> m a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">SC.Property</span> m
deeperIdempotent f <span class="fu">=</span> forAll <span class="fu">$</span> SC.changeDepth1 (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">$</span> \s <span class="ot">-&gt;</span> f s <span class="fu">==</span> f (f s)</code></pre>
<p>The result is here:</p>
<pre>
All Tests
  StringUtils
    SC projectNameFromString idempotent: <span class="green">OK</span>
      206 tests completed
    SC capitalize idempotent:            <span class="green">OK</span>
      1237 tests completed
    QC projectNameFromString idempotent: <span class="red">FAIL</span>
      *** Failed! Falsifiable (after 19 tests and 5 shrinks):
      "a a"
      Use --quickcheck-replay '18 913813783 2147483380' to reproduce.
  GithubAPI
    Yann:                                <span class="green">OK</span>
    Jasper:                              <span class="green">OK</span>

<span class="red">1 out of 5 tests failed</span>
</pre>

<p>The test fail, but this is not an error. Our <code>capitalize</code> function shouldn’t be idempotent. I simply added this test to show what occurs when a test fail. If you want to look more closely to the error you could do this:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./interact</span>
<span class="kw">GHCi</span>, version 7.6.2: http://www.haskell.org/ghc/   :? for help
<span class="kw">Loading</span> package ghc-prim ... linking ... done.
<span class="kw">Loading</span> package integer-gmp ... linking ... done.
<span class="kw">Loading</span> package base ... linking ... done.
<span class="kw">Prelude&gt;</span> :l src/HolyProject/StringUtils
[<span class="kw">1</span> of 1] Compiling HolyProject.StringUtils ( src/HolyProject/StringUtils.hs, interpreted )
<span class="kw">Ok</span>, modules loaded: HolyProject.StringUtils.
<span class="kw">*HolyProject.StringUtils&gt;</span> capitalize <span class="st">&quot;a a&quot;</span>
<span class="dt"><span class="highlight">&quot;AA&quot;</span></span>
<span class="kw">*HolyProject.StringUtils&gt;</span> capitalize (capitalize <span class="st">&quot;a a&quot;</span>)
<span class="dt"><span class="highlight">&quot;Aa&quot;</span></span>
<span class="kw">*HolyProject.StringUtils&gt;</span></code></pre>
<p>It is important to use <code>./interact</code> instead of <code>ghci</code>. Because we need to tell <code>ghci</code> how to found the package installed.</p>
<p>Apparently, SmallCheck didn’t found any counter example. I don’t know how it generates Strings and using deeper search is really long.</p>
<h2 id="conclusion">Conclusion</h2>
<div>
<img src="/Scratch/img/blog/Holy-Haskell-Starter/a-blessing.jpg" alt="Rabbit"/>
</div>
<p>Congratulation!</p>
<p>Now you could start programming in Haskell and publish your own cabal package.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>For example, you have to install the test libraries manually to use <code>cabal test</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>There is no easy way to do something like <code>name=$(ask name)</code>. Simply because <code>$(ask name)</code> run in another process which doesn’t get access to the standard input<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Having a good level of power in templates is very difficult. <span class="sc"><abbr title="In my Humble Opinion">imho</abbr></span> Mustache has made the best compromise.<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Parsec Presentation</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Parsec-Presentation/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Parsec-Presentation/index.html</id>
    <published>2013-10-09T00:00:00Z</published>
    <updated>2013-10-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<img src="http://yogsototh.github.io/parsec-presentation/parsec/img/mp/AST.png" alt="AST" /><br />
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Une introduction rapide à Parsec. Un parser en Haskell.</p>
</div>
<ul>
<li>The <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> presentation is <a href="http://yogsototh.github.io/parsec-presentation/parsec.html">here</a>.</li>
</ul>
<div style="display:none">
() () () () () ([1]{(#1)}) ([1]{(#1)}) () () () () () () () () ()
</div>
<!-- Begin slides. Just make elements with a class of slide. -->

<section class="slide">
<div style="text-align:center; font-size: .9em; width: 100%; line-height: 1.2em">
<h1 style="position: relative;">
Parsec
</h1>
<author><em class="base1">by</em> Yann Esposito</author>
<div style="font-size:.5em; margin: 0 1em;">
<twitter> <a href="http://twitter.com/yogsototh"><span class="citation">@yogsototh</span></a>, </twitter> <googleplus> <a href="https://plus.google.com/117858550730178181663">+yogsototh</a> </googleplus>
</div>
<div style="font-size:.8em">
<em class="base1">for</em> <a href="http://www.meetup.com/riviera-scala-clojure"> Riviera Scala Clojure Meetup (Haskell) </a><br/> <em class="base1">the</em> <ti style="font-size: .8em">8 Oct 2013</ti>
</div>
</div>
</section>
<section class="slide">
<h2 id="parsing">
Parsing
</h2>
<p>
Latin pars (ōrātiōnis), meaning part (of speech).
</p>
<ul>
<li>
<strong>analysing a string of symbols</strong>
</li>
<li>
<strong>formal grammar</strong>.
</li>
</ul>
</section>
<section class="slide">
<h2 id="parsing-in-programming-languages">
Parsing in Programming Languages
</h2>
<p>
Complexity:
</p>
<table>
<thead>
<tr class="header">
<th align="left">
Method
</th>
<th align="left">
Typical Example
</th>
<th align="left">
Output Data Structure
</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">
Splitting
</td>
<td align="left">
CSV
</td>
<td align="left">
Array, Map
</td>
</tr>
<tr class="even">
<td align="left">
Regexp
</td>
<td align="left">
email
</td>
<td align="left">
<ul>
<li>Fixed Layout Tree
</td>
</tr>
<tr class="odd">
<td align="left">
Parser
</td>
<td align="left">
Programming language
</td>
<td align="left">
<ul>
<li>Most Data Structure
</td>
</tr>
</tbody>
</table>
</section>
<section class="slide">
<h2 id="parser-culture">
Parser <span class="and">&amp;</span> culture
</h2>
<p>
In Haskell Parser are really easy to use.
</p>
<p>
Generally:
</p>
<ul>
<li>
In most languages: <strong>split</strong> then <strong>regexp</strong> then <strong>parse</strong>
</li>
<li>
In Haskell: <strong>split</strong> then <strong>parse</strong>
</li>
</ul>
</section>
<section class="slide">
<h2 id="parsing-example">
Parsing Example
</h2>
<p>
From String:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="dv">1</span><span class="fu">+</span><span class="dv">3</span>)<span class="fu">*</span>(<span class="dv">1</span><span class="fu">+</span><span class="dv">5</span><span class="fu">+</span><span class="dv">9</span>)</code></pre>
<p>
To data structure:
</p>
<p>
<img src="http://yogsototh.github.io/parsec-presentation/parsec/img/mp/AST.png" alt="AST" /><br />
</p>
</section>
<section class="slide">
<h2 id="parsec">
Parsec
</h2>
<blockquote>
<p>
Parsec lets you construct parsers by combining high-order Combinators to create larger expressions.
</p>
<p>
Combinator parsers are written and used within the same programming language as the rest of the program.
</p>
<p>
The parsers are first-class citizens of the languages […]“
</p>
<p>
<em><a href="http://www.haskell.org/haskellwiki/Parsec">Haskell Wiki</a></em>
</p>
</blockquote>
</section>
<section class="slide">
<h2 id="parser-libraries">
Parser Libraries
</h2>
<p>
In reality there are many choices:
</p>
<table>
<tbody>
<tr class="odd">
<td align="left">
attoparsec
</td>
<td align="left">
fast
</td>
</tr>
<tr class="even">
<td align="left">
Bytestring-lexing
</td>
<td align="left">
fast
</td>
</tr>
<tr class="odd">
<td align="left">
Parsec 3
</td>
<td align="left">
powerful, nice error reporting
</td>
</tr>
</tbody>
</table>
</section>
<section class="slide">
<h2 id="haskell-remarks-1">
Haskell Remarks (1)
</h2>
<p>
spaces are meaningful
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x   <span class="co">-- ⇔ f(x) in C-like languages</span>
f x y <span class="co">-- ⇔ f(x,y)</span></code></pre>
</section>
<section class="slide">
<h2 id="haskell-remarks-2">
Haskell Remarks (2)
</h2>
<p>
Don’t mind strange operators (<code>&lt;*&gt;</code>, <code>&lt;$&gt;</code>).<br />Consider them like separators, typically commas.<br />They are just here to deal with types.
</p>
<p>
Informally:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">toto <span class="fu">&lt;$&gt;</span> x <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;*&gt;</span> z
<span class="co">-- ⇔ toto x y z</span>
<span class="co">-- ⇔ toto(x,y,z) in C-like languages</span></code></pre>
</section>
<section class="slide">
<h2 id="minimal-parsec-examples">
Minimal Parsec Examples
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">whitespaces <span class="fu">=</span> many (oneOf <span class="st">&quot;\t &quot;</span>)
number <span class="fu">=</span> many1 digit
symbol <span class="fu">=</span> oneOf <span class="st">&quot;!#$%<span class="and">&amp;</span>|*+-/:&lt;=&gt;?@^_~&quot;</span></code></pre>
<pre class="sourceCode haskell">
<code class="sourceCode haskell"><span class="st">&quot; “</span> <span class="co">– whitespaces on” “</span> <span class="st">“”</span> <span class="co">– whitespaces on “32”</span> <span class="st">“32”</span> <span class="co">– number on “32”</span></li>
</ul></li>
</ul>
<span class="co">– number on &quot; 32 “</span> <span class="st">“number”</span> (line <span class="dv">1</span>, column <span class="dv">1</span>)<span class="fu">:</span> unexpected <span class="st">” “</span> expecting digit</code>
</pre>
</section>
<section class="slide">
<h2 id="comparison-with-regexp-parsec">
Comparison with Regexp (Parsec)
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IP</span> <span class="fu">=</span> <span class="dt">IP</span> <span class="dt">Word8</span> <span class="dt">Word8</span> <span class="dt">Word8</span> <span class="dt">Word8</span>
ip <span class="fu">=</span> <span class="dt">IP</span> <span class="fu">&lt;$&gt;</span>                             <span class="co">-- number.number.number.number</span>
       number <span class="fu">&lt;*</span>  char <span class="ch">&#39;.&#39;</span> <span class="fu">&lt;*&gt;</span>          <span class="co">-- put that in an IP data type</span>
       number <span class="fu">&lt;*</span>  char <span class="ch">&#39;.&#39;</span> <span class="fu">&lt;*&gt;</span>
       number <span class="fu">&lt;*</span>  char <span class="ch">&#39;.&#39;</span> <span class="fu">&lt;*&gt;</span>
       number
number <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> <span class="fu">read</span> <span class="fu">&lt;$&gt;</span> many1 digit <span class="co">-- read the number</span>
    guard (<span class="dv">0</span> <span class="fu">&lt;=</span> x <span class="fu"><span class="and">&amp;</span><span class="and">&amp;</span></span> x <span class="fu">&lt;</span> <span class="dv">256</span>) <span class="co">-- ensure it is 0 &lt;= x &lt; 256</span>
    <span class="fu">return</span> (<span class="fu">fromIntegral</span> x)   <span class="co">-- returns a Word8</span></code></pre>
</section>
<section class="slide">
<h2 id="comparison-with-regexp-perl-regexp">
Comparison with Regexp (Perl Regexp)
</h2>
<pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># remark: 888.999.999.999 is accepted</span>
\b\d{<span class="dv">1</span>,<span class="dv">3</span>}\.\d{<span class="dv">1</span>,<span class="dv">3</span>}\.\d{<span class="dv">1</span>,<span class="dv">3</span>}\.\d{<span class="dv">1</span>,<span class="dv">3</span>}\b

<span class="co"># exact but difficult to read</span>
\b(?:(?:<span class="dv">25</span>[<span class="dv">0-5</span>]|<span class="dv">2</span>[<span class="dv">0-4</span>][<span class="dv">0-9</span>]|[<span class="dv">01</span>]?[<span class="dv">0-9</span>][<span class="dv">0-9</span>]?)\.){<span class="dv">3</span>}
  (?:<span class="dv">25</span>[<span class="dv">0-5</span>]|<span class="dv">2</span>[<span class="dv">0-4</span>][<span class="dv">0-9</span>]|[<span class="dv">01</span>]?[<span class="dv">0-9</span>][<span class="dv">0-9</span>]?)\b</code></pre>
<p>
Also, regexp are <em>unityped</em> by nature.
</p>
</section>
<section class="slide">
<h2 id="monadic-style">
Monadic style
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
number <span class="fu">=</span> many1 digit

<span class="ot">number&#39; ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
number&#39; <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- digitString :: String</span>
    digitString <span class="ot">&lt;-</span> many1 digit
    <span class="fu">return</span> (<span class="fu">read</span> digitString)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;32&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]  <span class="co">-- number on &quot;32&quot;</span>
<span class="dv">32</span><span class="ot">   ::</span> <span class="dt">Int</span>     <span class="co">-- number&#39; on &quot;32&quot;</span></code></pre>
</section>
<section class="slide">
<h2 id="combining-monadic-style-s-asb-ε">
Combining Monadic style (S = aSb | ε)
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">s <span class="fu">=</span> <span class="kw">do</span>
        a <span class="ot">&lt;-</span> string <span class="st">&quot;a&quot;</span>
        mid <span class="ot">&lt;-</span> s
        b <span class="ot">&lt;-</span> string <span class="st">&quot;b&quot;</span>
        <span class="fu">return</span> (a <span class="fu">++</span> mid <span class="fu">++</span> b)
    <span class="fu">&lt;|&gt;</span> string <span class="st">&quot;&quot;</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;&quot;</span>          <span class="co">-- s on &quot;&quot;</span>
<span class="st">&quot;aaabbb&quot;</span>    <span class="co">-- s on &quot;aaabbb&quot;</span>
<span class="st">&quot;aabb&quot;</span>      <span class="co">-- s on &quot;aabbb&quot;</span>
<span class="co">-- s on &quot;aaabb&quot;</span>
<span class="dt">S</span> (line1 <span class="dv">1</span>, column <span class="dv">4</span>)<span class="fu">:</span>
unexpected end <span class="kw">of</span> input
expecting <span class="st">&quot;b&quot;</span></code></pre>
</section>
<section class="slide">
<h2 id="combining-applicative-style-s-asb-ε">
Combining Applicative style (S = aSb | ε)
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell">s <span class="fu">=</span> concat3 <span class="fu">&lt;$&gt;</span> string <span class="st">&quot;a&quot;</span> <span class="fu">&lt;*&gt;</span> s <span class="fu">&lt;*&gt;</span> char <span class="st">&quot;b&quot;</span>
    <span class="fu">&lt;|&gt;</span> string <span class="st">&quot;&quot;</span>
    <span class="kw">where</span>
        concat3 x y z <span class="fu">=</span> x <span class="fu">++</span> y <span class="fu">++</span> z</code></pre>
</section>
<section class="slide">
<h2 id="applicative-style-usefull-with-data-types">
Applicative Style usefull with Data types
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">IP</span> <span class="fu">=</span> <span class="dt">IP</span> <span class="dt">Word8</span> <span class="dt">Word8</span> <span class="dt">Word8</span> <span class="dt">Word8</span>

parseIP <span class="fu">=</span> <span class="dt">IP</span> <span class="fu">&lt;$&gt;</span>
            number <span class="fu">&lt;*</span>  char <span class="ch">&#39;.&#39;</span> <span class="fu">&lt;*&gt;</span>
            number <span class="fu">&lt;*</span>  char <span class="ch">&#39;.&#39;</span> <span class="fu">&lt;*&gt;</span>
            number <span class="fu">&lt;*</span>  char <span class="ch">&#39;.&#39;</span> <span class="fu">&lt;*&gt;</span>
            number

monadicParseIP <span class="fu">=</span> <span class="kw">do</span>
    d1 <span class="ot">&lt;-</span> number
    char <span class="ch">&#39;.&#39;</span>
    d2 <span class="ot">&lt;-</span> number
    char <span class="ch">&#39;.&#39;</span>
    d3 <span class="ot">&lt;-</span> number
    char <span class="ch">&#39;.&#39;</span>
    d4 <span class="ot">&lt;-</span> number
    <span class="fu">return</span> (<span class="dt">IP</span> d1 d2 d3 d4)</code></pre>
</section>
<section class="slide">
<h2 id="write-number-correctly">
Write number correctly
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">Word8</span>
number <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> <span class="fu">read</span> <span class="fu">&lt;$&gt;</span> many1 digit
    guard (<span class="dv">0</span> <span class="fu">&lt;=</span> x <span class="fu"><span class="and">&amp;</span><span class="and">&amp;</span></span> x <span class="fu">&lt;</span> <span class="dv">256</span>) <span class="fu">&lt;?&gt;</span>
        <span class="st">&quot;Number between 0 and 255 (here &quot;</span> <span class="fu">++</span> <span class="fu">show</span> x <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
    <span class="fu">return</span> (<span class="fu">fromIntegral</span> x)</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span> test parseIP <span class="st">&quot;parseIP&quot;</span> <span class="st">&quot;823.32.80.113&quot;</span>
<span class="st">&quot;parseIP&quot;</span> (line <span class="dv">1</span>, column <span class="dv">4</span>)<span class="fu">:</span>
unexpected <span class="st">&quot;.&quot;</span>
expecting digit <span class="fu">or</span> <span class="dt">Number</span> between <span class="dv">0</span> <span class="fu">and</span> <span class="dv">255</span> (here <span class="dv">823</span>)</code></pre>
</section>
<section class="slide">
<h2 id="so">
So
</h2>
<ul>
<li>
combination of simple parsers
</li>
<li>
error messages with <code>(&lt;?&gt;)</code>
</li>
<li>
embed result in data type using Applicative style
</li>
<li>
Not shown, use another monad with the parser
</li>
</ul>
<p>
Time to do something cool
</p>
</section>
<section class="slide">
<h2 id="useful-definition">
Useful definition
</h2>
<p>
<code>try</code> tries to parse and backtracks if it fails.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">&lt;||&gt;</span>) parser1 parser2 <span class="fu">=</span> try parser1 <span class="fu">&lt;|&gt;</span> parser2</code></pre>
</section>
<section class="slide">
<h2 id="scheme">
Scheme
</h2>
<p>
<a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">Write Yourself a Scheme in 48 hours</a>
</p>
<p>
Remember from text to data structure. Our data structure:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LispVal</span> <span class="fu">=</span>    <span class="dt">Atom</span> <span class="dt">String</span>     <span class="co">-- print or val-3 ...</span>
                <span class="fu">|</span> <span class="dt">Number</span> <span class="dt">Integer</span>  <span class="co">-- 32</span>
                <span class="fu">|</span> <span class="dt">String</span> <span class="dt">String</span>   <span class="co">-- &quot;foo&quot;</span>
                <span class="fu">|</span> <span class="dt">Bool</span> <span class="dt">Bool</span>       <span class="co">-- #t or #f</span>
                <span class="fu">|</span> <span class="dt">List</span> [<span class="dt">LispVal</span>]  <span class="co">-- (print &quot;foo&quot; &quot;bar&quot;)</span></code></pre>
<p>
Next will parse String, Atom, Integer
</p>
</section>
<section class="slide">
<h2 id="parse-string">
Parse String
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseString ::</span> <span class="dt">Parser</span> <span class="dt">LispVal</span>
parseString <span class="fu">=</span> <span class="kw">do</span>
    char <span class="ch">&#39;&quot;&#39;</span>
    x <span class="ot">&lt;-</span> many (noneOf <span class="st">&quot;\&quot;&quot;</span>)
    char <span class="ch">&#39;&quot;&#39;</span>
    <span class="fu">return</span> (<span class="dt">String</span> x)</code></pre>
<pre><code>-- parseString on &#39;&quot;toto&quot;&#39;
String &quot;toto&quot; :: LispVal
-- parseString on &#39;&quot; hello&quot;&#39;
String &quot; hello&quot; :: LispVal</code></pre>
</section>
<section class="slide">
<h2 id="parse-atom">
Parse Atom
</h2>
<p>
In Scheme true is <code>#t</code> and false <code>#f</code>. Which are also valid Atoms.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">symbol ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
symbol <span class="fu">=</span> oneOf <span class="st">&quot;!#$%<span class="and">&amp;</span>|*+-/:&lt;=&gt;?@^_~&quot;</span>

<span class="ot">parseAtom ::</span> <span class="dt">Parser</span> <span class="dt">LispVal</span>
parseAtom <span class="fu">=</span> <span class="kw">do</span>
    first <span class="ot">&lt;-</span> letter <span class="fu">&lt;|&gt;</span> symbol
    rest <span class="ot">&lt;-</span> many (letter <span class="fu">&lt;|&gt;</span> digit <span class="fu">&lt;|&gt;</span> symbol)
    <span class="kw">let</span> atom <span class="fu">=</span> first<span class="fu">:</span>rest
    <span class="fu">return</span> <span class="fu">$</span> <span class="kw">case</span> atom <span class="kw">of</span>
                <span class="st">&quot;#t&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="kw">True</span>
                <span class="st">&quot;#f&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="kw">False</span>
                _    <span class="ot">-&gt;</span> <span class="dt">Atom</span> atom</code></pre>
</section>
<section class="slide">
<h2 id="test-parseatom">
Test <code>parseAtom</code>
</h2>
<pre><code>-- parseAtom on &#39;#t&#39;
Bool True :: LispVal
-- parseAtom on &#39;#f&#39;
Bool False :: LispVal
-- parseAtom on &#39;some-atom&#39;
Atom &quot;some-atom&quot; :: LispVal</code></pre>
</section>
<section class="slide">
<h2 id="parse-number">
Parse Number
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseNumber ::</span> <span class="dt">Parser</span> <span class="dt">LispVal</span>
parseNumber <span class="fu">=</span> <span class="dt">Number</span> <span class="fu">.</span> <span class="fu">read</span> <span class="fu">&lt;$&gt;</span> many1 digit</code></pre>
<pre><code>-- parseNumber on &#39;18&#39;
Number 18 :: LispVal
-- parseNumber on &#39;188930992344321234&#39;
Number 188930992344321234 :: LispVal</code></pre>
</section>
<section class="slide">
<h2 id="compose-all-parsers">
Compose all parsers
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> <span class="dt">LispVal</span>
parseExpr <span class="fu">=</span> parseAtom
            <span class="fu">&lt;||&gt;</span> parseString
            <span class="fu">&lt;||&gt;</span> parseNumber</code></pre>
</section>
<section class="slide">
<h2 id="test-the-parser">
Test the parser
</h2>
<pre><code>-- parseExpr on &#39;188930992344321234&#39;
Number 188930992344321234 :: LispVal
-- parseExpr on &#39;#t&#39;
Bool True :: LispVal
-- parseExpr on &#39;just-some-word&#39;
Atom &quot;just-some-word&quot; :: LispVal
-- parseExpr on &#39;%-symbol-start&#39;
Atom &quot;%-symbol-start&quot; :: LispVal
-- parseExpr on &#39;&quot;a String&quot;&#39;
String &quot;a String&quot; :: LispVal</code></pre>
</section>
<section class="slide">
<h2 id="recursive-parsers">
Recursive Parsers
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parseList ::</span> <span class="dt">Parser</span> <span class="dt">LispVal</span>
parseList <span class="fu">=</span> <span class="dt">List</span> <span class="fu">&lt;$&gt;</span>
    (char <span class="ch">&#39;(&#39;</span> <span class="fu">*&gt;</span> sepBy parseExpr&#39; spaces <span class="fu">&lt;*</span> char <span class="ch">&#39;)&#39;</span> )

<span class="ot">parseExpr&#39; ::</span> <span class="dt">Parser</span> <span class="dt">LispVal</span>
parseExpr&#39; <span class="fu">=</span> parseAtom
             <span class="fu">&lt;||&gt;</span> parseString
             <span class="fu">&lt;||&gt;</span> parseNumber
             <span class="fu">&lt;||&gt;</span> parseList</code></pre>
</section>
<section class="slide">
<h2 id="test-parse-list">
Test Parse List
</h2>
<pre><code>-- parseExpr&#39; on &#39;(foo (bar baz))&#39;
List [Atom &quot;foo&quot;,List [Atom &quot;bar&quot;,Atom &quot;baz&quot;]] :: LispVal

-- parseExpr&#39; on &#39;(foo (bar)&#39;
&quot;parseExpr&#39;&quot; (line 1, column 11):
unexpected end of input
expecting white space, letter, &quot;\&quot;&quot;, digit, &quot;(&quot; or &quot;)&quot;

-- parseExpr&#39; on &#39;(((foo)) bar)&#39;
List [List [List [Atom &quot;foo&quot;]],Atom &quot;bar&quot;] :: LispVal</code></pre>
</section>
<section class="slide">
<h2 id="remark">
Remark
</h2>
<p>
Why Haskell?
</p>
<p>
Close relation between parser and data types.
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Product</span> a b <span class="fu">=</span> <span class="dt">Product</span> a b
<span class="kw">data</span> <span class="dt">Sum</span> a b <span class="fu">=</span> <span class="dt">A</span> a <span class="fu">|</span> <span class="dt">B</span> b</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">productParser <span class="fu">=</span> <span class="kw">do</span>
                  parser1
                  parser2
sumParser <span class="fu">=</span> parser1 <span class="fu">&lt;||&gt;</span> parser2</code></pre>
</section>
<section class="slide">
<h2 id="remark-2">
Remark (2)
</h2>
<p>
Similar structure:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MyType</span> <span class="fu">=</span> <span class="dt">X</span> <span class="dt">Int</span> <span class="dt">Char</span> <span class="fu">|</span> <span class="dt">Y</span> <span class="dt">String</span>

parseMyType <span class="fu">=</span>      (<span class="dt">X</span> <span class="fu">&lt;$&gt;</span> parseInt <span class="fu">&lt;*&gt;</span> parseChar) 
              <span class="fu">&lt;||&gt;</span> (<span class="dt">Y</span> <span class="fu">&lt;$&gt;</span> parseString)</code></pre>
</section>
<section class="slide">
<h2 id="remark-3">
Remark (3)
</h2>
<p>
Similar structure:
</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Answer</span> <span class="fu">=</span> <span class="dt">YES</span> <span class="fu">|</span> <span class="dt">NO</span> <span class="fu">|</span> <span class="dt">MAYBE</span>
<span class="kw">data</span> <span class="dt">MyType</span> <span class="fu">=</span> <span class="dt">X</span> <span class="dt">Int</span> <span class="dt">Answer</span> <span class="fu">|</span> <span class="dt">Y</span> <span class="dt">String</span>

parseAnswer <span class="fu">=</span> parseYES <span class="fu">&lt;||&gt;</span> parseNO <span class="fu">&lt;||&gt;</span> parseMAYBE
parseMyType <span class="fu">=</span>      (<span class="dt">X</span> <span class="fu">&lt;$&gt;</span> parseInt <span class="fu">&lt;*&gt;</span> parseAnswer) 
              <span class="fu">&lt;||&gt;</span> (<span class="dt">Y</span> <span class="fu">&lt;$&gt;</span> parseString)</code></pre>
</section>
<section class="slide">
<h2 id="conclusion">
Conclusion
</h2>
<p>
So Parser are more powerful than regular expression.<br />Parsec make it very easy to use.<br />Easy to read and to manipulate.
</p>
<p>
Notice how you could use parser as any other object in Haskell.<br />You could <code>mapM</code> them for example.
</p>
<p>
Any question?
</p>
</section>
<section class="slide">
<h2 id="appendice-do-it-yourself">
Appendice (Do it yourself)
</h2>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span>
<span class="kw">import</span> Control.Applicative <span class="kw">hiding</span> (many, (&lt;|&gt;))
<span class="kw">import</span> Text.Parsec
<span class="kw">import</span> Data.Typeable
<span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parsec</span> <span class="dt">String</span> () a

myparser <span class="fu">=</span> many1 letter

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> test myparser <span class="st">&quot;myparser&quot;</span> <span class="st">&quot;(my (string to) parse)&quot;</span>

<span class="ot">test ::</span> (<span class="dt">Typeable</span> a, <span class="kw">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
test parser description string <span class="fu">=</span> <span class="kw">do</span>
    <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="st">&quot;-- &quot;</span> <span class="fu">++</span> description <span class="fu">++</span> <span class="st">&quot; on \&quot;&quot;</span> <span class="fu">++</span> string <span class="fu">++</span> <span class="st">&quot;\&quot;&quot;</span>
    <span class="kw">let</span> res <span class="fu">=</span> parse parser description string
    <span class="kw">case</span> res <span class="kw">of</span>
        <span class="kw">Left</span>  err   <span class="ot">-&gt;</span> <span class="fu">print</span> err
        <span class="kw">Right</span> value <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">show</span> value <span class="fu">++</span> <span class="st">&quot; :: &quot;</span> <span class="fu">++</span> <span class="fu">show</span> (typeOf value)</code></pre>
</section>
<section class="slide">
<h2 id="appendice-2">
Appendice (2)
</h2>
<p>
Links to example code:
</p>
<ul>
<li>
<a href="http://yogsototh.github.io/parsec-presentation/parsec/examples/01.hs">examples1.hs</a>
</li>
<li>
<a href="http://yogsototh.github.io/parsec-presentation/parsec/examples/scheme.hs">scheme.hs</a>
</li>
</ul>
</section>
<!-- End slides. -->

]]></summary>
</entry>
<entry>
    <title>Rational Web Framework Choice</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Rational-Web-Framework-Choice/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Rational-Web-Framework-Choice/index.html</id>
    <published>2013-08-06T00:00:00Z</published>
    <updated>2013-08-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Rational-Web-Framework-Choice/battle-of-lepanto-vicentino-andrea.jpg" alt="Main image"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Comment déterminer de la façon la plus rationnelle possible le meilleur framework work relativement à vos besoins. <a href="#the-result">Cliquez ici pour aller au résultats</a>. Cet article n’est disponible qu’en anglais.</p>
</div>
<p>This is it.<br />You’ve got the next big idea.<br />You just need to make a very simple web application.</p>
<p>It sounds easy! You just need to choose a good modern web framework, when suddenly:</p>
<figure>
<img src="/Scratch/img/blog/Rational-Web-Framework-Choice/choice_paralysis.gif" alt="[Choice Paralysis][choice_paralysis]"/>
<figcaption>
<a href="https://en.wikipedia.org/wiki/Analysis_paralysis">Choice Paralysis</a>
</figcaption>
</figure>

<p>After your brain stack overflowed, you decide to use a very simple methodology. Answer two questions:</p>
<p><strong>Which language am I familiar with?<br />What is the most popular web framework for this language?</strong></p>
<p>Great! This is it.</p>
<p>But, you continually hear this little voice.</p>
<blockquote>
<p><strong>“You didn’t made a bad choice, yes. But …<br />you hadn’t made the best either.”</strong></p>
</blockquote>
<p>This article try to determine in the most objective and rational way the best(s) web framework(s) depending on your needs. To reach this goal, I will provide a decision tool in the result section.</p>
<p>I will use the following methodology:</p>
<p><strong>Methodology</strong></p>
<ol style="list-style-type: decimal">
<li>Model how to make choice
<ol style="list-style-type: lower-alpha">
<li>choose important parameters</li>
<li>organize (hierarchize) them</li>
<li>write down an objective chooser</li>
</ol></li>
<li>Grab objective quantified informations about web frameworks relatively to choosen parameters</li>
<li>Sanitize your data in order to handle imprecisions, lack of informations…</li>
<li>Apply the model of choice to your informations</li>
</ol>
<blockquote>
<p><strong>☞ Important Note</strong><br />I am far from happy to the actual result. There are a lot of biases, for example in the choice of the parameters. The same can be said about the data I gathered. I am using very imprecise informations. But, as far as I know, this is the only article which use many different parameters to help you choose a web framework.</p>
<p>This is why I made a very flexible decision tool:</p>
<p><a href="#the-result">Decision tool</a>.</p>
</blockquote>
<h2 id="model">Model</h2>
<p>Here are the important features (properties/parameters) I selected to make the choice:</p>
<ol style="list-style-type: decimal">
<li><em><strong>Popularity</strong></em>, which correlate with:
<ul>
<li>number of tested libraries</li>
<li>facility to find learning material</li>
<li>ability to find another developer to work with</li>
</ul></li>
<li><em><strong>Efficiency</strong></em>, which is generally correlated to:
<ul>
<li>how much processing power you’ll need per user</li>
<li>maintenance price per user</li>
<li>how long the user will wait to see/update data</li>
</ul></li>
<li><em><strong>Expressiveness</strong></em>, which is generally correlated to:
<ul>
<li>faster development</li>
<li>flexibility, adaptability</li>
</ul></li>
<li><em><strong>Robustness</strong></em>, which correlate with:
<ul>
<li>security</li>
<li>fewer bugs</li>
</ul></li>
</ol>
<p>Each feature is quite important and mostly independant from each other. I tried to embrace most important topics concerning web frameworks with these four properties. I am fully concious some people might lack another important feature. Nonetheless the methodology used here can be easily replicated. If you lack an important property add it at will and use this choice method.</p>
<p>Also each feature is very hard to measure with precision. This is why we will only focus on order of magnitude.</p>
<p>For each property a framework could have one of the six possible values: Excellent, Very Good, Good, Medium, Bad or Very Bad</p>
<p>So how to make a decision model from these informations?</p>
<p>One of the most versatile method is to give a weight for each cluster value. And to select the framework maximizing this score:</p>
<pre><code>score(framework) = efficiency + robustness + expressiveness + popularity</code></pre>
<blockquote>
<p>For example:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">Expressiveness</td>
<td align="right">10</td>
<td align="right">7</td>
<td align="right">1</td>
<td align="right">-∞</td>
<td align="right">-∞</td>
<td align="right">-∞</td>
</tr>
<tr class="even">
<td align="left">Popularity</td>
<td align="right">5</td>
<td align="right">5</td>
<td align="right">4</td>
<td align="right">3</td>
<td align="right">2</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="left">Efficiency</td>
<td align="right">10</td>
<td align="right">8</td>
<td align="right">6</td>
<td align="right">4</td>
<td align="right">2</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">Robustness</td>
<td align="right">10</td>
<td align="right">8</td>
<td align="right">6</td>
<td align="right">4</td>
<td align="right">2</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>Using this weighted table, that means:</p>
<ul>
<li>we discard the three least expressive clusters.</li>
<li>We don’t make any difference between excellent and very good in popularity.</li>
<li>Concerning efficient framework in excellent cluster will have 2 more points than the “very good” cluster.</li>
</ul>
<p>So for each framework we compute its score relatively to a weighted table. And we select the best(s).</p>
<p><strong>Example</strong>: Using this hypothetic framework and the preceeding table.</p>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Expressiveness</th>
<th align="left">Popularity</th>
<th align="left">Efficiency</th>
<th align="left">Robustness</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">yog</td>
<td align="left">Excellent</td>
<td align="left">Very Bad</td>
<td align="left">Medium</td>
<td align="left">Very Good</td>
</tr>
</tbody>
</table>
<pre><code>score(yog) = 10 + 0 + 4 + 8 = 22</code></pre>
</blockquote>
<p>Most needs should be expressed by such a weighted table. In the result section, we will discuss this further.</p>
<p>It is now time to try to get these measures.</p>
<h2 id="objective-measures">Objective measures</h2>
<p>None of the four properties I choosen can be measured with perfect precision. But we could get the order of magnitude for each.</p>
<p>I tried to focus on the framework only. But it is often easier to start by studying the language first.</p>
<p>For example, I have datas about popularity by language and I also have different datas concerning popularity by framework. Even if I use only the framework focused datas in my final decision model, it seemed important to me to discuss about the datas for the languages. The goal is to provide a tool to help decision not to give a decision for you.</p>
<h3 id="popularity">Popularity</h3>
<p><a href="http://redmonk.com/sogrady/2013/02/28/language-rankings-1-13/">RedMonk Programming Language Rankings (January 2013)</a> provide an apparent good measure of popularity. While not perfect the current measure feel mostly right. They create an image using stack overflow and github data. Vertical correspond to the number of questions on stackoverflow. Horizontal correspond to the number of projects on github.</p>
<p>If you look at the image, your eye can see about four clusters. The 1<sup>ﬆ</sup> cluster correspond to mainstream languages:</p>
<figure>
<img src="/Scratch/img/blog/Rational-Web-Framework-Choice/mainstreamlanguages.png" alt="Mainstream Languages Cluster from [RedMonk][redmonk]"/>
<figcaption>
Mainstream Languages Cluster from <a href="http://redmonk.com/sogrady/2013/02/28/language-rankings-1-13/">RedMonk</a>
</figcaption>
</figure>

<p>Most developer know at least one of these language.</p>
<p>The second cluster is quite bigger. It seems to correspond to languages with a solid community behind them.</p>
<figure>
<img src="/Scratch/img/blog/Rational-Web-Framework-Choice/secondtierlanguages.png" alt="Second tier languages from [RedMonk][redmonk]"/>
<figcaption>
Second tier languages from <a href="http://redmonk.com/sogrady/2013/02/28/language-rankings-1-13/">RedMonk</a>
</figcaption>
</figure>

<p>I don’t get into detail, but you could also see third and fourth tier popular languages.</p>
<p>So:</p>
<p><strong>Mainstream</strong>: JavaScript, Java, PHP, Python, Ruby, <code>C#</code>, <code>C++</code>, <code>C</code>, Objective-C, Perl, Shell</p>
<p><strong>Good</strong>: Scala, Haskell, Visual Basic, Assembly, R, Matlab, ASP, ActionScript, Coffeescript, Groovy, Clojure, Lua, Prolog</p>
<p><strong>Medium</strong>: Erlang, Go, Delphi, D, Racket, Scheme, ColdFusion, F#, FORTRAN, Arduino, Tcl, Ocaml</p>
<p><strong>Bad</strong>: third tier <strong>Very Bad</strong>: fourth tier</p>
<p>I don’t thing I could find easily web frameworks for third or fourth tier languages.</p>
<p>For now, I only talked about language popularity. But what about framework popularity? I made a test using number of question on stackoverflow only. Then by dividing by two for each 6 cluster:</p>
<table>
<thead>
<tr class="header">
<th align="left">Cluster</th>
<th align="left">Language</th>
<th align="left">Framework</th>
<th align="right">#nb</th>
<th align="right">%</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Excellent</td>
<td align="left">Ruby</td>
<td align="left">Rails</td>
<td align="right">176208</td>
<td align="right">100%</td>
</tr>
<tr class="even">
<td align="left">Very Good</td>
<td align="left">Python</td>
<td align="left">Django</td>
<td align="right">57385</td>
<td align="right">&lt;50%</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Servlet</td>
<td align="right">54139</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Spring</td>
<td align="right">31641</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Node.js</td>
<td align="left">node.js</td>
<td align="right">27243</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Codeigniter</td>
<td align="right">21503</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Groovy</td>
<td align="left">Grails</td>
<td align="right">20222</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left">Good</td>
<td align="left">Ruby</td>
<td align="left">Sinatra</td>
<td align="right">8631</td>
<td align="right">&lt;25%</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Python</td>
<td align="left">Flask</td>
<td align="right">7062</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Laravel</td>
<td align="right">6982</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Kohana</td>
<td align="right">5959</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Node.js</td>
<td align="left">Express</td>
<td align="right">5009</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left">Medium</td>
<td align="left">PHP</td>
<td align="left">Cake</td>
<td align="right">4554</td>
<td align="right">&lt;13%</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C♯</td>
<td align="left">ServiceStack</td>
<td align="right">3838</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Scala</td>
<td align="left">Play</td>
<td align="right">3823</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Wicket</td>
<td align="right">3819</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Dart</td>
<td align="left">Dart</td>
<td align="right">3753</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Slim</td>
<td align="right">3361</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Python</td>
<td align="left">Tornado</td>
<td align="right">3321</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Scala</td>
<td align="left">Lift</td>
<td align="right">2844</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">Go</td>
<td align="right">2689</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left">Bad</td>
<td align="left">Java</td>
<td align="left">Tapestry</td>
<td align="right">1197</td>
<td align="right">&lt;6%</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C♯</td>
<td align="left">aspnet</td>
<td align="right">1000</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Haskell</td>
<td align="left">Yesod</td>
<td align="right">889</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Silex</td>
<td align="right">750</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Lithium</td>
<td align="right">732</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C♯</td>
<td align="left">nancy</td>
<td align="right">705</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left">Very bad</td>
<td align="left">Java</td>
<td align="left">Grizzly</td>
<td align="right">622</td>
<td align="right">&lt;3%</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Erlang</td>
<td align="left">Cowboy</td>
<td align="right">568</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Perl</td>
<td align="left">Dancer</td>
<td align="right">496</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Symphony2</td>
<td align="right">491</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">Revel</td>
<td align="right">459</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Clojure</td>
<td align="left">Compojure</td>
<td align="right">391</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Perl</td>
<td align="left">Mojolicious</td>
<td align="right">376</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Scala</td>
<td align="left">Scalatra</td>
<td align="right">349</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Scala</td>
<td align="left">Finagle</td>
<td align="right">336</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Phalcon</td>
<td align="right">299</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">js</td>
<td align="left">Ringo</td>
<td align="right">299</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Gemini</td>
<td align="right">276</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Haskell</td>
<td align="left">Snap</td>
<td align="right">263</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Perl</td>
<td align="left">Plack</td>
<td align="right">257</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Erlang</td>
<td align="left">Elli</td>
<td align="right">230</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Dropwizard</td>
<td align="right">188</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Yaf</td>
<td align="right">146</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Play1</td>
<td align="right">133</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Node.js</td>
<td align="left">Hapi</td>
<td align="right">131</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Java</td>
<td align="left">Vertx</td>
<td align="right">60</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Scala</td>
<td align="left">Unfiltered</td>
<td align="right">42</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C</td>
<td align="left">onion</td>
<td align="right">18</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Clojure</td>
<td align="left">http-kit</td>
<td align="right">17</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Perl</td>
<td align="left">Kelp</td>
<td align="right">16</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Micromvc</td>
<td align="right">13</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Lua</td>
<td align="left">Openresty</td>
<td align="right">8</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C++</td>
<td align="left">cpoll-cppsp</td>
<td align="right">5</td>
<td align="right"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Clojure</td>
<td align="left">Luminus</td>
<td align="right">3</td>
<td align="right"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">Phreeze</td>
<td align="right">1</td>
<td align="right"></td>
</tr>
</tbody>
</table>
<p>As we can see, our framework popularity indicator can be quite different from its language popularity. For now I didn’t found a nice way to merge the results from RedMonk with these one. So I’ll use these unperfect one. Hopefully the order of magninute is mostly correct for most framework.</p>
<h3 id="efficiency">Efficiency</h3>
<p>Another objective measure is efficiency. We all know benchmarks are all flawed. But they are the only indicators concerning efficiency we have.</p>
<p>I used the benchmark from <a href="http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=all&amp;data=u64q">benchmarksgame</a>. Mainly, there are five clusters:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">1x→2x</td>
<td align="left"><code>C</code>, <code>C++</code></td>
</tr>
<tr class="even">
<td align="left">2x→3x</td>
<td align="left">Java 7, Scala, OCamL, Haskell, Go, Common LISP</td>
</tr>
<tr class="odd">
<td align="left">3x→10x</td>
<td align="left">C♯, Clojure, Racket, Dart</td>
</tr>
<tr class="even">
<td align="left">10x→30x</td>
<td align="left">Erlang</td>
</tr>
<tr class="odd">
<td align="left">30x→</td>
<td align="left">PHP, Python, Perl, Ruby, JRuby</td>
</tr>
</tbody>
</table>
<p>Remarks concerning some very slow languages:</p>
<ul>
<li>PHP ; huge variations, can be about 1.5x C speed in best case.</li>
<li>Python ; huge variations, can be about 1.5x C speed in best case</li>
<li>Perl ; Can be about 3x C speed in best case</li>
<li>Ruby, JRuby ; mostly very slow.</li>
</ul>
<p>This is a first approach. The speed of the language for basic benchmarks. But, here we are interrested in web programming. Fortunately techempower has made some tests focused on most web frameworks:</p>
<p><a href="http://www.techempower.com/blog/2013/07/02/frameworks-round-6/">Web framework benchmarks</a>.</p>
<p>These benchmark doesn’t fit well with our needs. The values are certainly quite imprecise to your real usage. The goal is just to get an order of magnitude for each framework. Another problem is the high number of informations.</p>
<p>As always, we should remember these informations are also imprecise. So I simply made some classes of efficiency.</p>
<p>Remark: I separated the clusters by using power of 2 relatively to the fastest.</p>
<table>
<thead>
<tr class="header">
<th align="left">Cluster</th>
<th align="left">Language</th>
<th align="left">Framework</th>
<th align="center">#nb</th>
<th align="left">slowness</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Excellent</td>
<td align="left">C++</td>
<td align="left">cpoll-cppsp</td>
<td align="center">114,711</td>
<td align="left">1×</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">gemini</td>
<td align="center">105,204</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Lua</td>
<td align="left">openresty</td>
<td align="center">93,882</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">servlet</td>
<td align="center">90,580</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C++</td>
<td align="left">cpoll-pool</td>
<td align="center">89,167</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">go</td>
<td align="center">76,024</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">finagle</td>
<td align="center">68,413</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">revel</td>
<td align="center">66,990</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">rest-express</td>
<td align="center">63,209</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Very Good</td>
<td align="left">Jav</td>
<td align="left">wicket</td>
<td align="center">48,772</td>
<td align="left">&gt;2×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">scalatra</td>
<td align="center">48,594</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">http-kit</td>
<td align="center">42,703</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">spring</td>
<td align="center">36,643</td>
<td align="left">&gt;3×</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">php</td>
<td align="center">36,605</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">tapestry</td>
<td align="center">35,032</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">compojure</td>
<td align="center">32,088</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">ringo</td>
<td align="center">31,962</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">dropwizard</td>
<td align="center">31,514</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">luminus</td>
<td align="center">30,672</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Good</td>
<td align="left">Sca</td>
<td align="left">play-slick</td>
<td align="center">29,950</td>
<td align="left">&gt;4×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">unfiltered</td>
<td align="center">29,782</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Erl</td>
<td align="left">elli</td>
<td align="center">28,862</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">vertx</td>
<td align="center">28,075</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">nodejs</td>
<td align="center">27,598</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Erl</td>
<td align="left">cowboy</td>
<td align="center">24,669</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C</td>
<td align="left">onion</td>
<td align="center">23,649</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Hkl</td>
<td align="left">yesod</td>
<td align="center">23,304</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">express</td>
<td align="center">22,856</td>
<td align="left">&gt;5×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">play-scala</td>
<td align="center">22,372</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav g</td>
<td align="left">rizzly-jersey</td>
<td align="center">20,550</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">tornado</td>
<td align="center">20,372</td>
<td align="left">&gt;6×</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">phalcon</td>
<td align="center">18,481</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Grv</td>
<td align="left">grails</td>
<td align="center">18,467</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">plack</td>
<td align="center">16,647</td>
<td align="left">&gt;7×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">yaf</td>
<td align="center">14,388</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Medium</td>
<td align="left">JS</td>
<td align="left">hapi</td>
<td align="center">11,235</td>
<td align="left">&gt;10×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play1</td>
<td align="center">9,979</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Hkl</td>
<td align="left">snap</td>
<td align="center">9,196</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">kelp</td>
<td align="center">8,250</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">flask</td>
<td align="center">8,167</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play-java</td>
<td align="center">7,905</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav p</td>
<td align="left">lay-java-jpa</td>
<td align="center">7,846</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">micromvc</td>
<td align="center">7,387</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">dancer</td>
<td align="center">5,040</td>
<td align="left">&gt;20×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">mojolicious</td>
<td align="center">4,371</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">ringo-conv</td>
<td align="center">4,249</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">django</td>
<td align="center">4,026</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">codeigniter</td>
<td align="center">3,809</td>
<td align="left">&gt;30×</td>
</tr>
<tr class="odd">
<td align="left">Bad</td>
<td align="left">Rby</td>
<td align="left">rails</td>
<td align="center">3,445</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">lift</td>
<td align="center">3,311</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">slim</td>
<td align="center">3,112</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">kohana</td>
<td align="center">2,378</td>
<td align="left">&gt;40×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">silex</td>
<td align="center">2,364</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Very Bad</td>
<td align="left">PHP</td>
<td align="left">laravel</td>
<td align="center">1,639</td>
<td align="left">&gt;60×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">phreeze</td>
<td align="center">1,410</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">lithium</td>
<td align="center">1,410</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">fuel</td>
<td align="center">1,410</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">cake</td>
<td align="center">1,287</td>
<td align="left">&gt;80×</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">symfony2</td>
<td align="center">879</td>
<td align="left">&gt;100×</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">aspnet-mvc</td>
<td align="center">871</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Rby</td>
<td align="left">sinatra</td>
<td align="center">561</td>
<td align="left">&gt;200×</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">servicestack</td>
<td align="center">51</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Dar</td>
<td align="left">dart</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">nancy</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">web-simple</td>
<td align="center">0</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>These are manually made clusters. But you get the idea. Certainly, some framework could jump between two different clusters. So this is something to remember. But as always, the order of magnitude is certainly mostly right.</p>
<h1 id="expressiveness">Expressiveness</h1>
<p>Now, how to objectively measure expressiveness?</p>
<p>RedMonk had a very good idea to find an objective (while imprecise) measure of each language expressiveness. Read this <a href="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/">article</a> for details.</p>
<p>After filtering languages suitable for web development, we end up with some clusters:</p>
<table>
<thead>
<tr class="header">
<th align="left">Cluster</th>
<th align="left">Languages</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Excellent</td>
<td align="left">Coffeescript, Clojure, Haskell</td>
</tr>
<tr class="even">
<td align="left">Very Good</td>
<td align="left">Racket, Groovy, R, Scala, OCamL, F♯, Erlang, Lisp, Go</td>
</tr>
<tr class="odd">
<td align="left">Medium</td>
<td align="left">Perl, Python, Objective-C, Scheme, Tcl, Ruby</td>
</tr>
<tr class="even">
<td align="left">Bad</td>
<td align="left">Lua, Fortran (free-format), PHP, Java, C++, C♯</td>
</tr>
<tr class="odd">
<td align="left">Very Bad</td>
<td align="left">Assembly, C, Javascript,</td>
</tr>
</tbody>
</table>
<p>Unfortunately there is no information about dart. So I simply give a very fast look at the syntax. As it looked a lot like javascript and js is quite low. I decided to put it close to java.</p>
<p>Also an important remark, javascript score very badly here while coffeescript (compiling to js) score “excellent”. So if you intend to use a javascript framework but only with coffescript that should change substantially the score. As I don’t believe it is the standard. Javascript oriented framework score very badly regarding expressiveness.</p>
<div id="toggle-expressiveness-table" class="button">
<span>Click here to show/hide the table for frameworks</span>
</div>
<div id="expressiveness-table">
<table>
<thead>
<tr class="header">
<th align="left">Cluster</th>
<th align="left">Language</th>
<th align="left">Framework</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Excellent</td>
<td align="left">Clj</td>
<td align="left">luminus</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">http-kit</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">compojure</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Hkl</td>
<td align="left">snap</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Hkl</td>
<td align="left">yesod</td>
</tr>
<tr class="even">
<td align="left">Very Good</td>
<td align="left">Erl</td>
<td align="left">elli</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Erl</td>
<td align="left">cowboy</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">go</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">revel</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Grv</td>
<td align="left">grails</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">lift</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">finagle</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">scalatra</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">play-scala</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">play-slick</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">unfiltered</td>
</tr>
<tr class="odd">
<td align="left">Medium</td>
<td align="left">Prl</td>
<td align="left">kelp</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">plack</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">dancer</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">web-simple</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">mojolicious</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">flask</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">django</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">tornado</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Rby</td>
<td align="left">rails</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Rby</td>
<td align="left">sinatra</td>
</tr>
<tr class="odd">
<td align="left">Bad</td>
<td align="left">C#</td>
<td align="left">nancy</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">aspnet-mvc</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">servicestack</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C++</td>
<td align="left">cpoll-pool</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C++</td>
<td align="left">cpoll-cppsp</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Dar</td>
<td align="left">dart</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play1</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">vertx</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">gemini</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">spring</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">wicket</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">servlet</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">tapestry</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play-java</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">dropwizard</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">rest-express</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play-java-jpa</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">grizzly-jersey</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Lua</td>
<td align="left">openresty</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">php</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">yaf</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">cake</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">fuel</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">slim</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">silex</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">kohana</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">laravel</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">lithium</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">phalcon</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">phreeze</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">micromvc</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">symfony2</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">codeigniter</td>
</tr>
<tr class="even">
<td align="left">Very Bad</td>
<td align="left">C</td>
<td align="left">onion</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">hapi</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">ringo</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">nodejs</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">express</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">ringo-conv</td>
</tr>
</tbody>
</table>
</div>
<h3 id="robustness">Robustness</h3>
<p>I couldn’t find any complete study to give the number of bug relatively to each framework/language.</p>
<p>But one thing I saw from experience is the more powerful the type system the safest your application is. While the type system doesn’t remove completely the need to test your application a very good type system tend to remove complete classes of bug.</p>
<p>Typically, not using pointer help to reduce the number of bugs due to bad references. Also, using a garbage collector, reduce greatly the probability to access unallocated space.</p>
<figure>
<img src="/Scratch/img/blog/Rational-Web-Framework-Choice/languagesafety.png" alt="Static Type Properties from [James IRY Blog][typesanalysis]"/>
<figcaption>
Static Type Properties from <a href="http://james-iry.blogspot.fr/2010/05/types-la-chart.html">James IRY Blog</a>
</figcaption>
</figure>

<p>From my point of view, robustness is mostly identical to safety.</p>
<p>Here are the clusters:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">Excellent</td>
<td align="left">Haskell, Scheme, Erlang</td>
</tr>
<tr class="even">
<td align="left">Very Good</td>
<td align="left">Scala, Java, Clojure</td>
</tr>
<tr class="odd">
<td align="left">Good</td>
<td align="left">Ruby, Python, Groovy, javascript, PHP</td>
</tr>
<tr class="even">
<td align="left">Medium</td>
<td align="left">C++, C#, Perl, Objective-C, Go, C</td>
</tr>
</tbody>
</table>
<p>So applying this to frameworks gives the following clusters:</p>
<div id="toggle-robustness-table" class="button">
<span>Click here to show/hide the table for frameworks</span>
</div>
<div id="robustness-table">
<table>
<thead>
<tr class="header">
<th align="left">Cluster</th>
<th align="left">Language</th>
<th align="left">Framework</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Excellent</td>
<td align="left">Erl</td>
<td align="left">elli</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Erl</td>
<td align="left">cowboy</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Hkl</td>
<td align="left">snap</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Hkl</td>
<td align="left">yesod</td>
</tr>
<tr class="odd">
<td align="left">Very Good</td>
<td align="left">Clj</td>
<td align="left">luminus</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">http-kit</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Clj</td>
<td align="left">compojure</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play1</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">vertx</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">gemini</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">spring</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">wicket</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">servlet</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">tapestry</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play-java</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">dropwizard</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">rest-express</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">play-java-jpa</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Jav</td>
<td align="left">grizzly-jersey</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">lift</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">finagle</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">scalatra</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">play-scala</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">play-slick</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Sca</td>
<td align="left">unfiltered</td>
</tr>
<tr class="even">
<td align="left">Good</td>
<td align="left">Grv</td>
<td align="left">grails</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">hapi</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">ringo</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">nodejs</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">express</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">JS</td>
<td align="left">ringo-conv</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Lua</td>
<td align="left">openresty</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">php</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">yaf</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">cake</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">fuel</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">slim</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">silex</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">kohana</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">laravel</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">lithium</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">phalcon</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">phreeze</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">micromvc</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">symfony2</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">PHP</td>
<td align="left">codeigniter</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">flask</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">django</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Py</td>
<td align="left">tornado</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Rby</td>
<td align="left">rails</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Rby</td>
<td align="left">sinatra</td>
</tr>
<tr class="even">
<td align="left">Medium</td>
<td align="left">C</td>
<td align="left">onion</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">nancy</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">aspnet-mvc</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C#</td>
<td align="left">servicestack</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">C++</td>
<td align="left">cpoll-pool</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">C++</td>
<td align="left">cpoll-cppsp</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Dar</td>
<td align="left">dart</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">go</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Go</td>
<td align="left">revel</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">kelp</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">plack</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">dancer</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">web-simple</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Prl</td>
<td align="left">mojolicious</td>
</tr>
</tbody>
</table>
</div>
<h2 id="the-result">The result</h2>
<p>For the result I initialized the table with my own needs.</p>
<p>And I am quite happy it confirms my current choice. I sware I didn’t given yesod any bonus point. I tried to be the most objective and factual as possible.</p>
<p>Now, it is up to you to enter your preferences.</p>
<p>On each line you could change how important a feature is for you. From essential to unsignificant. Of course you could change the matrix at will.</p>
<p>I just show a top 10 frameworks. In order to give a more understandable measure I provide the log of the score.</p>
<table id="choice-matrix">
<tr>
    <th></th>
    <th>
Excellent
</th>
    <th>
Very good
</th>
    <th>
Good
</th>
    <th>
Medium
</th>
    <th>
Bad
</th>
    <th>
Very bad
</th>
    <th>
Importance
</th>
</tr>
<tr id="t-expressiveness"><th>
Expressiveness
</th></tr>
<tr id="t-popularity"><th>
Popularity
</th></tr>
<tr id="t-efficiency"><th>
Efficiency
</th></tr>
<tr id="t-robustness"><th>
Robustness
</th></tr>
</table>

<div id="compute" class="button">
<span>Click to force refresh</span>
</div>
<div id="result">

</div>
<script>// <![CDATA[ // <![CDATA[
    function lt(x,y){return (x < y);}
    function bal(balname,str){return '<'+balname+'>'+str+'</'+balname+'>';}
    function ret(){return '<br/>';}
// ]]> // ]]></script>
<script>// <![CDATA[
    String.prototype.repeat = function(num){return new Array(num+1).join(this);};
    (function(){function run(){if (window.$){

     var languageOf={};
languageOf["elli"]="Erlang";
languageOf["cowboy"]="Erlang";
languageOf["snap"]="Haskell";
languageOf["yesod"]="Haskell";
languageOf["luminus"]="Clojure";
languageOf["http-kit"]="Clojure";
languageOf["compojure"]="Clojure";
languageOf["play1"]="Java";
languageOf["vertx"]="Java";
languageOf["gemini"]="Java";
languageOf["spring"]="Java";
languageOf["wicket"]="Java";
languageOf["servlet"]="Java";
languageOf["tapestry"]="Java";
languageOf["play-java"]="Java";
languageOf["dropwizard"]="Java";
languageOf["rest-express"]="Java";
languageOf["play-java-jpa"]="Java";
languageOf["grizzly-jersey"]="Java";
languageOf["lift"]="Scala";
languageOf["finagle"]="Scala";
languageOf["scalatra"]="Scala";
languageOf["play-scala"]="Scala";
languageOf["play-slick"]="Scala";
languageOf["unfiltered"]="Scala";
languageOf["grails"]="Groovy";
languageOf["hapi"]="javascript";
languageOf["ringo"]="javascript";
languageOf["nodejs"]="javascript";
languageOf["express"]="javascript";
languageOf["ringo-conv"]="javascript";
languageOf["openresty"]="Lua";
languageOf["php"]="PHP";
languageOf["yaf"]="PHP";
languageOf["cake"]="PHP";
languageOf["fuel"]="PHP";
languageOf["slim"]="PHP";
languageOf["silex"]="PHP";
languageOf["kohana"]="PHP";
languageOf["laravel"]="PHP";
languageOf["lithium"]="PHP";
languageOf["phalcon"]="PHP";
languageOf["phreeze"]="PHP";
languageOf["micromvc"]="PHP";
languageOf["symfony2"]="PHP";
languageOf["codeigniter"]="PHP";
languageOf["flask"]="Python";
languageOf["django"]="Python";
languageOf["tornado"]="Python";
languageOf["rails"]="Ruby";
languageOf["sinatra"]="Ruby";
languageOf["onion"]="C";
languageOf["nancy"]="C#";
languageOf["aspnet-mvc"]="C#";
languageOf["servicestack"]="C#";
languageOf["cpoll-pool"]="C++";
languageOf["cpoll-cppsp"]="C++";
languageOf["dart"]="Dart";
languageOf["go"]=" Go";
languageOf["revel"]=" Go";
languageOf["kelp"]="Perl";
languageOf["plack"]="Perl";
languageOf["dancer"]="Perl";
languageOf["web-simple"]="Perl";
languageOf["mojolicious"]="Perl";


popularityClusters=[[ "rails", "php"
],[ "django" , "servlet" , "spring" , "nodejs" , "codeigniter" , "grails"
],[ "sinatra" , "flask" , "laravel" , "kohana" , "rest-express", "express"
],[ "cake" , "servicestack" , "play-java", "play-slick"
, "wicket" , "dart" , "slim" , "tornado" , "lift" , "go"
],[ "tapestry" , "aspnet-mvc" , "yesod" , "silex" , "lithium" , "nancy"
],[ "grizzly" , "cowboy" , "dancer" , "symfony2" , "revel"
, "compojure" , "mojolicious" , "scalatra" , "finagle" , "phalcon"
, "ringo" , "gemini" , "snap" , "plack" , "elli" , "dropwizard"
, "yaf" , "play1" , "hapi" , "vertx" , "unfiltered" , "onion"
, "http-kit" , "kelp" , "micromvc" , "openresty" , "cpoll-pool"
,  "cpoll-cppsp" , "luminus" , "phreeze"
]];


efficiencyClusters=[[ "cpoll-cppsp" , "gemini" , "openresty" , "servlet"
, "cpoll-pool" , "go" , "finagle" , "revel" , "rest-express"
],[ "wicket" , "scalatra" , "http-kit" , "spring" , "php" , "tapestry"
, "compojure" , "ringo" , "dropwizard" , "luminus"
],[ "play-slick" , "unfiltered" , "elli" , "vertx" , "nodejs" , "cowboy"
, "onion" , "yesod" , "express" , "play-scala" , "grizzly"
, "tornado" , "phalcon" , "grails" , "plack" , "yaf"
],[ "hapi" , "play1" , "snap" , "kelp" , "flask" , "play-java"
, "play-java-jpa" , "micromvc" , "dancer" , "mojolicious" , "ringo-conv"
, "django" , "codeigniter"
],[ "rails" , "lift" , "slim" , "kohana" , "silex"
],[ "laravel" , "phreeze" , "lithium" , "fuel" , "cake" , "symfony2"
, "aspnet-mvc" , "sinatra" , "servicestack" , "dart" , "nancy" , "web-simple"
]];


expressivenessClusters=[[
"luminus" , "http-kit" , "compojure" , "snap" , "yesod"
],[ "elli" , "cowboy" , "go" , "revel" , "grails" , "lift" , "finagle"
, "scalatra" , "play-scala" , "play-slick" , "unfiltered"
],[ "kelp" , "plack" , "dancer" , "web-simple" , "mojolicious" , "flask"
, "django" , "tornado" , "rails" , "sinatra"
],[ "nancy" , "aspnet-mvc" , "servicestack" , "cpoll-pool" , "cpoll-cppsp"
, "dart" , "play1" , "vertx" , "gemini" , "spring" , "wicket" , "servlet"
, "tapestry" , "play-java" , "dropwizard" , "rest-express" , "play-java-jpa"
, "grizzly" , "openresty" , "php" , "yaf" , "cake" , "fuel" , "slim"
, "silex" , "kohana" , "laravel" , "lithium" , "phalcon" , "phreeze"
, "micromvc" , "symfony2" , "codeigniter"
],[ "onion" , "hapi" , "ringo" , "nodejs" , "express" , "ringo-conv"
]];

robustnessClusters=[[ "elli" , "cowboy" , "snap" , "yesod"
],[ "luminus" , "http-kit" , "compojure" , "play1" , "vertx" , "gemini"
, "spring" , "wicket" , "servlet" , "tapestry" , "play-java" , "dropwizard"
, "rest-express" , "play-java-jpa" , "grizzly" , "lift" , "finagle"
, "scalatra" , "play-scala" , "play-slick" , "unfiltered"
],[ "grails" , "hapi" , "ringo" , "nodejs" , "express" , "ringo-conv"
, "openresty" , "php" , "yaf" , "cake" , "fuel" , "slim" , "silex"
, "kohana" , "laravel" , "lithium" , "phalcon" , "phreeze" , "micromvc"
, "symfony2" , "codeigniter" , "flask" , "django" , "tornado" , "rails"
, "sinatra"
],[ "onion" , "nancy" , "aspnet-mvc" , "servicestack" , "cpoll-pool"
, "cpoll-cppsp" , "dart" , "go" , "revel" , "kelp" , "plack"
, "dancer" , "web-simple" , "mojolicious"
],[
],[
]];

        // var essentialVector=[10000,100,1,0,0,0];
        // var importantVector=[1024,256,64,16,4,1];
        // var normalVector=[32,16,8,4,2,1];
        // var somehowVector=[10,8,6,4,2,1];
        // var whateverVector=[1,1,1,1,1,1];

        var ninfty=Number.NEGATIVE_INFINITY;
        var essentialVector=[11,7,0,-1000,-1000,-1000];
        var importantVector=[10,8,6,4,2,0];
        var normalVector=[5,4,3,2,1,0];
        var somehowVector=[2,2,1,1,0,0];
        var whateverVector=[0,0,0,0,0,0];

        var framework=[];

        for (var i=0;lt(i,efficiencyClusters.length);i++) {
            for (var j=0;lt(j,efficiencyClusters[i].length);j++) {
                framework[efficiencyClusters[i][j]]={};
            }
        }
        $(["efficiency"
          ,"popularity"
          ,"expressiveness"
          ,"robustness"]).each(function(){
            var tab;
            eval("tab = "+this+"Clusters;");
            for (var i=0;lt(i,tab.length);i++) {
                for (var j=0;lt(j,tab[i].length);j++) {
                    eval("framework[tab[i][j]]."+this+"= i;");
                }
            }
          });

        function setLine(name,vector) {
            $('#' + name+' td input').each(function(i){
                var len = vector.length;
                if (lt(i,len)) {
                    $(this).val(vector[i]); }});}
        $(['t-expressiveness'
          ,'t-popularity'
          ,'t-efficiency'
          ,'t-robustness']).each(function(){
                    var name='#'+this;
                    var tdinput=$('<td align="right"><input style="display: inline-block;width:3.2em;text-align:right" type="text"></input></td>'.repeat(6));
                    $(name).append(tdinput);
                    $(name).append($('<td>'+
                        '<select style="width:6em" id="s-'+this+'">' +
                        '<option value="essential">Essential</option>' +
                        '<option value="important">Important</option>' +
                        '<option value="normal" selected="t">Normal</option>' +
                        '<option value="somehow">Somehow</option>' +
                        '<option value="whatever">Unsignificant</option>' +
                        '</select>' +
                        '</td>' ));
                    if (this == "t-expressiveness") {
                        setLine(this,essentialVector);
                        $(name+' select').val("essential");
                    } else if (this == "t-popularity") {
                        setLine(this,normalVector);
                        $(name+' select').val("normal");
                    } else if (this == "t-efficiency") {
                        setLine(this,importantVector);
                        $(name+' select').val("important");
                    } else if (this == "t-robustness") {
                        setLine(this,importantVector);
                        $(name+' select').val("important");
                    }
                    var strthis=''+this;
                    $("#s-"+this).change(function(){
                            var val=$("#s-"+strthis+" option:selected").val();
                            var tab;
                            eval('tab='+val+'Vector');
                            setLine(strthis,tab);
                            updateResult();
                        });
                });
        function updateResult(){
            var scoreMatrix=[[0,0,0,0,0,0]
                            ,[0,0,0,0,0,0]
                            ,[0,0,0,0,0,0]
                            ,[0,0,0,0,0,0]
                            ];
            $(['t-expressiveness'
              ,'t-popularity'
              ,'t-efficiency'
              ,'t-robustness']).each(function(i){
                $("#"+this+" td input").each(function(j){
                    scoreMatrix[i][j]=$(this).val(); }) });
            var result=[];
            for (key in framework) {
                framework[key].score =
                    parseInt(scoreMatrix[0][framework[key].expressiveness]) +
                    parseInt(scoreMatrix[1][framework[key].popularity]) +
                    parseInt(scoreMatrix[2][framework[key].efficiency]) +
                    parseInt(scoreMatrix[3][framework[key].robustness]);
                result.push([key,framework[key].score]);
            }
            result.sort(function(a,b){return b[1] - a[1];});
            var winners=[];
            var i=0;
            var maxscore=result[0][1];
            while ((lt(i,result.length)) && (result[i][1]==maxscore)){
                winners.push(result[i]);
                i+=1;
            }
            if (winners.length == 1) {
                $('#result').html('<'+'p style="text-align: center">And the winner is<'+'br/><'+'strong>'+result[0][0]+'<'+'/strong> ('+languageOf[result[0][0]]+')<'+'/p><'+'table><'+'tr><'+'th>position<'+'/th><'+'th>framework<'+'/th><'+'th>language<'+'/th><'+'th align="right">score<'+'/th><'+'/tr><'+'/table>');
            } else {
                var listwinners=new String;
                for (i=0;lt(i,winners.length);i++){
                    listwinners=listwinners+bal('strong', winners[i][0] ) + " ("+languageOf[winners[i][0]]+")"+ret();}
                $('#result').html('<'+'p style="text-align: center">And the winners are<'+'br/>' + listwinners + '<'+'table><'+'tr><'+'th>position<'+'/th><'+'th>framework<'+'/th><'+'th>language<'+'/th><'+'th align="right">score<'+'/th><'+'/tr><'+'/table>');
            }
            for (k=0;lt(k,10);k++){
                $('#result table').append('<'+'tr><'+'td>'+(k+1)+'<'+'/td><'+'td>'+result[k][0]+'<'+'/td><'+'td>'+languageOf[result[k][0]]+'<'+'/td><'+'td><'+'code>'+result[k][1]+'<'+'/code><'+'/td><'+'/tr>');
            }
        }
        $('#compute').click(updateResult);
        $("#choice-matrix input[type='text']").change(updateResult);
        $("#choice-matrix input[type='text']").keyup(updateResult);
        updateResult();

        // Show hide tables in the article
        $('#toggle-expressiveness-table').click(function(){
                                        $('#expressiveness-table').toggle();
                                        });
        $('#toggle-robustness-table').click(function(){
                                        $('#robustness-table').toggle();
                                        });
        $('#expressiveness-table').toggle();
        $('#robustness-table').toggle();

    } else {
        setTimeout(run,50);
    }
        }
        run();
    })();
// ]]></script>

<p>I didn’t had the courage in explaining in what the scoring system is good. Mostly, if you use product instead of sum for the score you could use power of <span class="math"><em>e</em></span> for the values in the matrix. And you could see the matrix as a probability matrix (each line sum to 1). Which provide a slighly better intuition on whats going on.</p>
<p>Remember only that values are exponential. Do not double an already big value for example the effect would be extreme.</p>
<h2 id="conclusion">Conclusion</h2>
<p>All of this is based as most as I could on objective data. The choice method seems both rather rational and classical. It is now up to you to edit the score matrix to set your needs.</p>
<p>I know that in the current state there are many flaws. But it is a first system to help make a choice rationally.</p>
<p>I encourage you to go further if you are not satisfied by my method.</p>
<p>The source code for the matrix shouldn’t be too hard to read. Just read the source of this webpage. You could change the positionning of some frameworks if you believe I made some mistake by placing them in some bad clusters.</p>
<p>So I hope this tool will help you in making your life easier.</p>]]></summary>
</entry>
<entry>
    <title>Hakyll setup</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Hakyll-setup/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Hakyll-setup/index.html</id>
    <published>2013-03-16T00:00:00Z</published>
    <updated>2013-03-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Hakyll-setup/main.png" alt="Main image"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Comment j’utilise <a href="http://jaspervdj.be/hakyll">hakyll</a>. Abréviations, corrections typographiques, multi-language, utilisation d’<code>index.html</code>, etc…</p>
</div>
<p>Ce site web est fait avec <a href="http://jaspervdj.be/hakyll">Hakyll</a>.</p>
<p><a href="http://jaspervdj.be/hakyll">Hakyll</a> peut être vu comme un <span class="sc"><abbr title="Content Management System">cms</abbr></span> minimaliste. D’une façon plus générale, il s’agit d’une bibliothèque qui facilite la création automatique de fichiers.</p>
<p>D’un point de vue utilisateur voici comment j’écris mes articles&nbsp;:</p>
<ol style="list-style-type: decimal">
<li>J’ouvre un éditeur de texte (vim dans mon cas). J’édite un fichier markdow qui ressemble à ça :</li>
</ol>
<pre class="sourceCode markdown"><code class="sourceCode markdown">Un titre de page
================

Un titre de chapitre
--------------------

Azur, nos bêtes sont bondées d&#39;un cri.
Je m&#39;éveille songeant au fruit noir de l&#39;anibe dans sa cupule
véruqueuse et tronquée.

Saint John Perse.

<span class="fu">### Titre 3</span>

&gt;<span class="dt"> C&#39;est un blockquote.</span>
&gt;
&gt;<span class="dt"> C&#39;est un second paragraphe dans le blockquote</span>
&gt;
&gt;<span class="dt"> ## C&#39;est un H2 dans un blockquote</span></code></pre>
<ol start="2" style="list-style-type: decimal">
<li>J’ouvre mon navigateur et je rafraichis de temps en temps pour voir les changements.</li>
<li>Une fois satisfait, je lance un script minimal qui fait grosso modo un simple <code>git push</code>. Mon blog est hébergé sur <a href="http://github.com">github</a>.</li>
</ol>
<p>A ne pas y regarder de trop près, on peut réduire le rôle d’Hakyll à&nbsp;:</p>
<blockquote>
<p>Créer (resp. mettre à jour) un fichier <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> lorsque je crée (resp. modifie) un fichier markdown.</p>
</blockquote>
<p>Bien que cela semble facile, il y a de nombreux détails cachés&nbsp;:</p>
<ul>
<li>Ajouter des métadatas comme des mots clés</li>
<li>Créer un page archive qui contient la liste de tous les articles</li>
<li>Gérer les fichier statiques</li>
<li>Créer un flux <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span></li>
<li>Filtrer le contenu</li>
<li>Gérer les dépendances</li>
</ul>
<p>Le travail d’Hakyll est de vous aider avec tout ça. Commençons par expliquer les concepts basiques.</p>
<h2 id="les-concepts-et-la-syntaxe">Les concepts et la syntaxe</h2>
<div>
<img src="/Scratch/img/blog/Hakyll-setup/overview.png" alt="Overview"/>
</div>
<p>Pour chaque fichier que vous créer, il faut fournir&nbsp;:</p>
<ul>
<li>un chemin de destination</li>
<li>une liste de filtres du contenu</li>
</ul>
<p>Commençons par le cas le plus simple ; les fichiers statiques (images, fontes, etc…) Généralement, vous avec un répertoire source (ici le répertoire courant) et une répertoire destination <code>_site</code>.</p>
<p>Le code Hakyll est&nbsp;:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- pour chaque fichier dans le répertoire static</span>
match <span class="st">&quot;static/*&quot;</span> <span class="kw">do</span>
  <span class="co">-- on ne change pas le nom ni le répertoire</span>
  route   idRoute
  <span class="co">-- on ne modifie pas le contenu</span>
  compile copyFileCompiler</code></pre>
<p>Ce programme va copier <code>static/foo.jpg</code> dans <code>_site/static/foo.jpg</code>. C’est un peu lourd pour un simple <code>cp</code>. Maintenant comment faire pour transformer automatiquement un fichier markdown dans le bon <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- pour chaque fichier avec un extension md</span>
match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  <span class="co">-- changer son extension en html</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  <span class="co">-- utiliser la librairie pandoc pour compiler le markdown en html</span>
  compile <span class="fu">$</span> pandocCompiler</code></pre>
<p>Si vous créez un fichier <code>posts/toto.md</code>, cela créera un fichier <code>_site/posts/toto.html</code>.</p>
<p>Si le fichier <code>posts/foo.md</code> contient</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="fu"># Cthulhu</span>

ph&#39;nglui mglw&#39;nafh Cthulhu R&#39;lyeh wgah&#39;nagl fhtagn</code></pre>
<p>le fichier <code>_site/posts/foo.html</code>, contiendra</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>Cthulhu<span class="kw">&lt;/h1&gt;</span>
<span class="kw">&lt;p&gt;</span>ph&#39;nglui mglw&#39;nafh Cthulhu R&#39;lyeh wgah&#39;nagl fhtagn<span class="kw">&lt;/p&gt;</span></code></pre>
<p>Mais horreur ! <code>_site/posts/cthulhu.html</code> n’est pas un <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> complet. Il ne possède ni header, ni footer, etc… C’est ici que nous utilisons des templates. J’ajoute une nouvelle directive dans le bloc “compile”.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- use the template with the current content</span>
    <span class="highlight"><span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> defaultContext</span></code></pre>
<p>Maintenant si <code>templates/posts.html</code> contient:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span>How could I get the title?<span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="highlight">$body$</span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>Maintenant notre <code>ctuhlhu.html</code> contient</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span>How could I get the title?<span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="highlight"><span class="kw">&lt;h1&gt;</span>Cthulhu<span class="kw">&lt;/h1&gt;</span></span>
    <span class="highlight"><span class="kw">&lt;p&gt;</span>ph&#39;nglui mglw&#39;nafh Cthulhu R&#39;lyeh wgah&#39;nagl fhtagn<span class="kw">&lt;/p&gt;</span></span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>C’est facile. Mais il reste un problème à résoudre. Comment pouvons-nous changer le titre ? Ou par exemple, ajouter des mots clés ?</p>
<p>La solution est d’utiliser les <code>Context</code>s. Pour cela, nous devrons ajouter des <em>metadonnées</em> à notre markdown<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="highlight">--- </span>
<span class="highlight">title: Cthulhu</span>
<span class="highlight">--- </span>
<span class="fu"># Cthulhu</span>

ph&#39;nglui mglw&#39;nafh Cthulhu R&#39;lyeh wgah&#39;nagl fhtagn</code></pre>
<p>Et modifier légèrement notre template&nbsp;:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span><span class="highlight">$title$</span><span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    $body$
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre>
<p>Super facile!</p>
<p>La suite de l’article est en Anglais. Je la traduirai volontier si suffisamment de personnes me le demande gentillement.</p>
<h2 id="real-customization">Real customization</h2>
<p>Now that we understand the basic functionality. How to:</p>
<ul>
<li>use SASS?</li>
<li>add keywords?</li>
<li>simplify <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>?</li>
<li>create an archive page?</li>
<li>create an <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> feed?</li>
<li>filter the content?</li>
<li>add abbreviations support?</li>
<li>manage two languages?</li>
</ul>
<h3 id="use-sass">Use SASS</h3>
<p>That’s easy. Simply call the executable using <code>unixFilter</code>. Of course you’ll have to install SASS (<code>gem install sass</code>). And we also use compressCss to gain some space.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;css/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    route   <span class="fu">$</span> setExtension <span class="st">&quot;css&quot;</span>
    compile <span class="fu">$</span> getResourceString <span class="fu">&gt;&gt;=</span>
              withItemBody (unixFilter <span class="st">&quot;sass&quot;</span> [<span class="st">&quot;--trace&quot;</span>]) <span class="fu">&gt;&gt;=</span>
              return <span class="fu">.</span> fmap compressCss</code></pre>
<h3 id="add-keywords">Add keywords</h3>
<p>In order to help to reference your website on the web, it is nice to add some keywords as meta datas to your <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> page.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;meta</span><span class="ot"> name=</span><span class="st">&quot;keywords&quot;</span>
<span class="ot">      content=</span><span class="st">&quot;Cthulhu, Yog-Sothoth, Shub-Niggurath&quot;</span><span class="kw">&gt;</span></code></pre>
<p>In order to add keywords, we could not directly use the markdown metadatas. Because, without any, there should be any meta tag in the <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>.</p>
<p>An easy answer is to create a <code>Context</code> that will contains the meta tag.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- metaKeywordContext will return a Context containing a String</span>
<span class="ot">metaKeywordContext ::</span> <span class="dt">Context</span> <span class="dt">String</span>
<span class="co">-- can be reached using $metaKeywords$ in the templates</span>
<span class="co">-- Use the current item (markdown file)</span>
metaKeywordContext <span class="fu">=</span> field <span class="st">&quot;metaKeywords&quot;</span> <span class="fu">$</span> \item <span class="ot">-&gt;</span> <span class="kw">do</span>
  <span class="co">-- tags contains the content of the &quot;tags&quot; metadata</span>
  <span class="co">-- inside the item (understand the source)</span>
  tags <span class="ot">&lt;-</span> getMetadataField (itemIdentifier item) <span class="st">&quot;tags&quot;</span>
  <span class="co">-- if tags is empty return an empty string</span>
  <span class="co">-- in the other case return</span>
  <span class="co">--   &lt;meta name=&quot;keywords&quot; content=&quot;$tags$&quot;&gt;</span>
  return <span class="fu">$</span> maybe <span class="st">&quot;&quot;</span> showMetaTags tags
    <span class="kw">where</span>
      showMetaTags t <span class="fu">=</span> <span class="st">&quot;&lt;meta name=\&quot;keywords\&quot; content=\&quot;&quot;</span>
                       <span class="fu">++</span> t <span class="fu">++</span> <span class="st">&quot;\&quot;&gt;\n&quot;</span></code></pre>
<p>Then we pass this <code>Context</code> to the <code>loadAndApplyTemplate</code> function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- use the template with the current content</span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>
            (defaultContext <span class="highlight"><span class="fu">&lt;&gt;</span> metaKeywordContext</span>)</code></pre>
<blockquote>
<p>☞ Here are the imports I use for this tutorial.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import           </span><span class="dt">Control.Monad</span>          (forM,forM_)
<span class="kw">import           </span><span class="dt">Data.List</span>              (sortBy,isInfixOf)
<span class="kw">import           </span><span class="dt">Data.Monoid</span>            ((&lt;&gt;),mconcat)
<span class="kw">import           </span><span class="dt">Data.Ord</span>               (comparing)
<span class="kw">import           </span><span class="dt">Hakyll</span>
<span class="kw">import           </span><span class="dt">System.Locale</span>          (defaultTimeLocale)
<span class="kw">import           </span><span class="dt">System.FilePath.Posix</span>  (takeBaseName,takeDirectory
                                         ,(<span class="fu">&lt;/&gt;</span>),splitFileName)</code></pre>
</blockquote>
<h3 id="simplify-url">Simplify <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span></h3>
<p>What I mean is to use url of the form:</p>
<pre><code>http://domain.name/post/title-of-the-post/</code></pre>
<p>I prefer this than having to add file with <code>.html</code> extension. We have to change the default Hakyll route behavior. We create another function <code>niceRoute</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- replace a foo/bar.md by foo/bar/index.html</span>
<span class="co">-- this way the url looks like: foo/bar in most browsers</span>
<span class="ot">niceRoute ::</span> <span class="dt">Routes</span>
niceRoute <span class="fu">=</span> customRoute createIndexRoute
  <span class="kw">where</span>
    createIndexRoute ident <span class="fu">=</span>
        takeDirectory p <span class="fu">&lt;/&gt;</span> takeBaseName p <span class="fu">&lt;/&gt;</span> <span class="st">&quot;index.html&quot;</span>
    <span class="kw">where</span> p<span class="fu">=</span>toFilePath ident</code></pre>
<p>Not too difficult. But! There might be a problem. What if there is a <code>foo/index.html</code> link instead of a clean <code>foo/</code> in some content?</p>
<p>Very simple, we simply remove all <code>/index.html</code> to all our links.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- replace url of the form foo/bar/index.html by foo/bar</span>
<span class="ot">removeIndexHtml ::</span> <span class="dt">Item</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Compiler</span> (<span class="dt">Item</span> <span class="dt">String</span>)
removeIndexHtml item <span class="fu">=</span> return <span class="fu">$</span> fmap (withUrls removeIndexStr) item
  <span class="kw">where</span>
<span class="ot">    removeIndexStr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
    removeIndexStr url <span class="fu">=</span> <span class="kw">case</span> splitFileName url <span class="kw">of</span>
        (dir, <span class="st">&quot;index.html&quot;</span>) <span class="fu">|</span> isLocal dir <span class="ot">-&gt;</span> dir
        _                                 <span class="ot">-&gt;</span> dir
        <span class="kw">where</span> islocal uri <span class="fu">=</span> not (isInfixOf <span class="st">&quot;://&quot;</span> uri)</code></pre>
<p>And we apply this filter at the end of our compilation</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  <span class="highlight">route <span class="fu">$</span> niceRoute</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- use the template with the current content</span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> defaultContext
    <span class="highlight"><span class="fu">&gt;&gt;=</span> removeIndexStr</span></code></pre>
<h3 id="create-an-archive-page">Create an archive page</h3>
<p>Creating an archive start to be difficult. There is an example in the default Hakyll example. Unfortunately, it assumes all posts prefix their name with a date like in <code>2013-03-20-My-New-Post.md</code>.</p>
<p>I migrated from an older blog and didn’t want to change my <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>. Also I prefer not to use any filename convention. Therefore, I add the date information in the metadata <code>published</code>. And the solution is here:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;archive.md&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
  route <span class="fu">$</span> niceRoute
  compile <span class="fu">$</span> <span class="kw">do</span>
    body <span class="ot">&lt;-</span> getResourceBody
    return <span class="fu">$</span> renderPandoc body
      <span class="highlight"><span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/archive.html&quot;</span> archiveCtx</span>
      <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="highlight"><span class="st">&quot;templates/base.html&quot;</span></span> defaultContext
      <span class="fu">&gt;&gt;=</span> removeIndexHtml</code></pre>
<p>Where <code>templates/archive.html</code> contains</p>
<pre class="sourceCode html"><code class="sourceCode html">$body$

<span class="kw">&lt;ul&gt;</span>
    $posts$
<span class="kw">&lt;/ul&gt;</span></code></pre>
<p>And <code>base.html</code> is a standard template (simpler than <code>post.html</code>).</p>
<p><code>archiveCtx</code> provide a context containing an <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> representation of a list of posts in the metadata named <code>posts</code>. It will be used in the <code>templates/archive.html</code> file with <code>$posts$</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">archiveCtx <span class="fu">=</span>
  defaultContext <span class="fu">&lt;&gt;</span>
  metaKeywordContext <span class="fu">&lt;&gt;</span>
  <span class="highlight">field <span class="st">&quot;posts&quot;</span> (\_ <span class="ot">-&gt;</span> postList createdFirst)</span></code></pre>
<p><code>postList</code> returns an <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> representation of a list of posts given an Item sort function. The representation will apply a minimal template on all posts. Then it concatenate all the results. The template is <code>post-item.html</code>:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;li&gt;&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$url$&quot;</span><span class="kw">&gt;</span>$published$ - $title$<span class="kw">&lt;/a&gt;&lt;/li&gt;</span></code></pre>
<p>Here is how it is done:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postList ::</span> [<span class="dt">Item</span> <span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Compiler</span> [<span class="dt">Item</span> <span class="dt">String</span>]
            <span class="ot">-&gt;</span> <span class="dt">Compiler</span> <span class="dt">String</span>
postList sortFilter <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- sorted posts</span>
    posts   <span class="ot">&lt;-</span> loadAll <span class="st">&quot;post/*&quot;</span> <span class="fu">&gt;&gt;=</span> sortFilter
    itemTpl <span class="ot">&lt;-</span> loadBody <span class="st">&quot;templates/post-item.html&quot;</span>
    <span class="co">-- we apply the template to all post</span>
    <span class="co">-- and we concatenate the result.</span>
    <span class="co">-- list is a string</span>
    list    <span class="ot">&lt;-</span> applyTemplateList itemTpl defaultContext posts
    return list</code></pre>
<p><code>createdFirst</code> sort a list of item and put it inside <code>Compiler</code> context. We need to be in the <code>Compiler</code> context to access metadatas.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createdFirst ::</span> [<span class="dt">Item</span> <span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Compiler</span> [<span class="dt">Item</span> <span class="dt">String</span>]
createdFirst items <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- itemsWithTime is a list of couple (date,item)</span>
  itemsWithTime <span class="ot">&lt;-</span> forM items <span class="fu">$</span> \item <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="co">-- getItemUTC will look for the metadata &quot;published&quot; or &quot;date&quot;</span>
    <span class="co">-- then it will try to get the date from some standard formats</span>
    utc <span class="ot">&lt;-</span> getItemUTC defaultTimeLocale <span class="fu">$</span> itemIdentifier item
    return (utc,item)
  <span class="co">-- we return a sorted item list</span>
  return <span class="fu">$</span> map snd <span class="fu">$</span> reverse <span class="fu">$</span> sortBy (comparing fst) itemsWithTime</code></pre>
<p>It wasn’t so easy. But it works pretty well.</p>
<h3 id="create-an-rss-feed">Create an <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> feed</h3>
<p>To create an <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> feed, we have to:</p>
<ul>
<li>select only the lasts posts.</li>
<li>generate partially rendered posts (no css, js, etc…)</li>
</ul>
<p>We could then render the posts twice. One for <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> rendering and another time for <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span>. Remark we need to generate the <span class="sc"><abbr title="Rich Site Summary">rss</abbr></span> version to create the <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> one.</p>
<p>One of the great feature of Hakyll is to be able to save snapshots. Here is how:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*.md&quot;</span> <span class="kw">do</span>
  route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
  compile <span class="fu">$</span> pandocCompiler
    <span class="co">-- save a snapshot to be used later in rss generation</span>
    <span class="highlight"><span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span></span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span> defaultContext</code></pre>
<p>Now for each post there is a snapshot named “content” associated. The snapshots are created before applying a template and after applying pandoc. Furthermore feed don’t need a source markdown file. Then we create a new file from no one. Instead of using <code>match</code>, we use <code>create</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">create [<span class="st">&quot;feed.xml&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
      route idRoute
      compile <span class="fu">$</span> <span class="kw">do</span>
        <span class="co">-- load all &quot;content&quot; snapshots of all posts</span>
        loadAllSnapshots <span class="st">&quot;posts/*&quot;</span> <span class="st">&quot;content&quot;</span>
        <span class="co">-- take the latest 10</span>
        <span class="fu">&gt;&gt;=</span> (fmap (take <span class="dv">10</span>)) <span class="fu">.</span> createdFirst
        <span class="co">-- renderAntom feed using some configuration</span>
        <span class="fu">&gt;&gt;=</span> renderAtom feedConfiguration feedCtx
      <span class="kw">where</span>
<span class="ot">        feedCtx ::</span> <span class="dt">Context</span> <span class="dt">String</span>
        feedCtx <span class="fu">=</span>  defaultContext <span class="fu">&lt;&gt;</span>
                   <span class="co">-- $description$ will render as the post body</span>
                   <span class="highlight">bodyField <span class="st">&quot;description&quot;</span></span></code></pre>
<p>The <code>feedConfiguration</code> contains some general informations about the feed.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">feedConfiguration ::</span> <span class="dt">FeedConfiguration</span>
feedConfiguration <span class="fu">=</span> <span class="dt">FeedConfiguration</span>
  { feedTitle <span class="fu">=</span> <span class="st">&quot;Great Old Ones&quot;</span>
  , feedDescription <span class="fu">=</span> <span class="st">&quot;This feed provide information about Great Old Ones&quot;</span>
  , feedAuthorName <span class="fu">=</span> <span class="st">&quot;Abdul Alhazred&quot;</span>
  , feedAuthorEmail <span class="fu">=</span> <span class="st">&quot;abdul.alhazred@great-old-ones.com&quot;</span>
  , feedRoot <span class="fu">=</span> <span class="st">&quot;http://great-old-ones.com&quot;</span>
  }</code></pre>
<p>Great idea certainly steal from <a href="http://nanoc.ws">nanoc</a> (my previous blog engine)!</p>
<h3 id="filter-the-content">Filter the content</h3>
<p>As I just said, <a href="http://nanoc.ws">nanoc</a> was my preceding blog engine. It is written in Ruby and as Hakyll, it is quite awesome. And one thing Ruby does more naturally than Haskell is regular expressions. I had a <em>lot</em> of filters in nanoc. I lost some because I don’t use them much. But I wanted to keep some. Generally, filtering the content is just a way to apply to the body a function of type <code>String -&gt; String</code>.</p>
<p>Also we generally want prefilters (to filter the markdown) and postfilters (to filter the <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span> after the pandoc compilation).</p>
<p>Here is how I do it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">markdownPostBehavior <span class="fu">=</span> <span class="kw">do</span>
  route <span class="fu">$</span> niceRoute
  compile <span class="fu">$</span> <span class="kw">do</span>
    body <span class="ot">&lt;-</span> getResourceBody
    <span class="highlight">prefilteredText <span class="ot">&lt;-</span> return <span class="fu">$</span> (fmap preFilters body)</span>
    <span class="highlight">return <span class="fu">$</span> renderPandoc prefilteredText</span>
    <span class="highlight"><span class="fu">&gt;&gt;=</span> applyFilter postFilters</span>
    <span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span>
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    yContext
    <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/boilerplate.html&quot;</span> yContext
    <span class="fu">&gt;&gt;=</span> relativizeUrls
    <span class="fu">&gt;&gt;=</span> removeIndexHtml</code></pre>
<p>Where</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">applyFilter strfilter str <span class="fu">=</span> return <span class="fu">$</span> (fmap <span class="fu">$</span> strfilter) str
<span class="ot">preFilters ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">postFilters ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre>
<p>Now we have a simple way to filter the content. Let’s augment the markdown ability.</p>
<h3 id="add-abbreviations-support">Add abbreviations support</h3>
<p>Comparing to <span style="text-transform: uppercase">L<sup style="vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em">a</sup>T<sub style="vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em">e</sub>X</span>, a very annoying markdown limitation is the lack of abbreviations.</p>
<p>Fortunately we can filter our content. And here is the filter I use:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">abbreviationFilter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
abbreviationFilter <span class="fu">=</span> replaceAll <span class="st">&quot;%[a-zA-Z0-9_]*&quot;</span> newnaming
  <span class="kw">where</span>
    newnaming matched <span class="fu">=</span> <span class="kw">case</span> M.lookup (tail matched) abbreviations <span class="kw">of</span>
                          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> matched
                          <span class="dt">Just</span> v <span class="ot">-&gt;</span> v
<span class="ot">abbreviations ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">String</span>
abbreviations <span class="fu">=</span> M.fromList
    [ (<span class="st">&quot;html&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;html&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;css&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;css&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;svg&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;svg&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;xml&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;xml&lt;/span&gt;&quot;</span>)
    , (<span class="st">&quot;xslt&quot;</span>, <span class="st">&quot;&lt;span class=\&quot;sc\&quot;&gt;xslt&lt;/span&gt;&quot;</span>) ]</code></pre>
<p>It will search for all string starting by ‘%’ and it will search in the <code>Map</code> if there is a corresponding abbreviation. If there is one, we replace the content. Otherwise we do nothing.</p>
<p>Do you really believe I type</p>
<pre class="sourceCode html wrap"><code class="sourceCode html"><span class="kw">&lt;span</span><span class="ot"> style=</span><span class="st">&quot;text-transform: uppercase&quot;</span><span class="kw">&gt;</span>L<span class="kw">&lt;sup</span><span class="ot"> style=</span><span class="st">&quot;vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em&quot;</span><span class="kw">&gt;</span>a<span class="kw">&lt;/sup&gt;</span>T<span class="kw">&lt;sub</span><span class="ot"> style=</span><span class="st">&quot;vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em&quot;</span><span class="kw">&gt;</span>e<span class="kw">&lt;/sub&gt;</span>X<span class="kw">&lt;/span&gt;</span></code></pre>
<p>each time I write <span style="text-transform: uppercase">L<sup style="vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em">a</sup>T<sub style="vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em">e</sub>X</span>?</p>
<h3 id="manage-two-languages">Manage two languages</h3>
<p>Generally I write my post in English and French. And this is more difficult than it appears. For example, I need to filter the language in order to get the right list of posts. I also use some words in the templates and I want them to be translated.</p>
<p>A nice tip is to pass arguments to a context and use it in the template. Typically I write:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$otherLanguagePath$&quot;</span>
<span class="ot">	onclick=</span><span class="st">&quot;setLanguage(&#39;$otherlanguage$&#39;)&quot;</span><span class="kw">&gt;</span>
	<span class="highlight">$trad changeLanguage$</span> <span class="kw">&lt;/a&gt;</span></code></pre>
<p>First I create a Map containing all translations.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Trad</span> <span class="fu">=</span> <span class="dt">Trad</span> {<span class="ot"> frTrad ::</span> <span class="dt">String</span>,<span class="ot"> enTrad ::</span> <span class="dt">String</span> }

<span class="ot">trads ::</span> <span class="dt">Map</span> <span class="dt">String</span> <span class="dt">Trad</span>
trads <span class="fu">=</span> M.fromList <span class="fu">$</span> map toTrad [
   (<span class="st">&quot;changeLanguage&quot;</span>,
      (<span class="st">&quot;English&quot;</span>
      , <span class="st">&quot;Français&quot;</span>))
  ,(<span class="st">&quot;switchCss&quot;</span>,
      (<span class="st">&quot;Changer de theme&quot;</span>
      ,<span class="st">&quot;Change Theme&quot;</span>))
  ,(<span class="st">&quot;socialPrivacy&quot;</span>,
      (<span class="st">&quot;Ces liens sociaux préservent votre vie privée&quot;</span>
      ,<span class="st">&quot;These social sharing links preserve your privacy&quot;</span>))
  ]
  <span class="kw">where</span>
    toTrad (key,(french,english)) <span class="fu">=</span>
      (key, <span class="dt">Trad</span> { frTrad <span class="fu">=</span> french , enTrad <span class="fu">=</span> english })</code></pre>
<p>Then I create a context taking an argument:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">tradsContext ::</span> <span class="dt">Context</span> a
tradsContext <span class="fu">=</span> functionField <span class="st">&quot;trad&quot;</span> <span class="fu">$</span> \args item <span class="ot">-&gt;</span> <span class="kw">do</span>
  <span class="co">-- get the key</span>
  k <span class="ot">&lt;-</span> getArgs args
  <span class="co">-- get its value (a Trad object)</span>
  v <span class="ot">&lt;-</span> getValue k trads
  <span class="co">-- get the current item language</span>
  lang <span class="ot">&lt;-</span> itemLang item
  <span class="kw">case</span> lang <span class="kw">of</span>
    <span class="st">&quot;en&quot;</span> <span class="ot">-&gt;</span> return (enTrad v)
    <span class="st">&quot;fr&quot;</span> <span class="ot">-&gt;</span> return (frTrad v)
    _    <span class="ot">-&gt;</span> fail <span class="fu">$</span> lang <span class="fu">++</span> <span class="st">&quot; is not a supported language&quot;</span>
  <span class="kw">where</span>
    getArgs [k] <span class="fu">=</span> return k
    getArgs _   <span class="fu">=</span> fail <span class="st">&quot;Wrong arg for trad&quot;</span>
    <span class="co">-- search the Trad associated the key</span>
    getValue key hmap <span class="fu">=</span>
        <span class="kw">case</span> M.lookup key hmap <span class="kw">of</span>
          <span class="dt">Just</span> value <span class="ot">-&gt;</span> return value
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> fail <span class="st">&quot;Traduction not found&quot;</span></code></pre>
<p>In the real code source I also need more functions. But I just wanted to show how to pass parameters to a metadata tag.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The full code is <a href="http://github.com/yogsototh/yblog.git">here</a>. And except from the main file, I use literate Haskell. This way the code should be easier to understand.</p>
<p>If you want to know why I switched from nanoc:</p>
<p>My preceding nanoc website was a bit too messy. So much in fact, that the dependency system recompiled the entire website for any change.</p>
<p>So I had to do something about it. I had two choices:</p>
<ol style="list-style-type: decimal">
<li>Correct my old code (in Ruby)</li>
<li>Duplicate the core functionalities with Hakyll (in Haskell)</li>
</ol>
<p>I added too much functionalities in my nanoc system. Starting from scratch (almost) remove efficiently a lot of unused crap.</p>
<p>So far I am very happy with the switch. A complete build is about 4x faster. I didn’t broke the dependency system this time. As soon as I modify and save the markdown source, I can reload the page in the browser.</p>
<p>I removed a lot of feature thought. Some of them will be difficult to achieve with Hakyll. A typical example:</p>
<p>In nanoc I could take a file like this as source:</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="fu"># Title</span>

content

&lt;code file=&quot;foo.hs&quot;&gt;
main = putStrLn &quot;Cthulhu!&quot;
&lt;/code&gt;</code></pre>
<p>And it will create a file <code>foo.hs</code> which could then be downloaded.</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;h1&gt;</span>Title<span class="kw">&lt;/h1&gt;</span>

<span class="kw">&lt;p&gt;</span>content<span class="kw">&lt;/p&gt;</span>

<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;code/foo.hs&quot;</span><span class="kw">&gt;</span>Download foo.hs<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;pre&gt;&lt;code&gt;</span>main = putStrLn &quot;Cthulhu!&quot;<span class="kw">&lt;/code&gt;&lt;/pre&gt;</span></code></pre>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Nous pouvons aussi ajouter ces métadonnées dans un fichier externe (<code>toto.md.metadata</code>).<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Être correct avec les boutons share</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Social-link-the-right-way/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Social-link-the-right-way/index.html</id>
    <published>2013-03-14T00:00:00Z</published>
    <updated>2013-03-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Social-link-the-right-way/main.png" alt="Main image"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Les boutons des réseaux sociaux traquent vos utilisateurs, ont un design incohérent avec celui de votre site, utilisent des ressources, ralentissent le rendu de vos pages.</p>
<p>Faite les choses bien. Utilisez des liens statiques.</p>
<p>Si vous n’avez pas envie de lire, copiez et collez simplement le code suivant dans votre <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>&nbsp;:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;sociallinks&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://twitter.com/home?status=$url$&quot;</span>
<span class="ot">     target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Tweet this<span class="kw">&lt;/a&gt;</span> -
  <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;http://www.facebook.com/sharer/sharer.php?u=$url$&quot;</span>
<span class="ot">     target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Like this<span class="kw">&lt;/a&gt;</span> -
  <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://plus.google.com/share?url=$url$&quot;</span>
<span class="ot">     target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Share on G+<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;script&gt;</span>
(<span class="kw">function</span>(){<span class="ot">window</span>.<span class="fu">addEventListener</span>(<span class="st">&quot;DOMContentLoaded&quot;</span>,<span class="kw">function</span>(){
    <span class="kw">var</span> url=<span class="ot">document</span>.<span class="fu">location</span>;
    <span class="kw">var</span> links=<span class="ot">document</span>.<span class="fu">getElementById</span>(<span class="st">&quot;sociallinks&quot;</span>)
                      .<span class="fu">getElementsByTagName</span>(<span class="st">&#39;a&#39;</span>);
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>;i!=<span class="ot">links</span>.<span class="fu">length</span>;i++){
        links[i].<span class="fu">setAttribute</span>(<span class="st">&quot;href&quot;</span>,
            links[i].<span class="ot">href</span>.<span class="fu">replace</span>(<span class="st">&#39;$url$&#39;</span>,url));}})})();
&lt;<span class="ot">/script&gt;</span></code></pre>
</div>
<h2 id="the-problem">The problem</h2>
<p>Ever been on a website and want to tweet about it? Fortunately, the website might have a button to help you. But do you really know what this button do?</p>
<p>The “Like”, “Tweet” and “+1” buttons will call a javascript. It will get access to your cookies. It helps the provider of the button to know who you are.</p>
<p>In plain English, the “+1” button will inform Google you are visiting the website, <strong>even if you don’t click on “+1”</strong>. The same is true for the “like” button for facebook and the “tweet this” button for twitter.</p>
<p>The problem is not only a privacy issue. In fact (sadly <span class="sc"><abbr title="In my Humble Opinion">imho</abbr></span>) this isn’t an issue for most people. These button consume computer ressources. Far more than a simple link. It thus slow down a bit the computer and consume energy. These button could also slow down the rendering of your web page.</p>
<p>Another aspect is their design. Their look and feel is mostly imposed by the provider.</p>
<p>The most problematic aspect in my opinion is to use a third party js on your website. What if tomorrow twitter update their tweet button? If the upgrade break something for only a minority of people, they won’t fix it. This could occur anytime without any notification. They just have to add a <code>document.write</code> in their <code>js</code> you call asynchronously and <strong>BAM!</strong> Your website is just an empty blank page. And as you call many external ressources, it can be very difficult to find the origin of the problem.</p>
<p><strong>Using social network buttons:</strong></p>
<ul>
<li>Pros:
<ul>
<li>help user share your website,</li>
<li>can provide a popularity indicator to your users.</li>
</ul></li>
<li>Cons:
<ul>
<li>you help tracking your users,</li>
<li>generally doesn’t follow the design of your website,</li>
<li>use more computer ressources,</li>
<li>slow down your website,</li>
<li>executing third party js can break things silently.</li>
</ul></li>
</ul>
<h2 id="solutions">Solutions</h2>
<p>I will provide you two solutions with the following properties:</p>
<ul>
<li>Pros:
<ul>
<li>help user share your website,</li>
<li>doesn’t follow your user,</li>
<li>use almost no computer ressource,</li>
<li>doesn’t slow down your website,</li>
<li>doesn’t execute any third party js on your website.</li>
</ul></li>
<li>Cons:
<ul>
<li>doesn’t provide any popularity information.</li>
</ul></li>
</ul>
<p><strong>Solution 1 (no js):</strong></p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://twitter.com/home?status=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Tweet this<span class="kw">&lt;/a&gt;</span>

<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;http://www.facebook.com/sharer/sharer.php?u=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Like this<span class="kw">&lt;/a&gt;</span>

<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://plus.google.com/share?url=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Share on G+<span class="kw">&lt;/a&gt;</span></code></pre>
<p>But you have to replace <code>$url$</code> by the current <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>.</p>
<p><strong>Solution 2 (Just copy/paste):</strong></p>
<p>If you don’t want to write the <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span> yourself, you could use some minimal js:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;sociallinks&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://twitter.com/home?status=$url$&quot;</span>
<span class="ot">     target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Tweet this<span class="kw">&lt;/a&gt;</span> -
  <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;http://www.facebook.com/sharer/sharer.php?u=$url$&quot;</span>
<span class="ot">     target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Like this<span class="kw">&lt;/a&gt;</span> -
  <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://plus.google.com/share?url=$url$&quot;</span>
<span class="ot">     target=</span><span class="st">&quot;_blank&quot;</span><span class="kw">&gt;</span>Share on G+<span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;script&gt;</span>
(<span class="kw">function</span>(){<span class="ot">window</span>.<span class="fu">addEventListener</span>(<span class="st">&quot;DOMContentLoaded&quot;</span>,<span class="kw">function</span>(){
    <span class="kw">var</span> url=<span class="ot">document</span>.<span class="fu">location</span>;
    <span class="kw">var</span> links=<span class="ot">document</span>.<span class="fu">getElementById</span>(<span class="st">&quot;sociallinks&quot;</span>)
                      .<span class="fu">getElementsByTagName</span>(<span class="st">&#39;a&#39;</span>);
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>;i!=<span class="ot">links</span>.<span class="fu">length</span>;i++){
        links[i].<span class="fu">setAttribute</span>(<span class="st">&quot;href&quot;</span>,
            links[i].<span class="ot">href</span>.<span class="fu">replace</span>(<span class="st">&#39;$url$&#39;</span>,url));}})})();
&lt;<span class="ot">/script&gt;</span></code></pre>
<p>Here is the result:</p>
<div class="nostar" style="text-align:center">
<div id="sociallinks">
<a href="https://twitter.com/home?status=$url$"
     target="_blank">Tweet this</a> - <a href="http://www.facebook.com/sharer/sharer.php?u=$url$"
     target="_blank">Like this</a> - <a href="https://plus.google.com/share?url=$url$"
     target="_blank">Share on G+</a>
</div>
<script>
(function(){window.addEventListener("DOMContentLoaded",function(){
    var url=document.location;
    var links=document.getElementById("sociallinks")
                      .getElementsByTagName('a');
    for (var i=0;i!=links.length;i++){
        links[i].setAttribute("href",
            links[i].href.replace('$url$',url));}})})();
</script>

</div>
<h2 id="good-looking-solutions">Good looking solutions</h2>
<p>If you don’t want just text but nice icons. You have many choices:</p>
<ul>
<li>Use images <code>&lt;img src=&quot;...&quot;/&gt;</code> in the links.</li>
<li>Use icon fonts</li>
</ul>
<p>As the first solution is pretty straightforward, I’ll explain the second one.</p>
<ol style="list-style-type: decimal">
<li>Download the icon font <a href="http://blog.martianwabbit.com/post/4344642365.html">here</a></li>
<li>put the font file(s) at some place (here ‘fonts/social_font.ttf’ relatively to your <span class="sc">css</span> file)</li>
<li>Add this to your <span class="sc">css</span></li>
</ol>
<pre class="sourceCode css"><code class="sourceCode css"><span class="dv">@font-face</span>
  font-family<span class="dv">:</span> <span class="st">&#39;social&#39;</span>
  src<span class="dv">:</span> url(<span class="st">&#39;fonts/social_font.ttf&#39;</span>) format(<span class="st">&#39;truetype&#39;</span>)
  font-weight<span class="dv">:</span> normal
  font-style<span class="dv">:</span> normal
<span class="fl">.social</span>
  font-family<span class="dv">:</span> social</code></pre>
<p>Now add this to your <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>:</p>
<p><strong>Solution 1 (without js):</strong></p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://twitter.com/home?status=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span>
<span class="ot">    class=</span><span class="st">&quot;social&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;#116;</span><span class="kw">&lt;/a&gt;</span>
·
<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;http://www.facebook.com/sharer/sharer.php?u=$url$&quot;</span>
<span class="ot">   target=</span><span class="st">&quot;_blank&quot;</span>
<span class="ot">   class=</span><span class="st">&quot;social&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;#0096;</span><span class="kw">&lt;/a&gt;</span>
·
<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://plus.google.com/share?url=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span>
<span class="ot">    class=</span><span class="st">&quot;social&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;#0103;</span><span class="kw">&lt;/a&gt;</span></code></pre>
<p><strong>Solution 2 (same with a bit more js):</strong></p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;sociallinksunicode&quot;</span><span class="kw">&gt;</span>
<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://twitter.com/home?status=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span>
<span class="ot">    class=</span><span class="st">&quot;social&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;#116;</span><span class="kw">&lt;/a&gt;</span>
·
<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;http://www.facebook.com/sharer/sharer.php?u=$url$&quot;</span>
<span class="ot">   target=</span><span class="st">&quot;_blank&quot;</span>
<span class="ot">   class=</span><span class="st">&quot;social&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;#0096;</span><span class="kw">&lt;/a&gt;</span>
·
<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://plus.google.com/share?url=$url$&quot;</span>
<span class="ot">    target=</span><span class="st">&quot;_blank&quot;</span>
<span class="ot">    class=</span><span class="st">&quot;social&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;#0103;</span><span class="kw">&lt;/a&gt;</span>
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;script&gt;</span>
(<span class="kw">function</span>(){<span class="ot">window</span>.<span class="fu">addEventListener</span>(<span class="st">&quot;DOMContentLoaded&quot;</span>,<span class="kw">function</span>(){
    <span class="kw">var</span> url=<span class="ot">document</span>.<span class="fu">location</span>;
    <span class="kw">var</span> links=<span class="ot">document</span>.<span class="fu">getElementById</span>(<span class="st">&quot;sociallinksunicode&quot;</span>)
                      .<span class="fu">getElementsByTagName</span>(<span class="st">&#39;a&#39;</span>);
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>;i!=<span class="ot">links</span>.<span class="fu">length</span>;i++){
        links[i].<span class="fu">setAttribute</span>(<span class="st">&quot;href&quot;</span>,
            links[i].<span class="ot">href</span>.<span class="fu">replace</span>(<span class="st">&#39;$url$&#39;</span>,url));}})})();
&lt;<span class="ot">/script&gt;</span></code></pre>
<p>Here is the result:</p>
<div class="nostar" style="font-size: 2em; text-align: center;">
<div id="sociallinksunicode">
<a href="https://twitter.com/home?status=$url$"
    target="_blank"
    class="social">t</a> · <a href="http://www.facebook.com/sharer/sharer.php?u=$url$"
   target="_blank"
   class="social">`</a> · <a href="https://plus.google.com/share?url=$url$"
    target="_blank"
    class="social">g</a>
</div>
<script>
(function(){window.addEventListener("DOMContentLoaded",function(){
    var url=document.location;
    var links=document.getElementById("sociallinksunicode")
                      .getElementsByTagName('a');
    for (var i=0;i!=links.length;i++){
        links[i].setAttribute("href",
            links[i].href.replace('$url$',url));}})})();
</script>
</div>
<h2 id="conclusion">Conclusion</h2>
<ol style="list-style-type: decimal">
<li>You get your design back,</li>
<li>You stop to help tracking people,</li>
<li>You use less computer ressources and more generally power ressources which is good for the planet,</li>
<li>Your web pages will load faster.</li>
</ol>
<p><em>ps</em>: On my personal website I continue to use Google analytics. Therefore, Google (and only Google, not facebook nor twitter) can track you here. But I might change this in the future.</p>]]></summary>
</entry>
<entry>
    <title>Category Theory Presentation</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Category-Theory-Presentation/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Category-Theory-Presentation/index.html</id>
    <published>2012-12-12T00:00:00Z</published>
    <updated>2012-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-hask-endofunctor.png" alt="Cateogry of Hask's endofunctors"/>

<p>Yesterday I was happy to make a presentation about Category Theory at <a href="http://www.meetup.com/riviera-scala-clojure">Riviera Scala Clojure Meetup</a> (note I used only Haskell for my examples).</p>

<ul><li><a href="http://yogsototh.github.com/Category-Theory-Presentation/categories.html">Click here to go to the HTML presentation.</a>
</li><li><a href="http://yogsototh.github.com/Category-Theory-Presentation/categories.pdf">Click Here to download the PDF slides (<span style="text-transform: uppercase">L<sup style="vertical-align: 0.15em; margin-left: -0.36em; margin-right: -0.15em; font-size: .85em">a</sup>T<sub style="vertical-align: -0.5ex; margin-left: -0.1667em; margin-right: -0.125em; font-size: 1em">e</sub>X</span> not rendered properly)</a>
</li></ul>

<p>If you don't want to read them through an HTML presentations framework or downloading a big PDF
just continue to read as a standard web page.
</p>

<div style="display:none">
\(\newcommand{\F}{\mathbf{F}}\)
\(\newcommand{\E}{\mathbf{E}}\)
\(\newcommand{\C}{\mathcal{C}}\)
\(\newcommand{\D}{\mathcal{D}}\)
\(\newcommand{\id}{\mathrm{id}}\)
\(\newcommand{\ob}[1]{\mathrm{ob}(#1)}\)
\(\newcommand{\hom}[1]{\mathrm{hom}(#1)}\)
\(\newcommand{\Set}{\mathbf{Set}}\)
\(\newcommand{\Mon}{\mathbf{Mon}}\)
\(\newcommand{\Vec}{\mathbf{Vec}}\)
\(\newcommand{\Grp}{\mathbf{Grp}}\)
\(\newcommand{\Rng}{\mathbf{Rng}}\)
\(\newcommand{\ML}{\mathbf{ML}}\)
\(\newcommand{\Hask}{\mathbf{Hask}}\)
\(\newcommand{\Cat}{\mathbf{Cat}}\)
\(\newcommand{\fmap}{\mathtt{fmap}}\)
</div>

<section class="slide" style="text-align: center;">
<h1 style="position: relative;">Category Theory <span class="and">&amp;</span> Programming</h1>
<div><em class="base01">for</em> <a href="http://www.meetup.com/riviera-scala-clojure">Rivieria Scala Clojure</a> (Note this presentation uses Haskell)</div>
<author><em class="base01">by</em> <a href="http://yannesposito.com">Yann Esposito</a></author>
<div style="font-size:.8em; margin: 5em auto">
    <twitter>
        <a href="http://twitter.com/yogsototh">@yogsototh</a>,
     </twitter>
     <googleplus>
        <a href="https://plus.google.com/117858550730178181663">+yogsototh</a>
     </googleplus>
</div>
<div class="flush"></div></section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight:bold">
    <li><span class="orange">General overview</li>
    <li>Definitions</li>
    <li>Applications</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="not-really-about-cat-glory">Not really about: Cat <span class="and">&amp;</span> glory</h2>
<figure>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/categlory.jpg" alt="Cat n glory" /> <figcaption>credit to Tokuhiro Kawai (川井徳寛)</figcaption>
</figure>

<div class="flush"></div></section>
<section class="slide">
<h2 id="general-overview">General Overview</h2>
<div style="float:right; width: 18%">
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/eilenberg.gif" alt="Samuel Eilenberg"/> <img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/maclaine.jpg" alt="Saunders Mac Lane"/>
</div>

<p><em>Recent Math Field</em><br />1942-45, Samuel Eilenberg <span class="and">&amp;</span> Saunders Mac Lane</p>
<p>Certainly one of the more abstract branches of math</p>
<ul>
<li><em>New math foundation</em><br /> formalism abstraction, package entire theory<sup>★</sup></li>
<li><em>Bridge between disciplines</em><br /> Physics, Quantum Physics, Topology, Logic, Computer Science<sup>☆</sup></li>
</ul>
<p  class="base01" style="border-top: solid 1px; width: 70%; font-size: 0.7em">
★: <a href="http://www.math.harvard.edu/~mazur/preprints/when_is_one.pdf">When is one thing equal to some other thing?, Barry Mazur, 2007</a><br/> ☆: <a href="http://math.ucr.edu/home/baez/rosetta.pdf">Physics, Topology, Logic and Computation: A Rosetta Stone, John C. Baez, Mike Stay, 2009</a>
</p>

<div class="flush"></div></section>
<section class="slide">
<h2 id="from-a-programmer-perspective">From a Programmer perspective</h2>
<blockquote>
<p>Category Theory is a new language/framework for Math</p>
</blockquote>
<ul>
<li>Another way of thinking</li>
<li>Extremely efficient for generalization</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="math-programming-relation">Math Programming relation</h2>
<img class="right" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/buddha.gif" alt="Buddha Fractal"/>
<p>Programming <em><span class="orange">is</span></em> doing Math</p>
<p>Strong relations between type theory and category theory.</p>
<p>Not convinced?<br />Certainly a <em>vocabulary</em> problem.</p>
<p>One of the goal of Category Theory is to create a <em>homogeneous vocabulary</em> between different disciplines.</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="vocabulary">Vocabulary</h2>
<img class="right" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mindblown.gif" alt="mind blown"/>
<p>Math vocabulary used in this presentation:</p>
<blockquote style="width:55%">
<p>Category, Morphism, Associativity, Preorder, Functor, Endofunctor, Categorial property, Commutative diagram, Isomorph, Initial, Dual, Monoid, Natural transformation, Monad, Klesli arrows, κατα-morphism, ...</p>
</blockquote>
<div class="flush"></div></section>
<section class="slide">
<h2 id="programmer-translation">Programmer Translation</h2>
<img class="right" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/readingcat.jpg" alt="lolcat"/>
<table style="width:50%">
<tr><th>
Mathematician
</th><th>
Programmer
</th></tr>
<tr><td>
Morphism
</td><td>
Arrow
</td></tr>
<tr><td>
Monoid
</td><td>
String-like
</td></tr>
<tr><td>
Preorder
</td><td>
Acyclic graph
</td></tr>
<tr><td>
Isomorph
</td><td>
The same
</td></tr>
<tr><td>
Natural transformation
</td><td>
rearrangement function
</td></tr>
<tr><td>
Funny Category
</td><td>
LOLCat
</td></tr>
</table>

<div class="flush"></div></section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight: bold">
    <li>General overview</li>
    <li> <span class="orange">Definitions</span>
<ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: 0 0 0 1em; width: 17em">
    <li>Category</li>
    <li>Intuition</li>
    <li>Examples</li>
    <li>Functor</li>
    <li>Examples</li>
</ul>
    </li>
    <li>Applications</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Category</h2>

<p>A way of representing <strong><em>things</em></strong> and <strong><em>ways to go between things</em></strong>.</p>

<p> A Category \(\mathcal{C}\) is defined by:</p>
<ul>
	<li> <em>Objects <span class="orange">\(\ob{C}\)</span></em>,</li>
	<li> <em>Morphisms <span class="orange">\(\hom{C}\)</span></em>,</li>
	<li> a <em>Composition law <span class="orange">(∘)</span></em></li>
    <li> obeying some <em>Properties</em>.</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Category: Objects</h2>

<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/objects.png" alt="objects" />

<p>\(\ob{\mathcal{C}}\) is a collection</p>
<div class="flush"></div></section>
<section class="slide">
<h2>Category: Morphisms</h2>

<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/morphisms.png" alt="morphisms"/>

<p>\(A\) and \(B\) objects of \(\C\)<br/>
\(\hom{A,B}\) is a collection of morphisms<br/>
\(f:A→B\) denote the fact \(f\) belongs to \(\hom{A,B}\)</p>
<p>\(\hom{\C}\) the collection of all morphisms of \(\C\)</p>
<div class="flush"></div></section>
<section class="slide">
<h2>Category: Composition</h2>
<p>Composition (∘): associate to each couple \(f:A→B, g:B→C\)
    $$g∘f:A\rightarrow C$$
</p>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/composition.png" alt="composition"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Category laws: neutral element</h2>
<p>for each object \(X\), there is an \(\id_X:X→X\),<br/>
such that for each \(f:A→B\):</p>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/identity.png" alt="identity"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Category laws: Associativity</h2>
<p> Composition is associative:</p>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/associativecomposition.png" alt="associative composition"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Commutative diagrams</h2>

<p>Two path with the same source and destination are equal.</p>
<figure class="left" style="max-width: 40%;margin-left: 5%;">
    <img
      src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/commutative-diagram-assoc.png"
      alt="Commutative Diagram (Associativity)"/>
    <figcaption>
    \((h∘g)∘f = h∘(g∘f) \)
    </figcaption>
</figure>
<figure class="right" style="max-width:31%;margin-right: 10%;">
    <img
      src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/commutative-diagram-id.png"
      alt="Commutative Diagram (Identity law)"/>
    <figcaption>
    \(id_B∘f = f = f∘id_A \)
    </figcaption>
</figure>
<div class="flush"></div></section>
<section class="slide">
<h2>Question Time!</h2>

<figure style="width:70%; margin:0 auto">
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/batquestion.jpg" width="100%"/>
<figcaption>
<em>- French-only joke -</em>
</figcaption>
</figure>
<div class="flush"></div></section>
<section class="slide">
<h2>Can this be a category?</h2>
<p>\(\ob{\C},\hom{\C}\) fixed, is there a valid ∘?</p>
<figure class="left">
    <img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example1.png" alt="Category example 1"/>
    <figcaption class="slide">
        <span class="green">YES</span>
    </figcaption>
</figure>
<figure class="left">
    <img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example2.png" alt="Category example 2"/>
    <figcaption class="slide">
        no candidate for \(g∘f\)
        <br/><span class="red">NO</span>
    </figcaption>
</figure>
<figure class="left">
    <img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example3.png" alt="Category example 3"/>
    <figcaption class="slide">
    <span class="green">YES</span>
    </figcaption>
</figure>
<div class="flush"></div></section>
<section class="slide">
<h2>Can this be a category?</h2>
<figure class="left">
    <img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example4.png" alt="Category example 4"/>
    <figcaption class="slide">
        no candidate for \(f:C→B\)
        <br/><span class="red">NO</span>
    </figcaption>
</figure>
<figure class="right" style="min-width: 50%">
    <img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-example5.png" alt="Category example 5"/>
    <figcaption class="slide">
    \((h∘g)∘f=\id_B∘f=f\)<br/>
    \(h∘(g∘f)=h∘\id_A=h\)<br/>
    but \(h≠f\)<br/>
    <span class="red">NO</span>
    </figcaption>
</figure>
<div class="flush"></div></section>
<section class="slide">
<h2>Categories Examples</h2>

<figure style="width:70%; margin:0 auto">
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/basket_of_cats.jpg" alt="Basket of cats"/>
<figcaption>
<em>- Basket of Cats -</em>
</figcaption>
</figure>
<div class="flush"></div></section>
<section class="slide">
<h2>Category \(\Set\)</h2>

<ul>
	<li> \(\ob{\Set}\) are <em>all</em> the sets</li>
    <li> \(\hom{E,F}\) are <em>all</em> functions from \(E\) to \(F\)</li>
    <li> ∘ is functions composition </li>
</ul>

<ul class="slide">
    <li>\(\ob{\Set}\) is a proper class ; not a set</li>
    <li>\(\hom{E,F}\) is a set</li>
	<li>\(\Set\) is then a <em>locally <b>small</b> category</em></li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Categories Everywhere?</h2>
<img class="right" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/cats-everywhere.jpg" alt="Cats everywhere"/>
<ul>
    <li>\(\Mon\): (monoids, monoid morphisms,∘)</li>
    <li>\(\Vec\): (Vectorial spaces, linear functions,∘)</li>
    <li>\(\Grp\): (groups, group morphisms,∘)</li>
    <li>\(\Rng\): (rings, ring morphisms,∘)</li>
    <li>Any deductive system <i>T</i>: (theorems, proofs, proof concatenation)</li>
    <li>\( \Hask\): (Haskell types, functions, <code>(.)</code> )</li>
    <li>...</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Smaller Examples</h2>

<h3>Strings</h3>
<img class="right" style="max-width:17%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/strings.png" alt="Monoids are one object categories"/>
<ul>
    <li> \(\ob{Str}\) is a singleton </li>
    <li> \(\hom{Str}\) each string </li>
    <li> ∘ is concatenation <code>(++)</code> </li>
</ul>
<ul>
    <li> <code>"" ++ u = u = u ++ ""</code> </li>
    <li> <code>(u ++ v) ++ w = u ++ (v ++ w)</code> </li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Finite Example?</h2>

<h3>Graph</h3>
<figure class="right" style="max-width:40%" >
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/graph-category.png" alt="Each graph is a category"/>
</figure>
<ul>
    <li> \(\ob{G}\) are vertices</li>
    <li> \(\hom{G}\) each path</li>
    <li> ∘ is path concatenation</li>
</ul>
<ul><li>\(\ob{G}=\{X,Y,Z\}\),
    </li><li>\(\hom{G}=\{ε,α,β,γ,αβ,βγ,...\}\)
    </li><li>\(αβ∘γ=αβγ\)
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Number construction</h2>

<h3>Each Numbers as a whole category</h3>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/numbers.png" alt="Each number as a category"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Degenerated Categories: Monoids</h2>

<img class="right" style="max-width:17%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/monoid.png" alt="Monoids are one object categories"/>
<p>Each Monoid \((M,e,⊙): \ob{M}=\{∙\},\hom{M}=M,\circ = ⊙\)</p>
<p class="orange">Only one object.</p>
<p>Examples:</p>
<ul><li><code>(Integer,0,+)</code>, <code>(Integer,1,*)</code>,
</li><li><code>(Strings,"",++)</code>, for each <code>a</code>, <code>([a],[],++)</code>
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Degenerated Categories: Preorders \((P,≤)\)</h2>

<ul><li>\(\ob{P}={P}\),
</li><li>\(\hom{x,y}=\{x≤y\} ⇔ x≤y\),
</li><li>\((y≤z) \circ (x≤y) = (x≤z) \)
</li></ul>

<p><em class="orange">At most one morphism between two objects.</em></p>

<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/preorder.png" alt="preorder category"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Degenerated Categories: Discrete Categories</h2>

<img class="right" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/set.png" alt="Any set can be a category"/>
<h3>Any Set</h3>
<p>Any set \(E: \ob{E}=E, \hom{x,y}=\{x\} ⇔  x=y \)</p>
<p class="orange">Only identities</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="choice">Choice</h2>
<p>The same object can be seen in many different way as a category.</p>
<p>You can choose what are object, morphisms and composition.</p>
<p>ex: <strong>Str</strong> and discrete(Σ<sup>*</sup>)</p>
<div class="flush"></div></section>
<section class="slide">
<h2 class="base1">Categorical Properties</h2>

<p class="base1">Any property which can be expressed in term of category, objects, morphism and composition.</p>

<ul><li> <em class="orange">Dual</em>: \(\D\) is \(\C\) with reversed morphisms.
</li><li> <em class="orange">Initial</em>: \(Z\in\ob{\C}\) s.t. \(∀Y∈\ob{\C}, \#\hom{Z,Y}=1\)
	<br/> Unique ("up to isormophism")
</li><li> <em class="orange">Terminal</em>: \(T\in\ob{\C}\) s.t. \(T\) is initial in the dual of \(\C\)
</li><li> <em class="orange">Functor</em>: structure preserving mapping between categories
</li><li> ...
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="isomorph">Isomorph</h2>
<p><img class="right" alt="isomorph cats" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/isomorph-cats.jpg" /> <em class="orange">isomorphism</em>: \(f:A→B\) which can be &quot;undone&quot; <em>i.e.</em><br />\(∃g:B→A\), \(g∘f=id_A\) <span class="and">&amp;</span> \(f∘g=id_B\)<br />in this case, \(A\) <span class="and">&amp;</span> \(B\) are <em class="orange">isomorphic</em>.</p>
<p><span class="orange">A≌B</span> means A and B are essentially the same.<br />In Category Theory, <span class="orange">=</span> is in fact mostly <span class="orange">≌</span>.<br />For example in commutative diagrams.</p>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor</h2>

<p> A functor is a mapping between two categories.
Let \(\C\) and \(\D\) be two categories.
A <em>functor</em> <span class="orange">\(\F\)</span> from <span class="blue">\(\C\)</span> to <span class="green">\(\D\)</span>:</p>
<ul>
	<li> Associate objects: <span class="backblue">\(A\in\ob{\C}\)</span> to <span class="backgreen">\(\F(A)\in\ob{\D}\)</span> </li>
	<li> Associate morphisms: <span class="backblue">\(f:A\to B\)</span> to <span class="backgreen">\(\F(f) : \F(A) \to \F(B)\)</span>
        such that
        <ul>
			<li>\( \F (\)<span class="backblue blue">\(\id_X\)</span>\()= \)<span class="backgreen"><span class="green">\(\id\)</span>\(\vphantom{\id}_{\F(}\)<span class="blue">\(\vphantom{\id}_X\)</span>\(\vphantom{\id}_{)} \)</span>,</li>
			<li>\( \F (\)<span class="backblue blue">\(g∘f\)</span>\()= \)<span class="backgreen">\( \F(\)<span class="blue">\(g\)</span>\() \)<span class="green">\(\circ\)</span>\( \F(\)<span class="blue">\(f\)</span>\() \)</span></li>
        </ul>
    </li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor Example (ob → ob)</h2>

<img width="65%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/functor.png" alt="Functor"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor Example (hom → hom)</h2>

<img width="65%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/functor-morphism.png" alt="Functor"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor Example</h2>

<img width="65%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/functor-morphism-color.png" alt="Functor"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Endofunctors</h2>

<p>An <em>endofunctor</em> for \(\C\) is a functor \(F:\C→\C\).</p>
<img width="75%"  src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/endofunctor.png" alt="Endofunctor"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Category of Categories</h2>

<img style="min-width:43%; width: 43%" class="right" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/fractalcat.jpg" />

<p>Categories and functors form a category: \(\Cat\)</p>
<ul><li>\(\ob{\Cat}\) are categories
</li><li>\(\hom{\Cat}\) are functors
</li><li>∘ is functor composition
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Plan</h2>
<ul style="font-size: 2em; font-weight:bold">
    <li>General overview</li>
    <li>Definitions</li>
    <li><span class="orange">Applications
        <ul class="base01" style="border-left: 2px solid; padding-left: 1em; font-size: .6em; float: right; font-weight: bold; margin: -4em 0 0 1em; width: 17em">
            <li>\(\Hask\) category
            </li><li> Functors
            </li><li> Natural transformations
            </li><li> Monads
            </li><li> κατα-morphisms
            </li></ul>
    </li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Hask</h2>

<p>Category \(\Hask\):</p>

<img class="right" style="max-width:30%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask.png" alt="Haskell Category Representation"/>

<ul><li>
\(\ob{\Hask} = \) Haskell types
</li><li>
\(\hom{\Hask} = \) Haskell functions
</li><li>
∘ = <code>(.)</code> Haskell function composition
</li></ul>

<p>Forget glitches because of <code>undefined</code>.</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="haskell-kinds">Haskell Kinds</h2>
<p>In Haskell some types can take type variable(s). Typically: <code>[a]</code>.</p>
<p>Types have <em>kinds</em>; The kind is to type what type is to function. Kind are the types for types (so meta).</p>
<pre><code>Int, Char :: *
[], Maybe :: * -&gt; *
(,), (-&gt;) :: * -&gt; * -&gt; *
[Int], Maybe Char, Maybe [Int] :: *</code></pre>
<div class="flush"></div></section>
<section class="slide">
<h2 id="haskell-types">Haskell Types</h2>
<p>Sometimes, the type determine a lot about the function<sup>★</sup>:</p>
<pre class="haskell"><code>fst :: (a,b) -> a -- Only one choice
snd :: (a,b) -> b -- Only one choice
f :: a -> [a]     -- Many choices
-- Possibilities: f x=[], or [x], or [x,x] or [x,...,x]

? :: [a] -> [a] -- Many choices
-- can only rearrange: duplicate/remove/reorder elements
-- for example: the type of addOne isn't [a] -> [a]
addOne l = map <span class="red">(+1)</span> l
-- The (+1) force 'a' to be a Num.</code></pre>

<p>
<p><span class="small base01">★:<a href="http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf">Theorems for free!, Philip Wadler, 1989</a></span></p>
<div class="flush"></div></section>
<section class="slide">
<h2>Haskell Functor vs \(\Hask\) Functor</h2>

<p>A Haskell Functor is a type <code>F :: * -> *</code> which belong to the type class <code>Functor</code> ; thus instantiate
<code>fmap :: (a -> b) -> (F a -> F b)</code>.

<p><span style="visibility:hidden"><span class="and">&amp;</span></span> <code>F</code>: \(\ob{\Hask}→\ob{\Hask}\)<br/> <span class="and">&amp;</span> <code>fmap</code>: \(\hom{\Hask}→\hom{\Hask}\)

<p>The couple <code>(F,fmap)</code> is a \(\Hask\)'s functor if for any <code>x :: F a</code>:</p>
<ul><li><code>fmap id x = x</code>
</li><li><code>fmap (f.g) x= (fmap f . fmap g) x</code>
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Haskell Functors Example: Maybe</h2>

<pre class="haskell"><code>data Maybe a = Just a | Nothing
instance Functor Maybe where
    fmap :: (a -> b) -> (Maybe a -> Maybe b)
    fmap f (Just a) = Just (f a)
    fmap f Nothing = Nothing</code></pre>
<pre class="haskell"><code>fmap (+1) (Just 1) == Just 2
fmap (+1) Nothing  == Nothing
fmap head (Just [1,2,3]) == Just 1</code></pre>
<div class="flush"></div></section>
<section class="slide">
<h2>Haskell Functors Example: List</h2>

<pre class="haskell"><code>instance Functor ([]) where
	fmap :: (a -> b) -> [a] -> [b]
	fmap = map</pre></code>
<pre class="haskell"><code>fmap (+1) [1,2,3]           == [2,3,4]
fmap (+1) []                == []
fmap head [[1,2,3],[4,5,6]] == [1,4]</code></pre>
<div class="flush"></div></section>
<section class="slide">
<h2 id="haskell-functors-for-the-programmer">Haskell Functors for the programmer</h2>
<p><code>Functor</code> is a type class used for types that can be mapped over.</p>
<ul>
<li>Containers: <code>[]</code>, Trees, Map, HashMap...</li>
<li>&quot;Feature Type&quot;:
<ul>
<li><code>Maybe a</code>: help to handle absence of <code>a</code>.<br />Ex: <code>safeDiv x 0 ⇒ Nothing</code></li>
<li><code>Either String a</code>: help to handle errors<br />Ex: <code>reportDiv x 0 ⇒ Left &quot;Division by 0!&quot;</code></li>
</ul></li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Haskell Functor intuition</h2>

<p>Put normal function inside a container. Ex: list, trees...<p>

<img width="70%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/boxfunctor.png" alt="Haskell Functor as a box play"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Haskell Functor properties</h2>

<p>Haskell Functors are:</p>

<ul><li><em>endofunctors</em> ; \(F:\C→\C\) here \(\C = \Hask\),
</li><li>a couple <b>(Object,Morphism)</b> in \(\Hask\).
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types look like a fractal:</p>

<img width="70%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask-endofunctor.png" alt="Haskell functor representation"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types look like a fractal:</p>

<img width="70%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask-endofunctor-objects.png" alt="Haskell functor representation"/>
<div class="flush"></div></section>
<section class="slide">
<h2>Functor as boxes</h2>

<p>Haskell functor can be seen as boxes containing all Haskell types and functions.
Haskell types look like a fractal:</p>

<img width="70%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/hask-endofunctor-morphisms.png" alt="Haskell functor representation"/>
<div class="flush"></div></section>
<section class="slide">
<h2 id="non-haskell-hasks-functors">&quot;Non Haskell&quot; Hask's Functors</h2>
<p>A simple basic example is the \(id_\Hask\) functor. It simply cannot be expressed as a couple (<code>F</code>,<code>fmap</code>) where</p>
<ul>
<li><code>F::* -&gt; *</code></li>
<li><code>fmap :: (a -&gt; b) -&gt; (F a) -&gt; (F b)</code></li>
</ul>
<p>Another example:</p>
<ul>
<li>F(<code>T</code>)=<code>Int</code></li>
<li>F(<code>f</code>)=<code>\_-&gt;0</code></li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="also-functor-inside-hask">Also Functor inside \(\Hask\)</h2>
<p>\(\mathtt{[a]}∈\ob{\Hask}\)</code> but is also a category. Idem for <code>Int</code>.</p>
<p><code>length</code> is a Functor from the category <code>[a]</code> to the category <code>Int</code>:</p>
<ul class="left" style="max-width:40%">
<li>\(\ob{\mathtt{[a]}}=\{∙\}\)</li>
<li>\(\hom{\mathtt{[a]}}=\mathtt{[a]}\)</li>
<li>\(∘=\mathtt{(++)}\)</li>
</ul>
<p class="left" style="margin:2em 3em">⇒</p>
<ul class="left" style="max-width:40%">
<li>\(\ob{\mathtt{Int}}=\{∙\}\)</li>
<li>\(\hom{\mathtt{Int}}=\mathtt{Int}\)</li>
<li>\(∘=\mathtt{(+)}\)</li>
</ul>
<div class="flush"></div>
<ul><li>id: <code>length [] = 0</code>
</li><li>comp: <code>length (l ++ l') = (length l) + (length l')</code>
</li></ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="category-of-hask-endofunctors">Category of \(\Hask\) Endofunctors</h2>
<img width="50%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/cat-hask-endofunctor.png" alt="Category of Hask endofunctors" />
<div class="flush"></div></section>
<section class="slide">
<h2 id="category-of-functors">Category of Functors</h2>
<p>If \(\C\) is <em>small</em> (\(\hom{\C}\) is a set). All functors from \(\C\) to some category \(\D\) form the category \(\mathrm{Func}(\C,\D)\).</p>
<ul>
<li>\(\ob{\mathrm{Func}(\C,\D)}\): Functors \(F:\C→\D\)</li>
<li>\(\hom{\mathrm{Func}(\C,\D)}\): <em>natural transformations</em></li>
<li>∘: Functor composition</li>
</ul>
<p>\(\mathrm{Func}(\C,\C)\) is the category of endofunctors of \(\C\).</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="natural-transformations">Natural Transformations</h2>
<p>Let \(F\) and \(G\) be two functors from \(\C\) to \(\D\).</p>
<p><img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/natural-transformation.png" alt="Natural transformation commutative diagram" class="right"/> <em>A natural transformation:</em> familly η ; \(η_X\in\hom{\D}\) for \(X\in\ob{\C}\) s.t.</p>
<p>ex: between Haskell functors; <code>F a -&gt; G a</code><br />Rearragement functions only.</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="natural-transformation-examples-14">Natural Transformation Examples (1/4)</h2>
<pre><code class="haskell small">data List a = Nil | Cons a (List a)
toList :: [a] -> List a
toList [] = Nil
toList (x:xs) = Cons x (toList xs)</code></pre>
<p><code>toList</code> is a natural transformation. It is also a morphism from <code>[]</code> to <code>List</code> in the Category of \(\Hask\) endofunctors.</p>
<img style="float:left;width:30%;margin-left: 1em;" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-list-tree.png" alt="natural transformation commutative diagram"/>
<figure style="float:right;width:50%">
<img style="width:40%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/list-tree-endofunctor-morphism.png" alt="natural transformation commutative diagram"/>
</figure>

<div class="flush"></div></section>
<section class="slide">
<h2 id="natural-transformation-examples-24">Natural Transformation Examples (2/4)</h2>
<pre><code class="haskell small">data List a = Nil | Cons a (List a)
toHList :: List a -> [a]
toHList Nil = []
toHList (Cons x xs) = x:toHList xs</code></pre>
<p><code>toHList</code> is a natural transformation. It is also a morphism from <code>List</code> to <code>[]</code> in the Category of \(\Hask\) endofunctors.</p>
<img style="float:left;width:30%;margin-left:1em" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-tree-list.png" alt="natural transformation commutative diagram"/>
<figure style="float:right;width:50%">
<img style="width:40%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/tree-list-endofunctor-morphism.png" alt="natural transformation commutative diagram"/> <figcaption><code>toList . toHList = id</code> <span class="and">&amp;</span> <code>toHList . toList = id</code> <span style="visibility:hidden"><span class="and">&amp;</span></span><br/> therefore <code>[]</code> <span class="and">&amp;</span> <code>List</code> are <span class="orange">isomorph</span>. </figcaption>
</figure>

<div class="flush"></div></section>
<section class="slide">
<h2 id="natural-transformation-examples-34">Natural Transformation Examples (3/4)</h2>
<pre><code class="haskell small">toMaybe :: [a] -> Maybe a
toMaybe [] = Nothing
toMaybe (x:xs) = Just x</code></pre>
<p><code>toMaybe</code> is a natural transformation. It is also a morphism from <code>[]</code> to <code>Maybe</code> in the Category of \(\Hask\) endofunctors.</p>
<img style="float:left;width:30%;margin-left:1em;" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-list-maybe.png" alt="natural transformation commutative diagram"/>
<figure style="float:right;width:50%">
<img style="width:40%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/list-maybe-endofunctor-morphism.png" alt="natural transformation commutative diagram"/>
</figure>

<div class="flush"></div></section>
<section class="slide">
<h2 id="natural-transformation-examples-44">Natural Transformation Examples (4/4)</h2>
<pre><code class="haskell small">mToList :: Maybe a -> [a]
mToList Nothing = []
mToList Just x  = [x]</code></pre>
<p><code>toMaybe</code> is a natural transformation. It is also a morphism from <code>[]</code> to <code>Maybe</code> in the Category of \(\Hask\) endofunctors.</p>
<img style="float:left;width:30%;margin-left:1em;" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/nattrans-maybe-list.png" alt="natural transformation commutative diagram"/>
<figure style="float:right;width:50%">
<img style="width:40%" src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/mp/maybe-list-endofunctor-morphsm.png" alt="relation between [] and Maybe"/> <figcaption>There is <span class="red">no isomorphism</span>.<br/> Hint: <code>Bool</code> lists longer than 1. </figcaption>
</figure>

<div class="flush"></div></section>
<section class="slide">
<h2 id="composition-problem">Composition problem</h2>
<p>The Problem; example with lists:</p>
<pre class="haskell"><code>f x = [x]       ⇒ f 1 = [1]   ⇒ (f.f) 1 = [[1]] ✗
g x = [x+1]     ⇒ g 1 = [2]   ⇒ (g.g) 1 = ERROR [2]+1 ✗
h x = [x+1,x*3] ⇒ h 1 = [2,3] ⇒ (h.h) 1 = ERROR [2,3]+1 ✗ </code></pre>

<p>The same problem with most <code>f :: a -&gt; F a</code> functions and functor <code>F</code>.</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="composition-fixable">Composition Fixable?</h2>
<p>How to fix that? We want to construct an operator which is able to compose:</p>
<p><code>f :: a -&gt; F b</code> <span class="and">&amp;</span> <code>g :: b -&gt; F c</code>.</p>
<p>More specifically we want to create an operator ◎ of type</p>
<p><code>◎ :: (b -&gt; F c) -&gt; (a -&gt; F b) -&gt; (a -&gt; F c)</code></p>
<p>Note: if <code>F</code> = I, ◎ = <code>(.)</code>.</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="fix-composition-12">Fix Composition (1/2)</h2>
<p>Goal, find: <code>◎ :: (b -&gt; F c) -&gt; (a -&gt; F b) -&gt; (a -&gt; F c)</code><br /><code>f :: a -&gt; F b</code>, <code>g :: b -&gt; F c</code>:</p>
<ul>
<li><code>(g ◎ f) x</code> ???</li>
<li>First apply <code>f</code> to <code>x</code> ⇒ <code>f x :: F b</code></li>
<li>Then how to apply <code>g</code> properly to an element of type <code>F b</code>?</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="fix-composition-22">Fix Composition (2/2)</h2>
<p>Goal, find: <code>◎ :: (b -&gt; F c) -&gt; (a -&gt; F b) -&gt; (a -&gt; F c)</code><br /><code>f :: a -&gt; F b</code>, <code>g :: b -&gt; F c</code>, <span class="orange"><code>f x :: F b</code></span>:</p>
<ul>
<li>Use <code>fmap :: (t -&gt; u) -&gt; (F t -&gt; F u)</code>!</li>
<li><code>(fmap g) :: F b -&gt; F (F c)</code> ; (<code>t=b</code>, <code>u=F c</code>)</li>
<li><code>(fmap g) (f x) :: F (F c)</code> it almost WORKS!</li>
<li>We lack an important component, <code>join :: F (F c) -&gt; F c</code></li>
<li><code>(g ◎ f) x = join ((fmap g) (f x))</code> ☺<br />◎ is the Kleisli composition; in Haskell: <code>&lt;=&lt;</code> (in <code>Control.Monad</code>).</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="necessary-laws">Necessary laws</h2>
<p>For ◎ to work like composition, we need join to hold the following properties:</p>
<ul>
<li><code>join (join (F (F (F a))))=join (F (join (F (F a))))</code></li>
<li>abusing notations denoting <code>join</code> by ⊙; this is equivalent to<br /><span class="orange"><code>(F ⊙ F) ⊙ F = F ⊙ (F ⊙ F)</code></span></li>
<li>There exists <code>η :: a -&gt; F a</code> s.t.<br /><span class="orange"><code>η⊙F=F=F⊙η</code></span></li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="klesli-composition">Klesli composition</h2>
<p>Now the composition works as expected. In Haskell ◎ is <code>&lt;=&lt;</code> in <code>Control.Monad</code>.</p>
<p><code>g &lt;=&lt; f = \x -&gt; join ((fmap g) (f x))</code></p>
<pre class="haskell"><code>f x = [x]       ⇒ f 1 = [1]   ⇒ (f <=< f) 1 = [1] ✓
g x = [x+1]     ⇒ g 1 = [2]   ⇒ (g <=< g) 1 = [3] ✓
h x = [x+1,x*3] ⇒ h 1 = [2,3] ⇒ (h <=< h) 1 = [3,6,4,9] ✓</code></pre>

<div class="flush"></div></section>
<section class="slide">
<h2 id="we-reinvented-monads">We reinvented Monads!</h2>
<p>A monad is a triplet <code>(M,⊙,η)</code> where</p>
<ul>
<li>\(M\) an <span class="orange">Endofunctor</span> (to type <code>a</code> associate <code>M a</code>)</li>
<li>\(⊙:M×M→M\) a <span class="orange">nat. trans.</span> (i.e. <code>⊙::M (M a) → M a</code> ; <code>join</code>)</li>
<li>\(η:I→M\) a <span class="orange">nat. trans.</span> (\(I\) identity functor ; <code>η::a → M a</code>)</li>
</ul>
<p>Satisfying</p>
<ul>
<li>\(M ⊙ (M ⊙ M) = (M ⊙ M) ⊙ M\)</li>
<li>\(η ⊙ M = M = M ⊙ η\)</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="compare-with-monoid">Compare with Monoid</h2>
<p>A Monoid is a triplet \((E,∙,e)\) s.t.</p>
<ul>
<li>\(E\) a set</li>
<li>\(∙:E×E→E\)</li>
<li>\(e:1→E\)</li>
</ul>
<p>Satisfying</p>
<ul>
<li>\(x∙(y∙z) = (x∙y)∙z, ∀x,y,z∈E\)</li>
<li>\(e∙x = x = x∙e, ∀x∈E\)</li>
</ul>
<div class="flush"></div></section>
<section class="slide">
<h2 id="monads-are-just-monoids">Monads are just Monoids</h2>
<blockquote>
<p>A Monad is just a monoid in the category of endofunctors, what's the problem?</p>
</blockquote>
<p>The real sentence was:</p>
<blockquote>
<p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
</blockquote>
<div class="flush"></div></section>
<section class="slide">
<h2 id="example-list">Example: List</h2>
<ul>
<li><code>[] :: * -&gt; *</code> an <span class="orange">Endofunctor</span></li>
<li>\(⊙:M×M→M\) a nat. trans. (<code>join :: M (M a) -&gt; M a</code>)</li>
<li>\(η:I→M\) a nat. trans.</li>
</ul>
<pre class="haskell"><code>-- In Haskell ⊙ is "join" in "Control.Monad"
join :: [[a]] -> [a]
join = concat

-- In Haskell the "return" function (unfortunate name)
η :: a -> [a]
η x = [x]</code></pre>

<div class="flush"></div></section>
<section class="slide">
<h2 id="example-list-law-verification">Example: List (law verification)</h2>
<p>Example: <code>List</code> is a functor (<code>join</code> is ⊙)</p>
<ul>
<li>\(M ⊙ (M ⊙ M) = (M ⊙ M) ⊙ M\)</li>
<li>\(η ⊙ M = M = M ⊙ η\)</li>
</ul>
<pre class="nohighlight small"><code>join [ join [[x,y,...,z]] ] = join [[x,y,...,z]]
                            = join (join [[[x,y,...,z]]])
join (η [x]) = [x] = join [η x]</code></pre>

<p>Therefore <code>([],join,η)</code> is a monad.</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="monads-utility">Monads useful?</h2>
<p>A <em>LOT</em> of monad tutorial on the net. Just one example; the State Monad</p>
<p><code>DrawScene</code> to <code><span class="orange">State Screen</span> DrawScene</code> ; still <b>pure</b>.</p>
<pre class="haskell left smaller" style="width:40%"><code>main = drawImage (width,height)

drawImage :: Screen -&gt; DrawScene
drawImage <span class="orange">screen</span> = do
    drawPoint p <span class="orange">screen</span>
    drawCircle c <span class="orange">screen</span>
    drawRectangle r <span class="orange">screen</span>

drawPoint point <span class="orange">screen</span> = ...
drawCircle circle <span class="orange">screen</span> = ...
drawRectangle rectangle <span class="orange">screen</span> = ...</code></pre>
<pre class="haskell right smaller" style="width:40%"><code>main = do
    <span class="orange">put (Screen 1024 768)</span>
    drawImage

drawImage :: State Screen DrawScene
drawImage = do
    drawPoint p
    drawCircle c
    drawRectangle r

drawPoint :: Point -&gt;
               State Screen DrawScene
drawPoint p = do
    <span class="orange">Screen width height &lt;- get</span>
    ...</code></pre>
<div class="flush"></div></section>
<section class="slide">
<h2 id="fold"><code>fold</code></h2>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/tower_folded.gif" alt="fold" style="width:50%;max-width:50%"/>
<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism">κατα-morphism</h2>
<img src="http://yogsototh.github.com/Category-Theory-Presentation/categories/img/earth_catamorphed.gif" alt="catamorphism" style="width:90%;max-width:90%"/>
<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism-fold-generalization">κατα-morphism: fold generalization</h2>
<p><code>acc</code> type of the &quot;accumulator&quot;:<br /><code>fold :: (acc -&gt; a -&gt; acc) -&gt; acc -&gt; [a] -&gt; acc</code></p>
<p>Idea: put the accumulated value inside the type.</p>
<pre class="haskell"><code>-- Equivalent to fold (+1) 0 "cata"
(Cons 'c' (Cons 'a' (Cons 't' (Cons 'a' Nil))))
(Cons 'c' (Cons 'a' (Cons 't' (Cons 'a' <span style="border: solid 1px;">0</span>))))
(Cons 'c' (Cons 'a' (Cons 't' <span style="border: solid 1px;">1</span>)))
(Cons 'c' (Cons 'a' <span style="border: solid 1px;">2</span>))
(Cons 'c' <span style="border: solid 1px;">3</span>)
<span style="border: solid 1px;">4</span></code></pre>

<p>But where are all the informations? <code>(+1)</code> and <code>0</code>?</p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism-missing-information">κατα-morphism: Missing Information</h2>
<p>Where is the missing information?</p>
<ul>
<li>Functor operator <code>fmap</code></li>
<li>Algebra representing the <code>(+1)</code> and also knowing about the <code>0</code>.</li>
</ul>
<p>First example, make <code>length</code> on <code>[Char]</code></p>
<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism-type-work">κατα-morphism: Type work</h2>
<pre class="haskell"><code>
data StrF a = Cons Char a | Nil
data Str' = StrF Str'

-- generalize the construction of Str to other datatype
-- Mu: type fixed point
-- Mu :: (* -> *) -> *

data Mu f = InF { outF :: f (Mu f) }
data Str = Mu StrF

-- Example
foo=InF { outF = Cons 'f'
        (InF { outF = Cons 'o'
            (InF { outF = Cons 'o'
                (InF { outF = Nil })})})}</code></pre>

<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism-missing-information-retrieved">κατα-morphism: missing information retrieved</h2>
<pre class="haskell"><code>type Algebra f a = f a -> a
instance Functor (StrF a) =
    fmap f (Cons c x) = Cons c (f x)
    fmap _ Nil = Nil</code></pre>

<pre class="haskell"><code>cata :: Functor f => Algebra f a -> Mu f -> a
cata f = f . fmap (cata f) . outF</code></pre>

<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism-finally-length">κατα-morphism: Finally length</h2>
<p>All needed information for making length.</p>
<pre><code>instance Functor (StrF a) =
    fmap f (Cons c x) = Cons c (f x)
    fmap _ Nil = Nil

length&#39; :: Str -&gt; Int
length&#39; = cata phi where
    phi :: Algebra StrF Int -- StrF Int -&gt; Int
    phi (Cons a b) = 1 + b
    phi Nil = 0

main = do
    l &lt;- length&#39; $ stringToStr &quot;Toto&quot;
    ...</code></pre>
<div class="flush"></div></section>
<section class="slide">
<h2 id="κατα-morphism-extension-to-trees">κατα-morphism: extension to Trees</h2>
<p>Once you get the trick, it is easy to extent to most Functor.</p>
<pre><code>type Tree = Mu TreeF
data TreeF x = Node Int [x]

instance Functor TreeF where
  fmap f (Node e xs) = Node e (fmap f xs)

depth = cata phi where
  phi :: Algebra TreeF Int -- TreeF Int -&gt; Int
  phi (Node x sons) = 1 + foldr max 0 sons</code></pre>
<div class="flush"></div></section>
<section class="slide last">
<h2 id="conclusion">Conclusion</h2>
<p>Category Theory oriented Programming:</p>
<ul>
<li>Focus on the type and operators</li>
<li>Extreme generalisation</li>
<li>Better modularity</li>
<li>Better control through properties of types</li>
</ul>
<p><span class="smaller">No cat were harmed in the making of this presentation.</span></p>
<div class="flush"></div></section>
]]></summary>
</entry>
<entry>
    <title>Un example progressif avec Haskell</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Haskell-OpenGL-Mandelbrot/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Haskell-OpenGL-Mandelbrot/index.html</id>
    <published>2012-06-15T00:00:00Z</published>
    <updated>2012-06-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/BenoitBMandelbrot.jpg" alt="The B in Benoît B. Mandelbrot stand for Benoît B. Mandelbrot"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Un exemple progressif d’utilisation d’Haskell. Vous pourrez voir un ensemble de Mandelbrot étendu à la troisième dimension. De plus le code sera très propre. Les détails de rendu sont séparés dans un module externe. Le code descriptif intéressant est concentré dans un environnement pur et fonctionnel. Vous pouvez vous inspirer de ce code utilisant le paradigme fonctional dans tous les languages.</p>
</div>
<h2 id="introduction">Introduction</h2>
<p>In my <a href="/Scratch/en/blog/Haskell-the-Hard-Way/">preceding article</a> I introduced Haskell.</p>
<p>This article goes further. It will show how to use functional programming with interactive programs. But more than that, it will show how to organize your code in a functional way. This article is more about functional paradigm than functional language. The code organization can be used in most imperative language.</p>
<p>As Haskell is designed for functional paradigm, it is easier to use in this context. In reality, the firsts sections will use an imperative paradigm. As you can use functional paradigm in imperative language, you can also use imperative paradigm in functional languages.</p>
<p>This article is about creating an useful and clean program. It can interact with the user in real time. It uses OpenGL, a library with imperative programming foundations. Despite this fact, most of the final code will remain in the pure part (no <code>IO</code>).</p>
<p>I believe the main audience for this article are:</p>
<ul>
<li>Haskell programmer looking for an OpengGL tutorial.</li>
<li>People interested in program organization (programming language agnostic).</li>
<li>Fractal lovers and in particular 3D fractal.</li>
<li>People interested in user interaction in a functional paradigm.</li>
</ul>
<p>I had in mind for some time now to make a Mandelbrot set explorer. I had already written a <a href="http://github.com/yogsototh/mandelbrot.git">command line Mandelbrot set generator in Haskell</a>. This utility is highly parallel; it uses the <code>repa</code> package<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>This time, we will not parallelize the computation. Instead, we will display the Mandelbrot set extended in 3D using OpenGL and Haskell. You will be able to move it using your keyboard. This object is a Mandelbrot set in the plan (z=0), and something nice to see in 3D.</p>
<p>Here are some screenshots of the result:</p>
<figure>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/GoldenMandelbulb.png" alt="The entire Mandelbulb"/>
<figcaption>
The entire Mandelbulb
</figcaption>
</figure>
<figure>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/3DMandelbulbDetail.png" alt="A Mandelbulb detail"/>
<figcaption>
A Mandelbulb detail
</figcaption>
</figure>
<figure>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/3DMandelbulbDetail2.png" alt="Another detail of the Mandelbulb"/>
<figcaption>
Another detail of the Mandelbulb
</figcaption>
</figure>

<p>And you can see the intermediate steps to reach this goal:</p>
<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/HGL_Plan.png" alt="The parts of the article"/>
</div>
<p>From the 2nd section to the 4th it will be <em>dirtier</em> and <em>dirtier</em>. We start cleaning the code at the 5th section.</p>
<hr/>
<p><a href="code/01_Introduction/hglmandel.lhs" class="cut">Download the source code of this section → 01_Introduction/<strong>hglmandel.lhs</strong></a></p>
<h2 id="first-version">First version</h2>
<p>We can consider two parts. The first being mostly some boilerplate<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. And the second part more focused on OpenGL and content.</p>
<h3 id="lets-play-the-song-of-our-people">Let’s play the song of our people</h3>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Graphics.Rendering.OpenGL</span>
<span class="kw">import </span><span class="dt">Graphics.UI.GLUT</span>
<span class="kw">import </span><span class="dt">Data.IORef</span></code></pre>
</div>
<p>For efficiency reason<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, I will not use the default Haskell <code>Complex</code> data type.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">C</span> (<span class="dt">Float</span>,<span class="dt">Float</span>) <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Complex</span> <span class="kw">where</span>
    fromInteger n <span class="fu">=</span> <span class="dt">C</span> (fromIntegral n,<span class="dv">0</span><span class="fu">.</span><span class="dv">0</span>)
    <span class="dt">C</span> (x,y) <span class="fu">*</span> <span class="dt">C</span> (z,t) <span class="fu">=</span> <span class="dt">C</span> (z<span class="fu">*</span>x <span class="fu">-</span> y<span class="fu">*</span>t, y<span class="fu">*</span>z <span class="fu">+</span> x<span class="fu">*</span>t)
    <span class="dt">C</span> (x,y) <span class="fu">+</span> <span class="dt">C</span> (z,t) <span class="fu">=</span> <span class="dt">C</span> (x<span class="fu">+</span>z, y<span class="fu">+</span>t)
    abs (<span class="dt">C</span> (x,y))     <span class="fu">=</span> <span class="dt">C</span> (sqrt (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y),<span class="dv">0</span><span class="fu">.</span><span class="dv">0</span>)
    signum (<span class="dt">C</span> (x,y))  <span class="fu">=</span> <span class="dt">C</span> (signum x , <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span>)</code></pre>
</div>
<p>We declare some useful functions for manipulating complex numbers:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">complex ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span>
complex x y <span class="fu">=</span> <span class="dt">C</span> (x,y)

<span class="ot">real ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
real (<span class="dt">C</span> (x,y))    <span class="fu">=</span> x

<span class="ot">im ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
im   (<span class="dt">C</span> (x,y))    <span class="fu">=</span> y

<span class="ot">magnitude ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
magnitude <span class="fu">=</span> real<span class="fu">.</span>abs</code></pre>
</div>
<h3 id="let-us-start">Let us start</h3>
<p>We start by giving the main architecture of our program:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- GLUT need to be initialized</span>
  (progname,_) <span class="ot">&lt;-</span> getArgsAndInitialize
  <span class="co">-- We will use the double buffered mode (GL constraint)</span>
  initialDisplayMode <span class="fu">$=</span> [<span class="dt">DoubleBuffered</span>]
  <span class="co">-- We create a window with some title</span>
  createWindow <span class="st">&quot;Mandelbrot Set with Haskell and OpenGL&quot;</span>
  <span class="co">-- Each time we will need to update the display</span>
  <span class="co">-- we will call the function &#39;display&#39;</span>
  displayCallback <span class="fu">$=</span> display
  <span class="co">-- We enter the main loop</span>
  mainLoop</code></pre>
</div>
<p>Mainly, we initialize our OpenGL application. We declared that the function <code>display</code> will be used to render the graphics:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">display <span class="fu">=</span> <span class="kw">do</span>
  clear [<span class="dt">ColorBuffer</span>] <span class="co">-- make the window black</span>
  loadIdentity <span class="co">-- reset any transformation</span>
  preservingMatrix drawMandelbrot
  swapBuffers <span class="co">-- refresh screen</span></code></pre>
</div>
<p>Also here, there is only one interesting line; the draw will occur in the function <code>drawMandelbrot</code>.</p>
<p>This function will provide a list of draw actions. Remember that OpenGL is imperative by design. Then, one of the consequence is you must write the actions in the right order. No easy parallel drawing here. Here is the function which will render something on the screen:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">drawMandelbrot <span class="fu">=</span>
  <span class="co">-- We will print Points (not triangles for example) </span>
  renderPrimitive <span class="dt">Points</span> <span class="fu">$</span> <span class="kw">do</span>
    mapM_ drawColoredPoint allPoints
  <span class="kw">where</span>
      drawColoredPoint (x,y,c) <span class="fu">=</span> <span class="kw">do</span>
          color c <span class="co">-- set the current color to c</span>
          <span class="co">-- then draw the point at position (x,y,0)</span>
          <span class="co">-- remember we&#39;re in 3D</span>
          vertex <span class="fu">$</span> <span class="dt">Vertex3</span> x y <span class="dv">0</span> </code></pre>
</div>
<p>The <code>mapM_</code> function is mainly the same as map but inside a monadic context. More precisely, this can be transformed as a list of actions where the order is important:</p>
<pre><code>drawMandelbrot = 
  renderPrimitive Points $ do
    color color1
    vertex $ Vertex3 x1 y1 0
    ...
    color colorN
    vertex $ Vertex3 xN yN 0</code></pre>
<p>We also need some kind of global variables. In fact, global variable are a proof of a design problem. We will get rid of them later.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">width <span class="fu">=</span> <span class="dv">320</span><span class="ot"> ::</span> <span class="dt">GLfloat</span>
height <span class="fu">=</span> <span class="dv">320</span><span class="ot"> ::</span> <span class="dt">GLfloat</span></code></pre>
</div>
<p>And of course our list of colored points. In OpenGL the default coordinate are from -1 to 1.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allPoints ::</span> [(<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>,<span class="dt">Color3</span> <span class="dt">GLfloat</span>)]
allPoints <span class="fu">=</span> [ (x<span class="fu">/</span>width,y<span class="fu">/</span>height,colorFromValue <span class="fu">$</span> mandel x y) <span class="fu">|</span> 
                  x <span class="ot">&lt;-</span> [<span class="fu">-</span>width<span class="fu">..</span>width], 
                  y <span class="ot">&lt;-</span> [<span class="fu">-</span>height<span class="fu">..</span>height]]</code></pre>
</div>
<p>We need a function which transform an integer value to some color:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">colorFromValue n <span class="fu">=</span>
  <span class="kw">let</span> 
<span class="ot">      t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
      t i <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">5</span> <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">5</span><span class="fu">*</span>cos( fromIntegral i <span class="fu">/</span> <span class="dv">10</span> )
  <span class="kw">in</span>
    <span class="dt">Color3</span> (t n) (t (n<span class="fu">+</span><span class="dv">5</span>)) (t (n<span class="fu">+</span><span class="dv">10</span>))</code></pre>
</div>
<p>And now the <code>mandel</code> function. Given two coordinates in pixels, it returns some integer value:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">mandel x y <span class="fu">=</span> 
  <span class="kw">let</span> r <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> x <span class="fu">/</span> width
      i <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> y <span class="fu">/</span> height
  <span class="kw">in</span>
      f (complex r i) <span class="dv">0</span> <span class="dv">64</span></code></pre>
</div>
<p>It uses the main Mandelbrot function for each complex \(c\). The Mandelbrot set is the set of complex number \(c\) such that the following sequence does not escape to infinity.</p>
<p>Let us define \(f_c:  \)</p>
<p><br /><span class="math"><em>f</em><sub><em>c</em></sub>(<em>z</em>) = <em>z</em><sup>2</sup> + <em>c</em></span><br /></p>
<p>The sequence is:</p>
<p><br /><span class="math">0 → <em>f</em><sub><em>c</em></sub>(0) → <em>f</em><sub><em>c</em></sub>(<em>f</em><sub><em>c</em></sub>(0)) → ⋯ → <em>f</em><sub><em>c</em></sub><sup><em>n</em></sup>(0) → ⋯</span><br /></p>
<p>Of course, instead of trying to test the real limit, we just make a test after a finite number of occurrences.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f c z <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
f c z n <span class="fu">=</span> <span class="kw">if</span> (magnitude z <span class="fu">&gt;</span> <span class="dv">2</span> ) 
          <span class="kw">then</span> n
          <span class="kw">else</span> f c ((z<span class="fu">*</span>z)<span class="fu">+</span>c) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre>
</div>
<p>Well, if you download this file (look at the bottom of this section), compile it and run it this is the result:</p>
<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/hglmandel_v01.png" alt="The mandelbrot set version 1"/>
</div>
<p>A first very interesting property of this program is that the computation for all the points is done only once. It is a bit long before the first image appears, but if you resize the window, it updates instantaneously. This property is a direct consequence of purity. If you look closely, you see that <code>allPoints</code> is a pure list. Therefore, calling <code>allPoints</code> will always render the same result and Haskell is clever enough to use this property. While Haskell doesn’t garbage collect <code>allPoints</code> the result is reused for free. We did not specified this value should be saved for later use. It is saved for us.</p>
<p>See what occurs if we make the window bigger:</p>
<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/hglmandel_v01_too_wide.png" alt="The mandelbrot too wide, black lines and columns"/>
</div>
<p>We see some black lines because we have drawn less point than there is on the surface. We can repair this by drawing little squares instead of just points. But, instead we will do something a bit different and unusual.</p>
<p><a href="code/01_Introduction/hglmandel.lhs" class="cut">Download the source code of this section → 01_Introduction/<strong>hglmandel.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Edges/HGLMandelEdge.lhs" class="cut">Download the source code of this section → 02_Edges/<strong>HGLMandelEdge.lhs</strong></a></p>
<h2 id="only-the-edges">Only the edges</h2>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Graphics.Rendering.OpenGL</span>
<span class="kw">import </span><span class="dt">Graphics.UI.GLUT</span>
<span class="kw">import </span><span class="dt">Data.IORef</span>
<span class="co">-- Use UNPACK data because it is faster</span>
<span class="co">-- The ! is for strict instead of lazy</span>
<span class="kw">data</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">C</span>  <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Float</span> 
                  <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Float</span> 
               <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Complex</span> <span class="kw">where</span>
    fromInteger n <span class="fu">=</span> <span class="dt">C</span> (fromIntegral n) <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span>
    (<span class="dt">C</span> x y) <span class="fu">*</span> (<span class="dt">C</span> z t) <span class="fu">=</span> <span class="dt">C</span> (z<span class="fu">*</span>x <span class="fu">-</span> y<span class="fu">*</span>t) (y<span class="fu">*</span>z <span class="fu">+</span> x<span class="fu">*</span>t)
    (<span class="dt">C</span> x y) <span class="fu">+</span> (<span class="dt">C</span> z t) <span class="fu">=</span> <span class="dt">C</span> (x<span class="fu">+</span>z) (y<span class="fu">+</span>t)
    abs (<span class="dt">C</span> x y)     <span class="fu">=</span> <span class="dt">C</span> (sqrt (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y)) <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span>
    signum (<span class="dt">C</span> x y)  <span class="fu">=</span> <span class="dt">C</span> (signum x) <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span>
<span class="ot">complex ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span>
complex x y <span class="fu">=</span> <span class="dt">C</span> x y

<span class="ot">real ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
real (<span class="dt">C</span> x y)    <span class="fu">=</span> x

<span class="ot">im ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
im   (<span class="dt">C</span> x y)    <span class="fu">=</span> y

<span class="ot">magnitude ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Float</span>
magnitude <span class="fu">=</span> real<span class="fu">.</span>abs
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- GLUT need to be initialized</span>
  (progname,_) <span class="ot">&lt;-</span> getArgsAndInitialize
  <span class="co">-- We will use the double buffered mode (GL constraint)</span>
  initialDisplayMode <span class="fu">$=</span> [<span class="dt">DoubleBuffered</span>]
  <span class="co">-- We create a window with some title</span>
  createWindow <span class="st">&quot;Mandelbrot Set with Haskell and OpenGL&quot;</span>
  <span class="co">-- Each time we will need to update the display</span>
  <span class="co">-- we will call the function &#39;display&#39;</span>
  displayCallback <span class="fu">$=</span> display
  <span class="co">-- We enter the main loop</span>
  mainLoop
display <span class="fu">=</span> <span class="kw">do</span>
   <span class="co">-- set the background color (dark solarized theme)</span>
  clearColor <span class="fu">$=</span> <span class="dt">Color4</span> <span class="dv">0</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">1686</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">2117</span> <span class="dv">1</span>
  clear [<span class="dt">ColorBuffer</span>] <span class="co">-- make the window black</span>
  loadIdentity <span class="co">-- reset any transformation</span>
  preservingMatrix drawMandelbrot
  swapBuffers <span class="co">-- refresh screen</span>

width <span class="fu">=</span> <span class="dv">320</span><span class="ot"> ::</span> <span class="dt">GLfloat</span>
height <span class="fu">=</span> <span class="dv">320</span><span class="ot"> ::</span> <span class="dt">GLfloat</span></code></pre>
</div>
</div>
<p>This time, instead of drawing all points, we will simply draw the edges of the Mandelbrot set. The method I use is a rough approximation. I consider the Mandelbrot set to be almost convex. The result will be good enough for the purpose of this tutorial.</p>
<p>We change slightly the <code>drawMandelbrot</code> function. We replace the <code>Points</code> by <code>LineLoop</code></p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">drawMandelbrot <span class="fu">=</span>
  <span class="co">-- We will print Points (not triangles for example) </span>
  renderPrimitive <span class="dt">LineLoop</span> <span class="fu">$</span> <span class="kw">do</span>
    mapM_ drawColoredPoint allPoints
  <span class="kw">where</span>
      drawColoredPoint (x,y,c) <span class="fu">=</span> <span class="kw">do</span>
          color c <span class="co">-- set the current color to c</span>
          <span class="co">-- then draw the point at position (x,y,0)</span>
          <span class="co">-- remember we&#39;re in 3D</span>
          vertex <span class="fu">$</span> <span class="dt">Vertex3</span> x y <span class="dv">0</span> </code></pre>
</div>
<p>And now, we should change our list of points. Instead of drawing every point of the visible surface, we will choose only point on the surface.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">allPoints <span class="fu">=</span> positivePoints <span class="fu">++</span> 
      map (\(x,y,c) <span class="ot">-&gt;</span> (x,<span class="fu">-</span>y,c)) (reverse positivePoints)</code></pre>
</div>
<p>We only need to compute the positive point. The Mandelbrot set is symmetric relatively to the abscisse axis.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">positivePoints ::</span> [(<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>,<span class="dt">Color3</span> <span class="dt">GLfloat</span>)]
positivePoints <span class="fu">=</span> <span class="kw">do</span>
     x <span class="ot">&lt;-</span> [<span class="fu">-</span>width<span class="fu">..</span>width]
     <span class="kw">let</span> y <span class="fu">=</span> maxZeroIndex (mandel x) <span class="dv">0</span> height (log2 height)
     <span class="kw">if</span> y <span class="fu">&lt;</span> <span class="dv">1</span> <span class="co">-- We don&#39;t draw point in the absciss</span>
        <span class="kw">then</span> []
        <span class="kw">else</span> return (x<span class="fu">/</span>width,y<span class="fu">/</span>height,colorFromValue <span class="fu">$</span> mandel x y)
     <span class="kw">where</span>
         log2 n <span class="fu">=</span> floor ((log n) <span class="fu">/</span> log <span class="dv">2</span>)</code></pre>
</div>
<p>This function is interesting. For those not used to the list monad here is a natural language version of this function:</p>
<pre class="no-highlight"><code>positivePoints =
    for all x in the range [-width..width]
    let y be smallest number s.t. mandel x y &gt; 0
    if y is on 0 then don&#39;t return a point
    else return the value corresonding to (x,y,color for (x+iy))</code></pre>
<p>In fact using the list monad you write like if you consider only one element at a time and the computation is done non deterministically. To find the smallest number such that <code>mandel x y &gt; 0</code> we use a simple dichotomy:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- given f min max nbtest,</span>
<span class="co">-- considering </span>
<span class="co">--  - f is an increasing function</span>
<span class="co">--  - f(min)=0</span>
<span class="co">--  - f(max)≠0</span>
<span class="co">-- then maxZeroIndex f min max nbtest returns x such that</span>
<span class="co">--    f(x - ε)=0 and f(x + ε)≠0</span>
<span class="co">--    where ε=(max-min)/2^(nbtest+1) </span>
maxZeroIndex func minval maxval <span class="dv">0</span> <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>
maxZeroIndex func minval maxval n <span class="fu">=</span> 
  <span class="kw">if</span> (func medpoint) <span class="fu">/=</span> <span class="dv">0</span> 
       <span class="kw">then</span> maxZeroIndex func minval medpoint (n<span class="fu">-</span><span class="dv">1</span>)
       <span class="kw">else</span> maxZeroIndex func medpoint maxval (n<span class="fu">-</span><span class="dv">1</span>)
  <span class="kw">where</span> medpoint <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span></code></pre>
</div>
<p>No rocket science here. See the result now:</p>
<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/HGLMandelEdges.png" alt="The edges of the mandelbrot set"/>
</div>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">colorFromValue n <span class="fu">=</span>
  <span class="kw">let</span> 
<span class="ot">      t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
      t i <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">5</span> <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">5</span><span class="fu">*</span>cos( fromIntegral i <span class="fu">/</span> <span class="dv">10</span> )
  <span class="kw">in</span>
    <span class="dt">Color3</span> (t n) (t (n<span class="fu">+</span><span class="dv">5</span>)) (t (n<span class="fu">+</span><span class="dv">10</span>))</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">mandel x y <span class="fu">=</span> 
  <span class="kw">let</span> r <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> x <span class="fu">/</span> width
      i <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> y <span class="fu">/</span> height
  <span class="kw">in</span>
      f (complex r i) <span class="dv">0</span> <span class="dv">64</span></code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Complex</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f c z <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
f c z n <span class="fu">=</span> <span class="kw">if</span> (magnitude z <span class="fu">&gt;</span> <span class="dv">2</span> ) 
          <span class="kw">then</span> n
          <span class="kw">else</span> f c ((z<span class="fu">*</span>z)<span class="fu">+</span>c) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre>
</div>
</div>
<p><a href="code/02_Edges/HGLMandelEdge.lhs" class="cut">Download the source code of this section → 02_Edges/<strong>HGLMandelEdge.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 03_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>
<h2 id="d-mandelbrot">3D Mandelbrot?</h2>
<p>Now we will we extend to a third dimension. But, there is no 3D equivalent to complex. In fact, the only extension known are quaternions (in 4D). As I know almost nothing about quaternions, I will use some extended complex, instead of using a 3D projection of quaternions. I am pretty sure this construction is not useful for numbers. But it will be enough for us to create something that look nice.</p>
<p>This section is quite long, but don’t be afraid, most of the code is some OpenGL boilerplate. If you just want to skim this section, here is a high level representation:</p>
<blockquote>
<ul>
<li><p>OpenGL Boilerplate</p></li>
<li>set some IORef (understand variables) for states<br /></li>
<li><p>Drawing:</p>
<ul>
<li>set doubleBuffer, handle depth, window size…</li>
<li>Use state to apply some transformations</li>
</ul></li>
<li><p>Keyboard: hitting some key change the state of IORef</p></li>
<li><p>Generate 3D Object</p></li>
</ul>
<p><sub>~</sub> allPoints :: [ColoredPoint]<br /> allPoints = for all (x,y), -width<x<width, 0<y<height
      Let z be the minimal depth such that
          mandel x y z > 0 add the points (x, y, z,color) (x,-y, z,color) (x, y,-z,color) (x,-y,-z,color) + neighbors to make triangles <sub>~</sub></p>
</blockquote>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Graphics.Rendering.OpenGL</span>
<span class="kw">import </span><span class="dt">Graphics.UI.GLUT</span>
<span class="kw">import </span><span class="dt">Data.IORef</span>
<span class="kw">type</span> <span class="dt">ColoredPoint</span> <span class="fu">=</span> (<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>,<span class="dt">Color3</span> <span class="dt">GLfloat</span>)</code></pre>
</div>
</div>
<p>We declare a new type <code>ExtComplex</code> (for extended complex). An extension of complex numbers with a third component:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ExtComplex</span> <span class="fu">=</span> <span class="dt">C</span> (<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>) 
                  <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)
<span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">ExtComplex</span> <span class="kw">where</span>
    <span class="co">-- The shape of the 3D mandelbrot </span>
    <span class="co">-- will depend on this formula</span>
    <span class="dt">C</span> (x,y,z) <span class="fu">*</span> <span class="dt">C</span> (x&#39;,y&#39;,z&#39;) <span class="fu">=</span> <span class="dt">C</span> (x<span class="fu">*</span>x&#39; <span class="fu">-</span> y<span class="fu">*</span>y&#39; <span class="fu">-</span> z<span class="fu">*</span>z&#39;, 
                                  x<span class="fu">*</span>y&#39; <span class="fu">+</span> y<span class="fu">*</span>x&#39; <span class="fu">+</span> z<span class="fu">*</span>z&#39;, 
                                  x<span class="fu">*</span>z&#39; <span class="fu">+</span> z<span class="fu">*</span>x&#39; )
    <span class="co">-- The rest is straightforward</span>
    fromInteger n <span class="fu">=</span> <span class="dt">C</span> (fromIntegral n, <span class="dv">0</span>, <span class="dv">0</span>)
    <span class="dt">C</span> (x,y,z) <span class="fu">+</span> <span class="dt">C</span> (x&#39;,y&#39;,z&#39;) <span class="fu">=</span> <span class="dt">C</span> (x<span class="fu">+</span>x&#39;, y<span class="fu">+</span>y&#39;, z<span class="fu">+</span>z&#39;)
    abs (<span class="dt">C</span> (x,y,z))     <span class="fu">=</span> <span class="dt">C</span> (sqrt (x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y <span class="fu">+</span> z<span class="fu">*</span>z), <span class="dv">0</span>, <span class="dv">0</span>)
    signum (<span class="dt">C</span> (x,y,z))  <span class="fu">=</span> <span class="dt">C</span> (signum x, signum y, signum z)</code></pre>
</div>
<p>The most important part is the new multiplication instance. Modifying this formula will change radically the shape of the result. Here is the formula written in a more mathematical notation. I called the third component of these extended complex <em>strange</em>.</p>
<p><br /><span class="math">real((<em>x</em>, <em>y</em>, <em>z</em>) * (<em>x</em>ʹ, <em>y</em>ʹ, <em>z</em>ʹ)) = <em>x</em><em>x</em>ʹ − <em>y</em><em>y</em>ʹ − <em>z</em><em>z</em>ʹ</span><br /></p>
<p><br /><span class="math">im((<em>x</em>, <em>y</em>, <em>z</em>) * (<em>x</em>ʹ, <em>y</em>ʹ, <em>z</em>ʹ)) = <em>x</em><em>y</em>ʹ − <em>y</em><em>x</em>ʹ + <em>z</em><em>z</em>ʹ</span><br /></p>
<p><br /><span class="math">strange((<em>x</em>, <em>y</em>, <em>z</em>) * (<em>x</em>ʹ, <em>y</em>ʹ, <em>z</em>ʹ)) = <em>x</em><em>z</em>ʹ + <em>z</em><em>x</em>ʹ</span><br /></p>
<p>Note how if <code>z=z'=0</code> then the multiplication is the same to the complex one.</p>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extcomplex ::</span> <span class="dt">GLfloat</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span> <span class="ot">-&gt;</span> <span class="dt">ExtComplex</span>
extcomplex x y z <span class="fu">=</span> <span class="dt">C</span> (x,y,z)

<span class="ot">real ::</span> <span class="dt">ExtComplex</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
real (<span class="dt">C</span> (x,y,z))    <span class="fu">=</span> x

<span class="ot">im ::</span> <span class="dt">ExtComplex</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
im   (<span class="dt">C</span> (x,y,z))    <span class="fu">=</span> y

<span class="ot">strange ::</span> <span class="dt">ExtComplex</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
strange (<span class="dt">C</span> (x,y,z)) <span class="fu">=</span> z

<span class="ot">magnitude ::</span> <span class="dt">ExtComplex</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
magnitude <span class="fu">=</span> real<span class="fu">.</span>abs</code></pre>
</div>
</div>
<h3 id="from-2d-to-3d">From 2D to 3D</h3>
<p>As we will use some 3D, we add some new directive in the boilerplate. But mainly, we simply state that will use some depth buffer. And also we will listen the keyboard.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- GLUT need to be initialized</span>
  (progname,_) <span class="ot">&lt;-</span> getArgsAndInitialize
  <span class="co">-- We will use the double buffered mode (GL constraint)</span>
  <span class="co">-- We also Add the DepthBuffer (for 3D)</span>
  initialDisplayMode <span class="fu">$=</span> 
      [<span class="dt">WithDepthBuffer</span>,<span class="dt">DoubleBuffered</span>,<span class="dt">RGBMode</span>]
  <span class="co">-- We create a window with some title</span>
  createWindow <span class="st">&quot;3D HOpengGL Mandelbrot&quot;</span>
  <span class="co">-- We add some directives</span>
  depthFunc  <span class="fu">$=</span> <span class="dt">Just</span> <span class="dt">Less</span>
  windowSize <span class="fu">$=</span> <span class="dt">Size</span> <span class="dv">500</span> <span class="dv">500</span>
  <span class="co">-- Some state variables (I know it feels BAD)</span>
  angle   <span class="ot">&lt;-</span> newIORef ((<span class="dv">35</span>,<span class="dv">0</span>)<span class="ot">::</span>(<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>))
  zoom    <span class="ot">&lt;-</span> newIORef (<span class="dv">2</span><span class="ot">::</span><span class="dt">GLfloat</span>)
  campos  <span class="ot">&lt;-</span> newIORef ((<span class="dv">0</span><span class="fu">.</span><span class="dv">7</span>,<span class="dv">0</span>)<span class="ot">::</span>(<span class="dt">GLfloat</span>,<span class="dt">GLfloat</span>))
  <span class="co">-- Function to call each frame</span>
  idleCallback <span class="fu">$=</span> <span class="dt">Just</span> idle
  <span class="co">-- Function to call when keyboard or mouse is used</span>
  keyboardMouseCallback <span class="fu">$=</span> 
          <span class="dt">Just</span> (keyboardMouse angle zoom campos)
  <span class="co">-- Each time we will need to update the display</span>
  <span class="co">-- we will call the function &#39;display&#39;</span>
  <span class="co">-- But this time, we add some parameters</span>
  displayCallback <span class="fu">$=</span> display angle zoom campos
  <span class="co">-- We enter the main loop</span>
  mainLoop</code></pre>
</div>
<p>The <code>idle</code> is here to change the states. There should never be any modification done in the <code>display</code> function.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">idle <span class="fu">=</span> postRedisplay <span class="dt">Nothing</span></code></pre>
</div>
<p>We introduce some helper function to manipulate standard <code>IORef</code>. Mainly <code>modVar x f</code> is equivalent to the imperative <code>x:=f(x)</code>, <code>modFst (x,y) (+1)</code> is equivalent to <code>(x,y) := (x+1,y)</code> and <code>modSnd (x,y) (+1)</code> is equivalent to <code>(x,y) := (x,y+1)</code></p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">modVar v f <span class="fu">=</span> <span class="kw">do</span>
  v&#39; <span class="ot">&lt;-</span> get v
  v <span class="fu">$=</span> (f v&#39;)
mapFst f (x,y) <span class="fu">=</span> (f x,  y)
mapSnd f (x,y) <span class="fu">=</span> (  x,f y)</code></pre>
</div>
<p>And we use them to code the function handling keyboard. We will use the keys <code>hjkl</code> to rotate, <code>oi</code> to zoom and <code>sedf</code> to move. Also, hitting space will reset the view. Remember that <code>angle</code> and <code>campos</code> are pairs and <code>zoom</code> is a scalar. Also note <code>(+0.5)</code> is the function <code>\x-&gt;x+0.5</code> and <code>(-0.5)</code> is the number <code>-0.5</code> (yes I share your pain).</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">keyboardMouse angle zoom campos key state modifiers position <span class="fu">=</span>
  <span class="co">-- We won&#39;t use modifiers nor position</span>
  kact angle zoom campos key state
  <span class="kw">where</span> 
    <span class="co">-- reset view when hitting space</span>
    kact a z p (<span class="dt">Char</span> <span class="ch">&#39; &#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> <span class="kw">do</span>
          a <span class="fu">$=</span> (<span class="dv">0</span>,<span class="dv">0</span>) <span class="co">-- angle </span>
          z <span class="fu">$=</span> <span class="dv">1</span>     <span class="co">-- zoom</span>
          p <span class="fu">$=</span> (<span class="dv">0</span>,<span class="dv">0</span>) <span class="co">-- camera position</span>
    <span class="co">-- use of hjkl to rotate</span>
    kact a _ _ (<span class="dt">Char</span> <span class="ch">&#39;h&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar a (mapFst (<span class="fu">+</span><span class="dv">0</span><span class="fu">.</span><span class="dv">5</span>))
    kact a _ _ (<span class="dt">Char</span> <span class="ch">&#39;l&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar a (mapFst (<span class="fu">+</span>(<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">5</span>)))
    kact a _ _ (<span class="dt">Char</span> <span class="ch">&#39;j&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar a (mapSnd (<span class="fu">+</span><span class="dv">0</span><span class="fu">.</span><span class="dv">5</span>))
    kact a _ _ (<span class="dt">Char</span> <span class="ch">&#39;k&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar a (mapSnd (<span class="fu">+</span>(<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">5</span>)))
    <span class="co">-- use o and i to zoom</span>
    kact _ z _ (<span class="dt">Char</span> <span class="ch">&#39;o&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar z (<span class="fu">*</span><span class="dv">1</span><span class="fu">.</span><span class="dv">1</span>)
    kact _ z _ (<span class="dt">Char</span> <span class="ch">&#39;i&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar z (<span class="fu">*</span><span class="dv">0</span><span class="fu">.</span><span class="dv">9</span>)
    <span class="co">-- use sdfe to move the camera</span>
    kact _ _ p (<span class="dt">Char</span> <span class="ch">&#39;s&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar p (mapFst (<span class="fu">+</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    kact _ _ p (<span class="dt">Char</span> <span class="ch">&#39;f&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar p (mapFst (<span class="fu">+</span>(<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)))
    kact _ _ p (<span class="dt">Char</span> <span class="ch">&#39;d&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar p (mapSnd (<span class="fu">+</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    kact _ _ p (<span class="dt">Char</span> <span class="ch">&#39;e&#39;</span>) <span class="dt">Down</span> <span class="fu">=</span> modVar p (mapSnd (<span class="fu">+</span>(<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)))
    <span class="co">-- any other keys does nothing</span>
    kact _ _ _ _ _ <span class="fu">=</span> return ()</code></pre>
</div>
<p>Note <code>display</code> takes some parameters this time. This function if full of boilerplate:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">display angle zoom position <span class="fu">=</span> <span class="kw">do</span>
   <span class="co">-- set the background color (dark solarized theme)</span>
  clearColor <span class="fu">$=</span> <span class="dt">Color4</span> <span class="dv">0</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">1686</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">2117</span> <span class="dv">1</span>
  clear [<span class="dt">ColorBuffer</span>,<span class="dt">DepthBuffer</span>]
  <span class="co">-- Transformation to change the view</span>
  loadIdentity <span class="co">-- reset any transformation</span>
  <span class="co">-- tranlate</span>
  (x,y) <span class="ot">&lt;-</span> get position
  translate <span class="fu">$</span> <span class="dt">Vector3</span> x y <span class="dv">0</span> 
  <span class="co">-- zoom</span>
  z <span class="ot">&lt;-</span> get zoom
  scale z z z
  <span class="co">-- rotate</span>
  (xangle,yangle) <span class="ot">&lt;-</span> get angle
  rotate xangle <span class="fu">$</span> <span class="dt">Vector3</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span> (<span class="dv">0</span><span class="fu">.</span><span class="dv">0</span><span class="ot">::</span><span class="dt">GLfloat</span>)
  rotate yangle <span class="fu">$</span> <span class="dt">Vector3</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span> (<span class="dv">0</span><span class="fu">.</span><span class="dv">0</span><span class="ot">::</span><span class="dt">GLfloat</span>)

  <span class="co">-- Now that all transformation were made</span>
  <span class="co">-- We create the object(s)</span>
  preservingMatrix drawMandelbrot

  swapBuffers <span class="co">-- refresh screen</span></code></pre>
</div>
<p>Not much to say about this function. Mainly there are two parts: apply some transformations, draw the object.</p>
<h3 id="the-3d-mandelbrot">The 3D Mandelbrot</h3>
<p>We have finished with the OpenGL section, let’s talk about how we generate the 3D points and colors. First, we will set the number of details to 200 pixels in the three dimensions.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">nbDetails <span class="fu">=</span> <span class="dv">200</span><span class="ot"> ::</span> <span class="dt">GLfloat</span>
width  <span class="fu">=</span> nbDetails
height <span class="fu">=</span> nbDetails
deep   <span class="fu">=</span> nbDetails</code></pre>
</div>
<p>This time, instead of just drawing some line or some group of points, we will show triangles. The function <code>allPoints</code> will provide a multiple of three points. Each three successive point representing the coordinate of each vertex of a triangle.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">drawMandelbrot <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- We will print Points (not triangles for example) </span>
  renderPrimitive <span class="dt">Triangles</span> <span class="fu">$</span> <span class="kw">do</span>
    mapM_ drawColoredPoint allPoints
  <span class="kw">where</span>
      drawColoredPoint (x,y,z,c) <span class="fu">=</span> <span class="kw">do</span>
          color c
          vertex <span class="fu">$</span> <span class="dt">Vertex3</span> x y z</code></pre>
</div>
<p>In fact, we will provide six ordered points. These points will be used to draw two triangles.</p>
<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/triangles.png" alt="Explain triangles"/>
</div>
<p>The next function is a bit long. Here is an approximative English version:</p>
<pre><code>forall x from -width to width
  forall y from -height to height
    forall the neighbors of (x,y)
      let z be the smalled depth such that (mandel x y z)&gt;0
      let c be the color given by mandel x y z 
      add the point corresponding to (x,y,z,c)</code></pre>
<p>Also, I added a test to hide points too far from the border. In fact, this function show points close to the surface of the modified mandelbrot set. But not the mandelbrot set itself.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">depthPoints ::</span> [<span class="dt">ColoredPoint</span>]
depthPoints <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> [<span class="fu">-</span>width<span class="fu">..</span>width]
  y <span class="ot">&lt;-</span> [<span class="fu">-</span>height<span class="fu">..</span>height]
  <span class="kw">let</span> 
      depthOf x&#39; y&#39; <span class="fu">=</span> maxZeroIndex (mandel x&#39; y&#39;) <span class="dv">0</span> deep logdeep 
      logdeep <span class="fu">=</span> floor ((log deep) <span class="fu">/</span> log <span class="dv">2</span>)
      z1 <span class="fu">=</span> depthOf    x     y
      z2 <span class="fu">=</span> depthOf (x<span class="fu">+</span><span class="dv">1</span>)    y
      z3 <span class="fu">=</span> depthOf (x<span class="fu">+</span><span class="dv">1</span>) (y<span class="fu">+</span><span class="dv">1</span>)
      z4 <span class="fu">=</span> depthOf    x  (y<span class="fu">+</span><span class="dv">1</span>)
      c1 <span class="fu">=</span> mandel    x     y  (z1<span class="fu">+</span><span class="dv">1</span>)
      c2 <span class="fu">=</span> mandel (x<span class="fu">+</span><span class="dv">1</span>)    y  (z2<span class="fu">+</span><span class="dv">1</span>)
      c3 <span class="fu">=</span> mandel (x<span class="fu">+</span><span class="dv">1</span>) (y<span class="fu">+</span><span class="dv">1</span>) (z3<span class="fu">+</span><span class="dv">1</span>)
      c4 <span class="fu">=</span> mandel    x  (y<span class="fu">+</span><span class="dv">1</span>) (z4<span class="fu">+</span><span class="dv">1</span>)
      p1 <span class="fu">=</span> (   x <span class="fu">/</span>width,   y <span class="fu">/</span>height, z1<span class="fu">/</span>deep, colorFromValue c1)
      p2 <span class="fu">=</span> ((x<span class="fu">+</span><span class="dv">1</span>)<span class="fu">/</span>width,   y <span class="fu">/</span>height, z2<span class="fu">/</span>deep, colorFromValue c2)
      p3 <span class="fu">=</span> ((x<span class="fu">+</span><span class="dv">1</span>)<span class="fu">/</span>width,(y<span class="fu">+</span><span class="dv">1</span>)<span class="fu">/</span>height, z3<span class="fu">/</span>deep, colorFromValue c3)
      p4 <span class="fu">=</span> (   x <span class="fu">/</span>width,(y<span class="fu">+</span><span class="dv">1</span>)<span class="fu">/</span>height, z4<span class="fu">/</span>deep, colorFromValue c4)
  <span class="kw">if</span> (and <span class="fu">$</span> map (<span class="fu">&gt;=</span><span class="dv">57</span>) [c1,c2,c3,c4])
  <span class="kw">then</span> []
  <span class="kw">else</span> [p1,p2,p3,p1,p3,p4]</code></pre>
<p>If you look at the function above, you see a lot of common patterns. Haskell is very efficient to make this better. Here is a harder to read but shorter and more generic rewritten function:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">depthPoints ::</span> [<span class="dt">ColoredPoint</span>]
depthPoints <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> [<span class="fu">-</span>width<span class="fu">..</span>width]
  y <span class="ot">&lt;-</span> [<span class="fu">-</span>height<span class="fu">..</span>height]
  <span class="kw">let</span> 
    neighbors <span class="fu">=</span> [(x,y),(x<span class="fu">+</span><span class="dv">1</span>,y),(x<span class="fu">+</span><span class="dv">1</span>,y<span class="fu">+</span><span class="dv">1</span>),(x,y<span class="fu">+</span><span class="dv">1</span>)]
    depthOf (u,v) <span class="fu">=</span> maxZeroIndex (mandel u v) <span class="dv">0</span> deep logdeep
    logdeep <span class="fu">=</span> floor ((log deep) <span class="fu">/</span> log <span class="dv">2</span>)
    <span class="co">-- zs are 3D points with found depth</span>
    zs <span class="fu">=</span> map (\(u,v) <span class="ot">-&gt;</span> (u,v,depthOf (u,v))) neighbors
    <span class="co">-- ts are 3D pixels + mandel value</span>
    ts <span class="fu">=</span> map (\(u,v,w) <span class="ot">-&gt;</span> (u,v,w,mandel u v (w<span class="fu">+</span><span class="dv">1</span>))) zs
    <span class="co">-- ps are 3D opengl points + color value</span>
    ps <span class="fu">=</span> map (\(u,v,w,c&#39;) <span class="ot">-&gt;</span> 
        (u<span class="fu">/</span>width,v<span class="fu">/</span>height,w<span class="fu">/</span>deep,colorFromValue c&#39;)) ts
  <span class="co">-- If the point diverged too fast, don&#39;t display it</span>
  <span class="kw">if</span> (and <span class="fu">$</span> map (\(_,_,_,c) <span class="ot">-&gt;</span> c<span class="fu">&gt;=</span><span class="dv">57</span>) ts)
  <span class="kw">then</span> []
  <span class="co">-- Draw two triangles</span>
  <span class="kw">else</span> [ps<span class="fu">!!</span><span class="dv">0</span>,ps<span class="fu">!!</span><span class="dv">1</span>,ps<span class="fu">!!</span><span class="dv">2</span>,ps<span class="fu">!!</span><span class="dv">0</span>,ps<span class="fu">!!</span><span class="dv">2</span>,ps<span class="fu">!!</span><span class="dv">3</span>]</code></pre>
</div>
<p>If you prefer the first version, then just imagine how hard it will be to change the enumeration of the point from (x,y) to (x,z) for example.</p>
<p>Also, we didn’t searched for negative values. This modified Mandelbrot is no more symmetric relatively to the plan <code>y=0</code>. But it is symmetric relatively to the plan <code>z=0</code>. Then I mirror these values.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allPoints ::</span> [<span class="dt">ColoredPoint</span>]
allPoints <span class="fu">=</span> planPoints <span class="fu">++</span> map inverseDepth  planPoints
  <span class="kw">where</span> 
      planPoints <span class="fu">=</span> depthPoints
      inverseDepth (x,y,z,c) <span class="fu">=</span> (x,y,<span class="fu">-</span>z<span class="fu">+</span><span class="dv">1</span><span class="fu">/</span>deep,c)</code></pre>
</div>
<p>The rest of the program is very close to the preceding one.</p>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- given f min max nbtest,</span>
<span class="co">-- considering </span>
<span class="co">--  - f is an increasing function</span>
<span class="co">--  - f(min)=0</span>
<span class="co">--  - f(max)≠0</span>
<span class="co">-- then maxZeroIndex f min max nbtest returns x such that</span>
<span class="co">--    f(x - ε)=0 and f(x + ε)≠0</span>
<span class="co">--    where ε=(max-min)/2^(nbtest+1) </span>
<span class="ot">maxZeroIndex ::</span> (<span class="dt">Fractional</span> a,<span class="dt">Num</span> a,<span class="dt">Num</span> b,<span class="dt">Eq</span> b) <span class="ot">=&gt;</span> 
                 (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
maxZeroIndex func minval maxval <span class="dv">0</span> <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>
maxZeroIndex func minval maxval n <span class="fu">=</span> 
  <span class="kw">if</span> (func medpoint) <span class="fu">/=</span> <span class="dv">0</span> 
       <span class="kw">then</span> maxZeroIndex func minval medpoint (n<span class="fu">-</span><span class="dv">1</span>)
       <span class="kw">else</span> maxZeroIndex func medpoint maxval (n<span class="fu">-</span><span class="dv">1</span>)
  <span class="kw">where</span> medpoint <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span></code></pre>
</div>
<p>I made the color slightly brighter</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">colorFromValue n <span class="fu">=</span>
  <span class="kw">let</span> 
<span class="ot">      t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
      t i <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">7</span> <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span><span class="fu">*</span>cos( fromIntegral i <span class="fu">/</span> <span class="dv">10</span> )
  <span class="kw">in</span>
    <span class="dt">Color3</span> (t n) (t (n<span class="fu">+</span><span class="dv">5</span>)) (t (n<span class="fu">+</span><span class="dv">10</span>))</code></pre>
</div>
<p>We only changed from <code>Complex</code> to <code>ExtComplex</code> of the main <code>f</code> function.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">ExtComplex</span> <span class="ot">-&gt;</span> <span class="dt">ExtComplex</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f c z <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
f c z n <span class="fu">=</span> <span class="kw">if</span> (magnitude z <span class="fu">&gt;</span> <span class="dv">2</span> ) 
          <span class="kw">then</span> n
          <span class="kw">else</span> f c ((z<span class="fu">*</span>z)<span class="fu">+</span>c) (n<span class="fu">-</span><span class="dv">1</span>)</code></pre>
</div>
</div>
<p>We simply add a new dimension to the <code>mandel</code> function and change the type signature of <code>f</code> from <code>Complex</code> to <code>ExtComplex</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">mandel x y z <span class="fu">=</span> 
  <span class="kw">let</span> r <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> x <span class="fu">/</span> width
      i <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> y <span class="fu">/</span> height
      s <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">*</span> z <span class="fu">/</span> deep
  <span class="kw">in</span>
      f (extcomplex r i s) <span class="dv">0</span> <span class="dv">64</span></code></pre>
</div>
<p>Here is the result:</p>
<div>
<img src="/Scratch/img/blog/Haskell-OpenGL-Mandelbrot/mandelbrot_3D.png" alt="A 3D mandelbrot like"/>
</div>
<p><a href="code/03_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 03_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>
<hr/>
<p><a href="code/04_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 04_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>
<h2 id="naïve-code-cleaning">Naïve code cleaning</h2>
<p>The first approach to clean the code is to separate the GLUT/OpenGL part from the computation of the shape. Here is the cleaned version of the preceding section. Most boilerplate was put in external files.</p>
<ul>
<li><a href="code/04_Mandelbulb/YBoiler.hs"><code>YBoiler.hs</code></a>, the 3D rendering</li>
<li><a href="code/04_Mandelbulb/Mandel.hs"><code>Mandel</code></a>, the mandel function</li>
<li><a href="code/04_Mandelbulb/ExtComplex.hs"><code>ExtComplex</code></a>, the extended complexes</li>
</ul>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">YBoiler</span> <span class="co">-- Most the OpenGL Boilerplate</span>
<span class="kw">import </span><span class="dt">Mandel</span> <span class="co">-- The 3D Mandelbrot maths</span></code></pre>
</div>
<p>The <code>yMainLoop</code> takes two arguments: the title of the window and a function from time to triangles</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> yMainLoop <span class="st">&quot;3D Mandelbrot&quot;</span> (\_ <span class="ot">-&gt;</span> allPoints)</code></pre>
</div>
<p>We set some global constant (this is generally bad).</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">nbDetails <span class="fu">=</span> <span class="dv">200</span><span class="ot"> ::</span> <span class="dt">GLfloat</span>
width  <span class="fu">=</span> nbDetails
height <span class="fu">=</span> nbDetails
deep   <span class="fu">=</span> nbDetails</code></pre>
</div>
<p>We then generate colored points from our function. This is similar to the preceding section.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">allPoints ::</span> [<span class="dt">ColoredPoint</span>]
allPoints <span class="fu">=</span> planPoints <span class="fu">++</span> map inverseDepth  planPoints
  <span class="kw">where</span> 
      planPoints <span class="fu">=</span> depthPoints <span class="fu">++</span> map inverseHeight depthPoints
      inverseHeight (x,y,z,c) <span class="fu">=</span> (x,<span class="fu">-</span>y,z,c)
      inverseDepth (x,y,z,c) <span class="fu">=</span> (x,y,<span class="fu">-</span>z<span class="fu">+</span><span class="dv">1</span><span class="fu">/</span>deep,c)</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">depthPoints ::</span> [<span class="dt">ColoredPoint</span>]
depthPoints <span class="fu">=</span> <span class="kw">do</span>
  x <span class="ot">&lt;-</span> [<span class="fu">-</span>width<span class="fu">..</span>width]
  y <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="fu">..</span>height]
  <span class="kw">let</span> 
    neighbors <span class="fu">=</span> [(x,y),(x<span class="fu">+</span><span class="dv">1</span>,y),(x<span class="fu">+</span><span class="dv">1</span>,y<span class="fu">+</span><span class="dv">1</span>),(x,y<span class="fu">+</span><span class="dv">1</span>)]
    depthOf (u,v) <span class="fu">=</span> maxZeroIndex (ymandel u v) <span class="dv">0</span> deep <span class="dv">7</span>
    <span class="co">-- zs are 3D points with found depth</span>
    zs <span class="fu">=</span> map (\(u,v) <span class="ot">-&gt;</span> (u,v,depthOf (u,v))) neighbors
    <span class="co">-- ts are 3D pixels + mandel value</span>
    ts <span class="fu">=</span> map (\(u,v,w) <span class="ot">-&gt;</span> (u,v,w,ymandel u v (w<span class="fu">+</span><span class="dv">1</span>))) zs
    <span class="co">-- ps are 3D opengl points + color value</span>
    ps <span class="fu">=</span> map (\(u,v,w,c&#39;) <span class="ot">-&gt;</span> 
        (u<span class="fu">/</span>width,v<span class="fu">/</span>height,w<span class="fu">/</span>deep,colorFromValue c&#39;)) ts
  <span class="co">-- If the point diverged too fast, don&#39;t display it</span>
  <span class="kw">if</span> (and <span class="fu">$</span> map (\(_,_,_,c) <span class="ot">-&gt;</span> c<span class="fu">&gt;=</span><span class="dv">57</span>) ts)
  <span class="kw">then</span> []
  <span class="co">-- Draw two triangles</span>
  <span class="kw">else</span> [ps<span class="fu">!!</span><span class="dv">0</span>,ps<span class="fu">!!</span><span class="dv">1</span>,ps<span class="fu">!!</span><span class="dv">2</span>,ps<span class="fu">!!</span><span class="dv">0</span>,ps<span class="fu">!!</span><span class="dv">2</span>,ps<span class="fu">!!</span><span class="dv">3</span>]

<span class="co">-- given f min max nbtest,</span>
<span class="co">-- considering </span>
<span class="co">--  - f is an increasing function</span>
<span class="co">--  - f(min)=0</span>
<span class="co">--  - f(max)≠0</span>
<span class="co">-- then maxZeroIndex f min max nbtest returns x such that</span>
<span class="co">--    f(x - ε)=0 and f(x + ε)≠0</span>
<span class="co">--    where ε=(max-min)/2^(nbtest+1) </span>
maxZeroIndex func minval maxval <span class="dv">0</span> <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>
maxZeroIndex func minval maxval n <span class="fu">=</span> 
  <span class="kw">if</span> (func medpoint) <span class="fu">/=</span> <span class="dv">0</span> 
       <span class="kw">then</span> maxZeroIndex func minval medpoint (n<span class="fu">-</span><span class="dv">1</span>)
       <span class="kw">else</span> maxZeroIndex func medpoint maxval (n<span class="fu">-</span><span class="dv">1</span>)
  <span class="kw">where</span> medpoint <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>

colorFromValue n <span class="fu">=</span>
  <span class="kw">let</span> 
<span class="ot">      t ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">GLfloat</span>
      t i <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">7</span> <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span><span class="fu">*</span>cos( fromIntegral i <span class="fu">/</span> <span class="dv">10</span> )
  <span class="kw">in</span>
    ((t n),(t (n<span class="fu">+</span><span class="dv">5</span>)),(t (n<span class="fu">+</span><span class="dv">10</span>)))

ymandel x y z <span class="fu">=</span> mandel (<span class="dv">2</span><span class="fu">*</span>x<span class="fu">/</span>width) (<span class="dv">2</span><span class="fu">*</span>y<span class="fu">/</span>height) (<span class="dv">2</span><span class="fu">*</span>z<span class="fu">/</span>deep) <span class="dv">64</span></code></pre>
</div>
<p>This code is cleaner but many things doesn’t feel right. First, all the user interaction code is outside our main file. I feel it is okay to hide the detail for the rendering. But I would have preferred to control the user actions.</p>
<p>On the other hand, we continue to handle a lot rendering details. For example, we provide ordered vertices.</p>
<p><a href="code/04_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 04_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>
<hr/>
<p><a href="code/05_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 05_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>
<h2 id="functional-organization">Functional organization?</h2>
<p>Some points:</p>
<ol style="list-style-type: decimal">
<li>OpenGL and GLUT is done in C. In particular the <code>mainLoop</code> function is a direct link to the C library (FFI). This function is clearly far from the functional paradigm. Could we make this better? We will have two choices:</li>
</ol>
<ul>
<li>create our own <code>mainLoop</code> function to make it more functional.</li>
<li>deal with the imperative nature of the GLUT <code>mainLoop</code> function.</li>
</ul>
<p>As one of the goal of this article is to understand how to deal with existing libraries and particularly the one coming from imperative languages, we will continue to use the <code>mainLoop</code> function. 2. Our main problem come from user interaction. If you ask “the Internet”, about how to deal with user interaction with a functional paradigm, the main answer is to use <em>functional reactive programming</em> (FRP). I won’t use FRP in this article. Instead, I’ll use a simpler while less effective way to deal with user interaction. But The method I’ll use will be as pure and functional as possible.</p>
<p>Here is how I imagine things should go. First, what the main loop should look like if we could make our own:</p>
<pre class="no-highlight"><code>functionalMainLoop =
    Read user inputs and provide a list of actions
    Apply all actions to the World
    Display one frame 
    repetere aeternum</code></pre>
<p>Clearly, ideally we should provide only three parameters to this main loop function:</p>
<ul>
<li>an initial World state</li>
<li>a mapping between the user interactions and functions which modify the world</li>
<li>a function taking two parameters: time and world state and render a new world without user interaction.</li>
</ul>
<p>Here is a real working code, I’ve hidden most display functions. The YGL, is a kind of framework to display 3D functions. But it can easily be extended to many kind of representation.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">YGL</span> <span class="co">-- Most the OpenGL Boilerplate</span>
<span class="kw">import </span><span class="dt">Mandel</span> <span class="co">-- The 3D Mandelbrot maths</span></code></pre>
</div>
<p>We first set the mapping between user input and actions. The type of each couple should be of the form <code>(user input, f)</code> where (in a first time) <code>f:World -&gt; World</code>. It means, the user input will transform the world state.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Centralize all user input interaction</span>
<span class="ot">inputActionMap ::</span> <span class="dt">InputMap</span> <span class="dt">World</span>
inputActionMap <span class="fu">=</span> inputMapFromList [
     (<span class="dt">Press</span> <span class="ch">&#39;k&#39;</span> , rotate xdir   <span class="dv">5</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;i&#39;</span> , rotate xdir (<span class="fu">-</span><span class="dv">5</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;j&#39;</span> , rotate ydir   <span class="dv">5</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;l&#39;</span> , rotate ydir (<span class="fu">-</span><span class="dv">5</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;o&#39;</span> , rotate zdir   <span class="dv">5</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;u&#39;</span> , rotate zdir (<span class="fu">-</span><span class="dv">5</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;f&#39;</span> , translate xdir   <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;s&#39;</span> , translate xdir (<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;e&#39;</span> , translate ydir   <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;d&#39;</span> , translate ydir (<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;z&#39;</span> , translate zdir   <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;r&#39;</span> , translate zdir (<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;+&#39;</span> , zoom    <span class="dv">1</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;-&#39;</span> , zoom (<span class="dv">1</span><span class="fu">/</span><span class="dv">1</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;h&#39;</span> , resize    <span class="dv">1</span><span class="fu">.</span><span class="dv">2</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;g&#39;</span> , resize (<span class="dv">1</span><span class="fu">/</span><span class="dv">1</span><span class="fu">.</span><span class="dv">2</span>))
    ]</code></pre>
</div>
<p>And of course a type design the World State. The important part is that it is our World State type. We could have used any kind of data type.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- I prefer to set my own name for these types</span>
<span class="kw">data</span> <span class="dt">World</span> <span class="fu">=</span> <span class="dt">World</span> {
<span class="ot">      angle       ::</span> <span class="dt">Point3D</span>
    ,<span class="ot"> scale       ::</span> <span class="dt">Scalar</span>
    ,<span class="ot"> position    ::</span> <span class="dt">Point3D</span>
    ,<span class="ot"> shape       ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">Function3D</span>
    ,<span class="ot"> box         ::</span> <span class="dt">Box3D</span>
    ,<span class="ot"> told        ::</span> <span class="dt">Time</span> <span class="co">-- last frame time</span>
    } </code></pre>
</div>
<p>The important part to glue our own type to the framework is to make our type an instance of the type class <code>DisplayableWorld</code>. We simply have to provide the definition of some functions.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">DisplayableWorld</span> <span class="dt">World</span> <span class="kw">where</span>
  winTitle _ <span class="fu">=</span> <span class="st">&quot;The YGL Mandelbulb&quot;</span>
  camera w <span class="fu">=</span> <span class="dt">Camera</span> {
        camPos <span class="fu">=</span> position w, 
        camDir <span class="fu">=</span> angle w,
        camZoom <span class="fu">=</span> scale w }
  <span class="co">-- objects for world w</span>
  <span class="co">-- is the list of one unique element</span>
  <span class="co">-- The element is an YObject</span>
  <span class="co">--   more precisely the XYFunc Function3D Box3D</span>
  <span class="co">--   where the Function3D is the type</span>
  <span class="co">--             Point -&gt; Point -&gt; Maybe (Point,Color)</span>
  <span class="co">--   and its value here is ((shape w) res)</span>
  <span class="co">--   and the Box3D value is defbox</span>
  objects w <span class="fu">=</span> [<span class="dt">XYFunc</span> ((shape  w) res) defbox]
              <span class="kw">where</span>
                  res <span class="fu">=</span> resolution <span class="fu">$</span> box w
                  defbox <span class="fu">=</span> box w</code></pre>
</div>
<p>The <code>camera</code> function will retrieve an object of type <code>Camera</code> which contains most necessary information to set our camera. The <code>objects</code> function will returns a list of objects. Their type is <code>YObject</code>. Note the generation of triangles is no more in this file. Until here we only used declarative pattern.</p>
<p>We also need to set all our transformation functions. These function are used to update the world state.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">xdir ::</span> <span class="dt">Point3D</span>
xdir <span class="fu">=</span> makePoint3D (<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>)
<span class="ot">ydir ::</span> <span class="dt">Point3D</span>
ydir <span class="fu">=</span> makePoint3D (<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>)
<span class="ot">zdir ::</span> <span class="dt">Point3D</span>
zdir <span class="fu">=</span> makePoint3D (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)</code></pre>
</div>
<p>Note <code>(-*&lt;)</code> is the scalar product (<code>α -*&lt; (x,y,z) = (αx,αy,αz)</code>). Also note we could add two Point3D.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rotate ::</span> <span class="dt">Point3D</span> <span class="ot">-&gt;</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
rotate dir angleValue world <span class="fu">=</span> 
  world {
     angle <span class="fu">=</span> (angle world) <span class="fu">+</span> (angleValue <span class="fu">-*&lt;</span> dir) }

<span class="ot">translate ::</span> <span class="dt">Point3D</span> <span class="ot">-&gt;</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
translate dir len world <span class="fu">=</span> 
  world {
    position <span class="fu">=</span> (position world) <span class="fu">+</span> (len <span class="fu">-*&lt;</span> dir) }

<span class="ot">zoom ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
zoom z world <span class="fu">=</span> world {
    scale <span class="fu">=</span> z <span class="fu">*</span> scale world }

<span class="ot">resize ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
resize r world <span class="fu">=</span> world {
    box <span class="fu">=</span> (box world) {
     resolution <span class="fu">=</span> sqrt ((resolution (box world))<span class="fu">**</span><span class="dv">2</span> <span class="fu">*</span> r) }}</code></pre>
</div>
<p>The resize is used to generate the 3D function. As I wanted the time spent to generate a more detailed view to grow linearly I use this not so straightforward formula.</p>
<p>The <code>yMainLoop</code> takes three arguments.</p>
<ul>
<li>A map between user Input and world transformation</li>
<li>A timed world transformation</li>
<li>An initial world state</li>
</ul>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> yMainLoop inputActionMap idleAction initialWorld</code></pre>
</div>
<p>Here is our initial world state.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- We initialize the world state</span>
<span class="co">-- then angle, position and zoom of the camera</span>
<span class="co">-- And the shape function</span>
<span class="ot">initialWorld ::</span> <span class="dt">World</span>
initialWorld <span class="fu">=</span> <span class="dt">World</span> {
   angle <span class="fu">=</span> makePoint3D (<span class="fu">-</span><span class="dv">30</span>,<span class="fu">-</span><span class="dv">30</span>,<span class="dv">0</span>)
 , position <span class="fu">=</span> makePoint3D (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)
 , scale <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">8</span>
 , shape <span class="fu">=</span> shapeFunc 
 , box <span class="fu">=</span> <span class="dt">Box3D</span> { minPoint <span class="fu">=</span> makePoint3D (<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>)
               , maxPoint <span class="fu">=</span>  makePoint3D (<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)
               , resolution <span class="fu">=</span>  <span class="dv">0</span><span class="fu">.</span><span class="dv">16</span> }
 , told <span class="fu">=</span> <span class="dv">0</span>
 }</code></pre>
</div>
<p>We will define <code>shapeFunc</code> later. Here is the function which transform the world even without user action. Mainly it makes some rotation.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idleAction ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
idleAction tnew world <span class="fu">=</span> world {
    angle <span class="fu">=</span> (angle world) <span class="fu">+</span> (delta <span class="fu">-*&lt;</span> zdir)
  , told <span class="fu">=</span> tnew
  }
  <span class="kw">where</span> 
      anglePerSec <span class="fu">=</span> <span class="dv">5</span><span class="fu">.</span><span class="dv">0</span>
      delta <span class="fu">=</span> anglePerSec <span class="fu">*</span> elapsed <span class="fu">/</span> <span class="dv">1000</span><span class="fu">.</span><span class="dv">0</span>
      elapsed <span class="fu">=</span> fromIntegral (tnew <span class="fu">-</span> (told world))</code></pre>
</div>
<p>Now the function which will generate points in 3D. The first parameter (<code>res</code>) is the resolution of the vertex generation. More precisely, <code>res</code> is distance between two points on one direction. We need it to “close” our shape.</p>
<p>The type <code>Function3D</code> is <code>Point -&gt; Point -&gt; Maybe Point</code>. Because we consider partial functions (for some <code>(x,y)</code> our function can be undefined).</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">shapeFunc ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">Function3D</span>
shapeFunc res x y <span class="fu">=</span> 
  <span class="kw">let</span> 
      z <span class="fu">=</span> maxZeroIndex (ymandel x y) <span class="dv">0</span> <span class="dv">1</span> <span class="dv">20</span>
  <span class="kw">in</span>
  <span class="kw">if</span> and [ maxZeroIndex (ymandel (x<span class="fu">+</span>xeps) (y<span class="fu">+</span>yeps)) <span class="dv">0</span> <span class="dv">1</span> <span class="dv">20</span> <span class="fu">&lt;</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">000001</span> <span class="fu">|</span>
              val <span class="ot">&lt;-</span> [res], xeps <span class="ot">&lt;-</span> [<span class="fu">-</span>val,val], yeps<span class="ot">&lt;-</span>[<span class="fu">-</span>val,val]]
      <span class="kw">then</span> <span class="dt">Nothing</span> 
      <span class="kw">else</span> <span class="dt">Just</span> (z,colorFromValue ((ymandel x y z) <span class="fu">*</span> <span class="dv">64</span>))</code></pre>
</div>
<p>With the color function.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">colorFromValue ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Color</span>
colorFromValue n <span class="fu">=</span>
  <span class="kw">let</span> 
<span class="ot">      t ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Scalar</span>
      t i <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">7</span> <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">3</span><span class="fu">*</span>cos( i <span class="fu">/</span> <span class="dv">10</span> )
  <span class="kw">in</span>
    makeColor (t n) (t (n<span class="fu">+</span><span class="dv">5</span>)) (t (n<span class="fu">+</span><span class="dv">10</span>))</code></pre>
</div>
<p>The rest is similar to the preceding sections.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- given f min max nbtest,</span>
<span class="co">-- considering </span>
<span class="co">--  - f is an increasing function</span>
<span class="co">--  - f(min)=0</span>
<span class="co">--  - f(max)≠0</span>
<span class="co">-- then maxZeroIndex f min max nbtest returns x such that</span>
<span class="co">--    f(x - ε)=0 and f(x + ε)≠0</span>
<span class="co">--    where ε=(max-min)/2^(nbtest+1) </span>
<span class="ot">maxZeroIndex ::</span> (<span class="dt">Fractional</span> a,<span class="dt">Num</span> a,<span class="dt">Num</span> b,<span class="dt">Eq</span> b) <span class="ot">=&gt;</span> 
                 (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
maxZeroIndex _ minval maxval <span class="dv">0</span> <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>
maxZeroIndex func minval maxval n <span class="fu">=</span> 
  <span class="kw">if</span> (func medpoint) <span class="fu">/=</span> <span class="dv">0</span> 
       <span class="kw">then</span> maxZeroIndex func minval medpoint (n<span class="fu">-</span><span class="dv">1</span>)
       <span class="kw">else</span> maxZeroIndex func medpoint maxval (n<span class="fu">-</span><span class="dv">1</span>)
  <span class="kw">where</span> medpoint <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>

<span class="ot">ymandel ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span>
ymandel x y z <span class="fu">=</span> fromIntegral (mandel x y z <span class="dv">64</span>) <span class="fu">/</span> <span class="dv">64</span></code></pre>
</div>
<p>I won’t explain how the magic occurs here. If you are interested, just read the file <a href="code/05_Mandelbulb/YGL.hs"><code>YGL.hs</code></a>. It is commented a lot.</p>
<ul>
<li><a href="code/05_Mandelbulb/YGL.hs"><code>YGL.hs</code></a>, the 3D rendering framework</li>
<li><a href="code/05_Mandelbulb/Mandel.hs"><code>Mandel</code></a>, the mandel function</li>
<li><a href="code/05_Mandelbulb/ExtComplex.hs"><code>ExtComplex</code></a>, the extended complexes</li>
</ul>
<p><a href="code/05_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 05_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>
<hr/>
<p><a href="code/06_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 06_Mandelbulb/<strong>Mandelbulb.lhs</strong></a></p>
<h2 id="optimization">Optimization</h2>
<p>Our code architecture feel very clean. All the meaningful code is in our main file and all display details are externalized. If you read the code of <code>YGL.hs</code>, you’ll see I didn’t made everything perfect. For example, I didn’t finished the code of the lights. But I believe it is a good first step and it will be easy to go further. Unfortunately the program of the preceding session is extremely slow. We compute the Mandelbulb for each frame now.</p>
<p>Before our program structure was:</p>
<pre class="no-highlight"><code>Constant Function -&gt; Constant List of Triangles -&gt; Display</code></pre>
<p>Now we have</p>
<pre class="no-highlight"><code>Main loop -&gt; World -&gt; Function -&gt; List of Objects -&gt; Atoms -&gt; Display</code></pre>
<p>The World state could change. The compiler can no more optimize the computation for us. We have to manually explain when to redraw the shape.</p>
<p>To optimize we must do some things in a lower level. Mostly the program remains the same, but it will provide the list of atoms directly.</p>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">YGL</span> <span class="co">-- Most the OpenGL Boilerplate</span>
<span class="kw">import </span><span class="dt">Mandel</span> <span class="co">-- The 3D Mandelbrot maths</span>

<span class="co">-- Centralize all user input interaction</span>
<span class="ot">inputActionMap ::</span> <span class="dt">InputMap</span> <span class="dt">World</span>
inputActionMap <span class="fu">=</span> inputMapFromList [
     (<span class="dt">Press</span> <span class="ch">&#39; &#39;</span> , switchRotation)
    ,(<span class="dt">Press</span> <span class="ch">&#39;k&#39;</span> , rotate xdir <span class="dv">5</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;i&#39;</span> , rotate xdir (<span class="fu">-</span><span class="dv">5</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;j&#39;</span> , rotate ydir <span class="dv">5</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;l&#39;</span> , rotate ydir (<span class="fu">-</span><span class="dv">5</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;o&#39;</span> , rotate zdir <span class="dv">5</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;u&#39;</span> , rotate zdir (<span class="fu">-</span><span class="dv">5</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;f&#39;</span> , translate xdir <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;s&#39;</span> , translate xdir (<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;e&#39;</span> , translate ydir <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;d&#39;</span> , translate ydir (<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;z&#39;</span> , translate zdir <span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;r&#39;</span> , translate zdir (<span class="fu">-</span><span class="dv">0</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;+&#39;</span> , zoom <span class="dv">1</span><span class="fu">.</span><span class="dv">1</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;-&#39;</span> , zoom (<span class="dv">1</span><span class="fu">/</span><span class="dv">1</span><span class="fu">.</span><span class="dv">1</span>))
    ,(<span class="dt">Press</span> <span class="ch">&#39;h&#39;</span> , resize <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span>)
    ,(<span class="dt">Press</span> <span class="ch">&#39;g&#39;</span> , resize (<span class="dv">1</span><span class="fu">/</span><span class="dv">2</span><span class="fu">.</span><span class="dv">0</span>))
    ]</code></pre>
</div>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">World</span> <span class="fu">=</span> <span class="dt">World</span> {
<span class="ot">      angle       ::</span> <span class="dt">Point3D</span>
    ,<span class="ot"> anglePerSec ::</span> <span class="dt">Scalar</span>
    ,<span class="ot"> scale       ::</span> <span class="dt">Scalar</span>
    ,<span class="ot"> position    ::</span> <span class="dt">Point3D</span>
    ,<span class="ot"> box         ::</span> <span class="dt">Box3D</span>
    ,<span class="ot"> told        ::</span> <span class="dt">Time</span> 
    <span class="co">-- We replace shape by cache</span>
    ,<span class="ot"> cache       ::</span> [<span class="dt">YObject</span>]
    } </code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">DisplayableWorld</span> <span class="dt">World</span> <span class="kw">where</span>
  winTitle _ <span class="fu">=</span> <span class="st">&quot;The YGL Mandelbulb&quot;</span>
  camera w <span class="fu">=</span> <span class="dt">Camera</span> {
        camPos <span class="fu">=</span> position w, 
        camDir <span class="fu">=</span> angle w,
        camZoom <span class="fu">=</span> scale w }
  <span class="co">-- We update our objects instanciation</span>
  objects <span class="fu">=</span> cache</code></pre>
</div>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">xdir ::</span> <span class="dt">Point3D</span>
xdir <span class="fu">=</span> makePoint3D (<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>)
<span class="ot">ydir ::</span> <span class="dt">Point3D</span>
ydir <span class="fu">=</span> makePoint3D (<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>)
<span class="ot">zdir ::</span> <span class="dt">Point3D</span>
zdir <span class="fu">=</span> makePoint3D (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>)

<span class="ot">rotate ::</span> <span class="dt">Point3D</span> <span class="ot">-&gt;</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
rotate dir angleValue world <span class="fu">=</span> 
  world {
     angle <span class="fu">=</span> angle world <span class="fu">+</span> (angleValue <span class="fu">-*&lt;</span> dir) }

<span class="ot">switchRotation ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
switchRotation world <span class="fu">=</span> 
  world {
     anglePerSec <span class="fu">=</span> <span class="kw">if</span> anglePerSec world <span class="fu">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> <span class="dv">5</span><span class="fu">.</span><span class="dv">0</span> }

<span class="ot">translate ::</span> <span class="dt">Point3D</span> <span class="ot">-&gt;</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
translate dir len world <span class="fu">=</span> 
  world {
    position <span class="fu">=</span> position world <span class="fu">+</span> (len <span class="fu">-*&lt;</span> dir) }

<span class="ot">zoom ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
zoom z world <span class="fu">=</span> world {
    scale <span class="fu">=</span> z <span class="fu">*</span> scale world }</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> yMainLoop inputActionMap idleAction initialWorld</code></pre>
</div>
</div>
<p>Our initial world state is slightly changed:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- We initialize the world state</span>
<span class="co">-- then angle, position and zoom of the camera</span>
<span class="co">-- And the shape function</span>
<span class="ot">initialWorld ::</span> <span class="dt">World</span>
initialWorld <span class="fu">=</span> <span class="dt">World</span> {
   angle <span class="fu">=</span> makePoint3D (<span class="dv">30</span>,<span class="dv">30</span>,<span class="dv">0</span>)
 , anglePerSec <span class="fu">=</span> <span class="dv">5</span><span class="fu">.</span><span class="dv">0</span>
 , position <span class="fu">=</span> makePoint3D (<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)
 , scale <span class="fu">=</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span>
 , box <span class="fu">=</span> <span class="dt">Box3D</span> { minPoint <span class="fu">=</span> makePoint3D (<span class="dv">0</span><span class="fu">-</span>eps, <span class="dv">0</span><span class="fu">-</span>eps, <span class="dv">0</span><span class="fu">-</span>eps)
               , maxPoint <span class="fu">=</span> makePoint3D (<span class="dv">0</span><span class="fu">+</span>eps, <span class="dv">0</span><span class="fu">+</span>eps, <span class="dv">0</span><span class="fu">+</span>eps)
               , resolution <span class="fu">=</span>  <span class="dv">0</span><span class="fu">.</span><span class="dv">02</span> }
 , told <span class="fu">=</span> <span class="dv">0</span>
 <span class="co">-- We declare cache directly this time</span>
 , cache <span class="fu">=</span> objectFunctionFromWorld initialWorld
 }
 <span class="kw">where</span> eps<span class="fu">=</span><span class="dv">2</span></code></pre>
</div>
<p>The use of <code>eps</code> is a hint to make a better zoom by computing with the right bounds.</p>
<p>We use the <code>YGL.getObject3DFromShapeFunction</code> function directly. This way instead of providing <code>XYFunc</code>, we provide directly a list of Atoms.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">objectFunctionFromWorld ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> [<span class="dt">YObject</span>]
objectFunctionFromWorld w <span class="fu">=</span> [<span class="dt">Atoms</span> atomList]
  <span class="kw">where</span> atomListPositive <span class="fu">=</span> 
          getObject3DFromShapeFunction
              (shapeFunc (resolution (box w))) (box w)
        atomList <span class="fu">=</span> atomListPositive <span class="fu">++</span> 
          map negativeTriangle atomListPositive
        negativeTriangle (<span class="dt">ColoredTriangle</span> (p1,p2,p3,c)) <span class="fu">=</span> 
              <span class="dt">ColoredTriangle</span> (negz p1,negz p3,negz p2,c)
              <span class="kw">where</span> negz (<span class="dt">P</span> (x,y,z)) <span class="fu">=</span> <span class="dt">P</span> (x,y,<span class="fu">-</span>z)</code></pre>
</div>
<p>We know that resize is the only world change that necessitate to recompute the list of atoms (triangles). Then we update our world state accordingly.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">resize ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
resize r world <span class="fu">=</span> 
  tmpWorld { cache <span class="fu">=</span> objectFunctionFromWorld tmpWorld }
  <span class="kw">where</span> 
      tmpWorld <span class="fu">=</span> world { box <span class="fu">=</span> (box world) {
              resolution <span class="fu">=</span> sqrt ((resolution (box world))<span class="fu">**</span><span class="dv">2</span> <span class="fu">*</span> r) }}</code></pre>
</div>
<p>All the rest is exactly the same.</p>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idleAction ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span>
idleAction tnew world <span class="fu">=</span> 
      world {
        angle <span class="fu">=</span> angle world <span class="fu">+</span> (delta <span class="fu">-*&lt;</span> zdir)
      , told <span class="fu">=</span> tnew
      }
  <span class="kw">where</span> 
      delta <span class="fu">=</span> anglePerSec world <span class="fu">*</span> elapsed <span class="fu">/</span> <span class="dv">1000</span><span class="fu">.</span><span class="dv">0</span>
      elapsed <span class="fu">=</span> fromIntegral (tnew <span class="fu">-</span> (told world))

<span class="ot">shapeFunc ::</span> <span class="dt">Scalar</span> <span class="ot">-&gt;</span> <span class="dt">Function3D</span>
shapeFunc res x y <span class="fu">=</span> 
  <span class="kw">let</span> 
      z <span class="fu">=</span> maxZeroIndex (ymandel x y) <span class="dv">0</span> <span class="dv">1</span> <span class="dv">20</span>
  <span class="kw">in</span>
  <span class="kw">if</span> and [ maxZeroIndex (ymandel (x<span class="fu">+</span>xeps) (y<span class="fu">+</span>yeps)) <span class="dv">0</span> <span class="dv">1</span> <span class="dv">20</span> <span class="fu">&lt;</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">000001</span> <span class="fu">|</span>
              val <span class="ot">&lt;-</span> [res], xeps <span class="ot">&lt;-</span> [<span class="fu">-</span>val,val], yeps<span class="ot">&lt;-</span>[<span class="fu">-</span>val,val]]
      <span class="kw">then</span> <span class="dt">Nothing</span> 
      <span class="kw">else</span> <span class="dt">Just</span> (z,colorFromValue <span class="dv">0</span>)

<span class="ot">colorFromValue ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Color</span>
colorFromValue n <span class="fu">=</span>
  <span class="kw">let</span> 
<span class="ot">      t ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Scalar</span>
      t i <span class="fu">=</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">0</span> <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">5</span><span class="fu">*</span>cos( i <span class="fu">/</span><span class="dv">10</span> )
  <span class="kw">in</span>
    makeColor (t n) (t (n<span class="fu">+</span><span class="dv">5</span>)) (t (n<span class="fu">+</span><span class="dv">10</span>))

<span class="co">-- given f min max nbtest,</span>
<span class="co">-- considering </span>
<span class="co">--  - f is an increasing function</span>
<span class="co">--  - f(min)=0</span>
<span class="co">--  - f(max)≠0</span>
<span class="co">-- then maxZeroIndex f min max nbtest returns x such that</span>
<span class="co">--    f(x - ε)=0 and f(x + ε)≠0</span>
<span class="co">--    where ε=(max-min)/2^(nbtest+1) </span>
<span class="ot">maxZeroIndex ::</span> (<span class="dt">Fractional</span> a,<span class="dt">Num</span> a,<span class="dt">Num</span> b,<span class="dt">Eq</span> b) <span class="ot">=&gt;</span> 
                 (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
maxZeroIndex _ minval maxval <span class="dv">0</span> <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>
maxZeroIndex func minval maxval n <span class="fu">=</span> 
  <span class="kw">if</span> func medpoint <span class="fu">/=</span> <span class="dv">0</span> 
       <span class="kw">then</span> maxZeroIndex func minval medpoint (n<span class="fu">-</span><span class="dv">1</span>)
       <span class="kw">else</span> maxZeroIndex func medpoint maxval (n<span class="fu">-</span><span class="dv">1</span>)
  <span class="kw">where</span> medpoint <span class="fu">=</span> (minval<span class="fu">+</span>maxval)<span class="fu">/</span><span class="dv">2</span>

<span class="ot">ymandel ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span>
ymandel x y z <span class="fu">=</span> fromIntegral (mandel x y z <span class="dv">64</span>) <span class="fu">/</span> <span class="dv">64</span></code></pre>
</div>
</div>
<p>And you can also consider minor changes in the <code>YGL.hs</code> source file.</p>
<ul>
<li><a href="code/06_Mandelbulb/YGL.hs"><code>YGL.hs</code></a>, the 3D rendering framework</li>
<li><a href="code/06_Mandelbulb/Mandel.hs"><code>Mandel</code></a>, the mandel function</li>
<li><a href="code/06_Mandelbulb/ExtComplex.hs"><code>ExtComplex</code></a>, the extended complexes</li>
</ul>
<p><a href="code/06_Mandelbulb/Mandelbulb.lhs" class="cut">Download the source code of this section → 06_Mandelbulb/<strong>Mandelbulb.lhs</strong> </a></p>
<h2 id="conclusion">Conclusion</h2>
<p>As we can use imperative style in a functional language, know you can use functional style in imperative languages. This article exposed a way to organize some code in a functional way. I’d like to stress the usage of Haskell made it very simple to achieve this.</p>
<p>Once you are used to pure functional style, it is hard not to see all advantages it offers.</p>
<p>The code in the two last sections is completely pure and functional. Furthermore I don’t use <code>GLfloat</code>, <code>Color3</code> or any other OpenGL type. If I want to use another library in the future, I would be able to keep all the pure code and simply update the YGL module.</p>
<p>The <code>YGL</code> module can be seen as a “wrapper” around 3D display and user interaction. It is a clean separator between the imperative paradigm and functional paradigm.</p>
<p>If you want to go further, it shouldn’t be hard to add parallelism. This should be easy mainly because most of the visible code is pure. Such an optimization would have been harder by using directly the OpenGL library.</p>
<p>You should also want to make a more precise object. Because, the Mandelbulb is clearly not convex. But a precise rendering might be very long from O(n².log(n)) to O(n³).</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Unfortunately, I couldn’t make this program to work on my Mac. More precisely, I couldn’t make the <a href="http://openil.sourceforge.net/">DevIL</a> library work on Mac to output the image. Yes I have done a <code>brew install libdevil</code>. But even a minimal program who simply write some <code>jpg</code> didn’t worked. I tried both with <code>Haskell</code> and <code>C</code>.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Generally in Haskell you need to declare a lot of import lines. This is something I find annoying. In particular, it should be possible to create a special file, Import.hs which make all the necessary import for you, as you generally need them all. I understand why this is cleaner to force the programmer not to do so, but, each time I do a copy/paste, I feel something is wrong. I believe this concern can be generalized to the lack of namespace in Haskell.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>I tried <code>Complex Double</code>, <code>Complex Float</code>, this current data type with <code>Double</code> and the actual version <code>Float</code>. For rendering a 1024x1024 Mandelbrot set it takes <code>Complex Double</code> about 6.8s, for <code>Complex Float</code> about 5.1s, for the actual version with <code>Double</code> and <code>Float</code> it takes about <code>1.6</code> sec. See these sources for testing yourself: <a href="https://gist.github.com/2945043">https://gist.github.com/2945043</a>. If you really want to things to go faster, use <code>data Complex = C {-# UNPACK #-} !Float {-# UNPACK #-} !Float</code>. It takes only one second instead of 1.6s.<a href="#fnref3">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Haskell comme un vrai!</title>
    <link href="http://yannesposito.com/Scratch/fr/blog/Haskell-the-Hard-Way/index.html" />
    <id>http://yannesposito.com/Scratch/fr/blog/Haskell-the-Hard-Way/index.html</id>
    <published>2012-02-08T00:00:00Z</published>
    <updated>2012-02-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/magritte_pleasure_principle.jpg" alt="Magritte pleasure principle"/>
</div>
<div class="intro">
<p><span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> Un tutoriel très court mais très dense pour apprendre Haskell.</p>
<p>Merci à <a href="https://plus.google.com/u/0/113751420744109290534">Oleg Taykalo</a> vous pouvez trouver une traduction russe ici: <a href="http://habrahabr.ru/post/152889/">Partie 1</a> <em>&amp;</em> <a href="http://habrahabr.ru/post/153383/">Partie 2</a> ; Un grand merci à <a href="https://github.com/lepereceval">lepereceval</a> pour sa traduction française que je n’ai pas eu le courage de faire moi-même ! (<em>NDT: Si vous trouvez une erreurs ou même plusieurs dans la traduction française, vous pouvez m’en faire part à le</em>point_pere_point_ceval_arobase_gmail_point_com_. N’hésitez pas!_)</p>
<blockquote>
<center><hr style="width:30%;float:left;border-color:#CCCCD0;margin-top:1em"/>
<span class="sc"><b>Table of Content</b></span>
<hr style="width:30%;float:right;border-color:#CCCCD0;margin-top:1em"/></center>

<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#install">Installation</a></li>
<li><a href="#don-t-be-afraid">Ne soyez pas effrayés!</a></li>
<li><a href="#very-basic-haskell">Les bases de Haskell</a>
<ul>
<li><a href="#function-declaration">Déclaration de fonctions</a></li>
<li><a href="#a-type-example">Un exemple de type</a></li>
</ul></li>
<li><a href="#essential-haskell">Notions essentielles</a></li>
<li><a href="#notations">Notations</a>
<ul>
<li><a href="#arithmetic">Arithmétique</a></li>
<li><a href="#logic">Logique</a></li>
<li><a href="#powers">Puissances</a></li>
<li><a href="#lists">Listes</a></li>
<li><a href="#strings">Chaînes de caractères</a></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#deal-with-parentheses">Traiter avec les parenthèses</a></li>
</ul></li>
<li><a href="#useful-notations-for-functions">Notations utiles pour les fonctions</a></li>
<li><a href="#hard-part">La Partie Difficile</a></li>
<li><a href="#functional-style">Le style fonctionnel</a>
<ul>
<li><a href="#higher-order-functions">Fonctions d’ordre supérieur</a></li>
</ul></li>
<li><a href="#types">Les types</a>
<ul>
<li><a href="#type-inference">Inférence de type</a></li>
<li><a href="#type-construction">Construction de types</a></li>
<li><a href="#recursive-type">Type récursif</a></li>
<li><a href="#trees">Les arbres</a></li>
</ul></li>
<li><a href="#infinite-structures">Structures infinies</a></li>
<li><a href="#hell-difficulty-part">Partie de difficulté infernale</a></li>
<li><a href="#deal-with-io">S’occuper de l’E/S (IO)</a></li>
<li><a href="#io-trick-explained">Le truc des IO révélé</a></li>
<li><a href="#monads">Les monades</a>
<ul>
<li><a href="#maybe-monad">Maybe est une monade</a></li>
<li><a href="#the-list-monad">La monade List</a></li>
</ul></li>
<li><a href="#appendix">Appendice</a></li>
<li><a href="#more-on-infinite-tree">Revenons sur les arbres infinis</a></li>
</ul>
</div>
</blockquote>
</div>
<div class="intro">
<p>Je pense vraiment que tous les développeurs devraient apprendre Haskell. Peut-être pas devenir des ninjas d’Haskell, mais au moins savoir ce que ce langage a de particulier. Son apprentissage ouvre énormément l’esprit.</p>
<p>La plupart des langages partagent les mêmes fondamentaux&nbsp;:</p>
<ul>
<li>les variables</li>
<li>les boucles</li>
<li>les pointeurs<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></li>
<li>les structures de données, les objets et les classes</li>
</ul>
<p>Haskell est très différent. Ce langage utilise des concepts dont je n’avais jamais entendu parlé avant. Beaucoup de ces concepts pourront vous aider à devenir un meilleur développeur.</p>
<p>Plier son esprit à Haskell peut être difficile. Ce le fût pour moi. Dans cet article, j’essaye de fournir les informations qui m’ont manquées lors de mon apprentissage.</p>
<p>Cet article sera certainement difficile à suivre. Mais c’est voulu. Il n’y a pas de raccourci pour apprendre Haskell. C’est difficile. Mais je pense que c’est une bonne chose. C’est parce qu’Haskell est difficile qu’il est intéressant.</p>
<p>La manière conventionnelle d’apprendre Haskell est de lire deux livres. En premier <a href="http://learnyouahaskell.com">“Learn You a Haskell”</a> et ensuite <a href="http://www.realworldhaskell.org">“Real World Haskell”</a>. Je pense aussi que c’est la bonne manière de s’y prendre. Mais apprendre même un tout petit peu d’Haskell est presque impossible sans se plonger réellement dans ces livres.</p>
<p>Cet article fait un résumé très dense et rapide des aspect majeurs d’Haskell. J’y ai aussi rajouté des informations qui m’ont manqué pendant l’apprentissage de ce langage.</p>
<p>Pour les francophones ; je suis désolé. Je n’ai pas eu le courage de tout retraduire en français. Sachez cependant que si vous êtes plusieurs à insister, je ferai certainement l’effort de traduire l’article en entier. Et si vous vous sentez d’avoir une bonne âme je ne suis pas contre un peu d’aide. Les sources de cet article sont sur <a href="http://github.com/yogsototh/learn_haskell.git">gihub</a>.</p>
<p>Cet article contient cinq parties&nbsp;:</p>
<ul>
<li>Introduction : un exemple rapide pour montrer qu’Haskell peut être facile.</li>
<li>Les bases d’Haskell : La syntaxe et des notions essentielles</li>
<li>Partie difficile :
<ul>
<li>Style fonctionnel : un exemple progressif, du style impératif au style fonctionnel ;</li>
<li>Types : la syntaxe et un exemple d’arbre binaire ;</li>
<li>Structure infinie : manipulons un arbre infini !</li>
</ul></li>
<li>Partie de difficulté infernale :
<ul>
<li>Utiliser les IO : un exemple très minimal ;</li>
<li>Le truc des IO révélé : les détails cachés d’IO qui m’ont manqués</li>
<li>Les monades : incroyable à quel point on peut généraliser</li>
</ul></li>
<li>Appendice :
<ul>
<li>Revenons sur les arbres infinis : une discussion plus mathématique sur la manipulation d’arbres infinis.</li>
</ul></li>
</ul>
<blockquote>
Note: Chaque fois que vous voyez un séparateur avec un nom de fichier se terminant par <code>lhs</code>, vous pouvez cliquer sur le nom de fichier et télécharger le fichier. Si vous sauvegardez le fichier sour le nom <code>filename.lhs</code>, vous pouvez l’exécuter avec :
<pre>
runhaskell filename.lhs
</pre>

<p>Certains ne marcheront pas, mais la majorité vous donneront un résultat. Vous devriez voir un lien juste en dessous.</p>
</blockquote>
</div>
<hr/>
<p><a href="code/01_basic/10_Introduction/00_hello_world.lhs" class="cut">01_basic/10_Introduction/<strong>00_hello_world.lhs</strong></a></p>
<h2 id="introduction">
Introduction
</h2>

<h3 id="install">
Installation
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/Haskell-logo.png" alt=""/>
</div>
<ul>
<li>La principale façon d’installer Haskell est <a href="http://www.haskell.org/platform">Haskell Platform</a>.</li>
</ul>
<p>Outils:</p>
<ul>
<li><code>ghc</code>: Compilateur similaire à gcc pour le langage <code>C</code>.</li>
<li><code>ghci</code>: Console Haskell interactive (Read-Eval-Print Loop)</li>
<li><code>runhaskell</code>: Exécuter un programme sans le compiler. Pratique mais très lent comparé aux programmes compilés.</li>
</ul>
<h3 id="don-t-be-afraid">
Ne soyez pas effrayés!
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/munch_TheScream.jpg" alt="The Scream"/>
</div>
<p>Beaucoup de livres/articles sur Haskell commencent par présenter des formules ésotériques (Algorithmes de tri rapide, suite de Fibonacci, etc…). Je ferai l’exact opposé En premier lieu je ne vous montrerai pas les super-pouvoirs d’Haskell. Je vais commencer par les similarités avec les autres langages de programmation. Commençons par l’indispensable “Hello World!”.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> putStrLn <span class="st">&quot;Hello World!&quot;</span></code></pre>
</div>
<p>Pour l’exécuter, vous pouvez enregistrer ce code dans un fichier <code>hell.hs</code> et:</p>
<pre class="zsh"><code>~ runhaskell ./hello.hs
Hello World!</code></pre>
<p>Vous pouvez également télécharger la source Haskell littérale. Vous devriez voir un lien juste au dessus du titre de l’introduction. Téléchargez ce fichier en tant que <code>00_hello_world.lhs</code> et:</p>
<pre class="zsh"><code>~ runhaskell 00_hello_world.lhs
Hello World!</code></pre>
<p><a href="code/01_basic/10_Introduction/00_hello_world.lhs" class="cut">01_basic/10_Introduction/<strong>00_hello_world.lhs</strong> </a></p>
<hr/>
<p><a href="code/01_basic/10_Introduction/10_hello_you.lhs" class="cut">01_basic/10_Introduction/<strong>10_hello_you.lhs</strong></a></p>
<p>Maintenant, un programme qui demande votre nom et répond “Hello” suivit du nom que vous avez entré:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    print <span class="st">&quot;What is your name?&quot;</span>
    name <span class="ot">&lt;-</span> getLine
    print (<span class="st">&quot;Hello &quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot;!&quot;</span>)</code></pre>
</div>
<p>Premièrement, comparons ce code avec ceux de quelques langages de programmation impératif:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Python</span>
<span class="dt">print</span> <span class="st">&quot;What is your name?&quot;</span>
name = <span class="dt">raw_input</span>()
<span class="dt">print</span> <span class="st">&quot;Hello </span><span class="ot">%s</span><span class="st">!&quot;</span> % name</code></pre>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Ruby</span>
puts <span class="st">&quot;What is your name?&quot;</span>
name = gets.chomp
puts <span class="st">&quot;Hello </span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">!&quot;</span></code></pre>
<pre class="sourceCode c"><code class="sourceCode c"><span class="co">// In C</span>
<span class="ot">#include &lt;stdio.h&gt;</span>
<span class="dt">int</span> main (<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {
    <span class="dt">char</span> name[<span class="dv">666</span>]; <span class="co">// &lt;- An Evil Number!</span>
    <span class="co">// What if my name is more than 665 character long?</span>
    printf(<span class="st">&quot;What is your name?</span><span class="ch">\n</span><span class="st">&quot;</span>);
    scanf(<span class="st">&quot;%s&quot;</span>, name);
    printf(<span class="st">&quot;Hello %s!</span><span class="ch">\n</span><span class="st">&quot;</span>, name);
    <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre>
<p>La structure est la même, mais il y a quelques différences de syntaxe. La partie principale de ce tutoriel sera consacrée à expliquer cela.</p>
<p>En Haskell il y a une fonction <code>main</code> tous les objets ont un type. Le type de <code>main</code> est <code>IO ()</code>. Cela veut dire que <code>main</code> causera des effets secondaires.</p>
<p>Rappelez-vous just que Haskell peut ressembler énormément aux principaux langages impératifs.</p>
<p><a href="code/01_basic/10_Introduction/10_hello_you.lhs" class="cut">01_basic/10_Introduction/<strong>10_hello_you.lhs</strong> </a></p>
<hr/>
<p><a href="code/01_basic/10_Introduction/20_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>20_very_basic.lhs</strong></a></p>
<h3 id="very-basic-haskell">
Les bases de Haskell
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/picasso_owl.jpg" alt="Picasso minimal owl"/>
</div>
<p>Avant de continuer, vous devez êtres avertis à propos de propriétés essentielles de Haskell.</p>
<p><em>Fonctionnel</em></p>
<p>Haskell est un langage fonctionnel Si vous avez déjà travaillé avec un langage impératif, vous devrez apprendre beaucoup de nouvelles choses. Heureusement beaucoup de ces nouveaux concepts vous aidera à programmer même dans un langage impératif.</p>
<p><em>Typage Statique Intelligent</em></p>
<p>Au lieu de bloquer votre chemin comme en <code>C</code>, <code>C++</code> ou <code>Java</code>, le système de typage est ici pour vous aider.</p>
<p><em>Pureté</em></p>
<p>Généralement vos fonctions ne modifieront rien du le monde extérieur. Cela veut dire qu’elles ne peuvent pas modifier la valeur d’une variable, lire du texte entré par un utilisateur, écrire sur l’écran, lancer un missile. D’un autre coté, avoir un code parallèle devient très facile. Haskell rend très clair où les effets apparaissent et où le code est pur. De plus, il devient beaucoup plus aisé de raisonner sur son programme. La majorité des bugs seront évités dans les parties pures de votre programme.</p>
<p>En outre, les fonctions pures suivent une loi fondamentale en Haskell:</p>
<blockquote>
<p>Appliquer une fonction avec les mêmes paramètres retourne toujours la même valeur.</p>
</blockquote>
<p><em>Paresse</em></p>
<p>La paresse par défaut est un choix de conception de langage très rare. Par défaut, Haskell évalue quelque chose seulement lorsque cela est nécessaire. En conséquence, cela fournit un moyen très élégant de manipuler des structures infinies, par exemple.</p>
<p>Un dernier avertissement sur comment vous devriez lire le code Haskell. Pour moi, c’est comme lire des papiers scientifiques. Quelques parties sont très claires, mais quand vous voyez une formule, concentrez-vous dessus et lisez plus lentement. De plus, lorsque vous apprenez Haskell, cela n’importe <em>vraiment</em> pas si vous ne comprenez pas les détails syntaxiques. Si vous voyez un <code>&gt;&gt;=</code>, <code>&lt;$&gt;</code>, <code>&lt;-</code> ou n’importe quel symbole bizarre, ignorez-les et suivez le déroulement du code.</p>
<h4 id="function-declaration">
Déclaration de fonctions
</h4>

<p>Vous avez déjà dû déclarer des fonctions comme cela:</p>
<p>En <code>C</code>:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> f(<span class="dt">int</span> x, <span class="dt">int</span> y) {
    <span class="kw">return</span> x*x + y*y;
}</code></pre>
<p>En JavaScript:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">f</span>(x,y) {
    <span class="kw">return</span> x*x + y*y;
}</code></pre>
<p>En Python:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> f(x,y):
    <span class="kw">return</span> x*x + y*y</code></pre>
<p>En Ruby:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> f(x,y)
    x*x + y*y
<span class="kw">end</span></code></pre>
<p>En Scheme:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme">(<span class="kw">define</span><span class="fu"> </span>(f x y)
    (<span class="kw">+</span> (* x x) (* y y)))</code></pre>
<p>Finalement, la manière de faire de Haskell est:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y <span class="fu">=</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y</code></pre>
<p>Très propre. Aucune parenthèse, aucun <code>def</code>.</p>
<p>N’oubliez pas, Haskell utilise beaucoup les fonctions et les types. C’est très facile de les définir. La syntaxe a été particulièrement réfléchie pour ces objets.</p>
<h4 id="a-type-example">
Un exemple de type
</h4>

<p>Même si ce n’est pas obligatoire, les informations de type pour les fonctions sont habituellement déclarées explicitement. Ce n’est pas indispensable car le compilateur est suffisamment intelligent pour le déduire à votre place. Cependant, c’est une bonne idée car cela montre bien l’intention du développeur et facilite la compréhension.</p>
<p>Jouons un peu. On déclare le type en utilisant <code>::</code></p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot"> f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
 f x y <span class="fu">=</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y

 main <span class="fu">=</span> print (f <span class="dv">2</span> <span class="dv">3</span>)</code></pre>
</div>
<pre><code>~ runhaskell 20_very_basic.lhs
13</code></pre>
<p><a href="code/01_basic/10_Introduction/20_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>20_very_basic.lhs</strong> </a></p>
<hr/>
<p><a href="code/01_basic/10_Introduction/21_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>21_very_basic.lhs</strong></a></p>
<p>Maintenant essayez</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
f x y <span class="fu">=</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y

main <span class="fu">=</span> print (f <span class="dv">2</span><span class="fu">.</span><span class="dv">3</span> <span class="dv">4</span><span class="fu">.</span><span class="dv">2</span>)</code></pre>
</div>
<p>Vous devriez avoir cette erreur:</p>
<pre><code>21_very_basic.lhs:6:23:
    No instance for (Fractional Int)
      arising from the literal `4.2&#39;
    Possible fix: add an instance declaration for (Fractional Int)
    In the second argument of `f&#39;, namely `4.2&#39;
    In the first argument of `print&#39;, namely `(f 2.3 4.2)&#39;
    In the expression: print (f 2.3 4.2)</code></pre>
<p>Le problème est que <code>4.2</code> n’est pas de type <code>Int</code> (<em>NDT: Il n’est pas un entier</em>)</p>
<p><a href="code/01_basic/10_Introduction/21_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>21_very_basic.lhs</strong> </a></p>
<hr/>
<p><a href="code/01_basic/10_Introduction/22_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>22_very_basic.lhs</strong></a></p>
<p>La soulution: ne déclarez pas de type pour <code>f</code> pour le moment et laissez Haskell inférer le type le plus général pour nous:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x y <span class="fu">=</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y

main <span class="fu">=</span> print (f <span class="dv">2</span><span class="fu">.</span><span class="dv">3</span> <span class="dv">4</span><span class="fu">.</span><span class="dv">2</span>)</code></pre>
</div>
<p>Maintenant, ça marche! Heureursement, nous n’avons pas à déclarer un nouvelle fonction pour chaque type différent. Par exemple, en <code>C</code>, vous auriez dû déclarer un fonction pour <code>int</code>, pour <code>float</code>, pour <code>long</code>, pour <code>double</code>, etc…</p>
<p>Mais quel type devons nous déclarer? Pour découvrir le type que Haskell a trouvé pour nous, lançons ghci:</p>
<pre><span class="low">
%</span> ghci<span class="low"><code>
GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude></code></span> let f x y = x*x + y*y
<span class="low"><code>Prelude></code></span> :type f
<code>f :: Num a => a -> a -> a</code>
</pre>

<p>Hein? Quel ce type étrange?</p>
<pre><code>Num a =&gt; a -&gt; a -&gt; a</code></pre>
<p>Preumièrement, concentrons-nous sur la partie de droite: <code>a -&gt; a -&gt; a</code>. Pour le comprendre, regardez cette liste d’exemples progressifs:</p>
<table>
<colgroup>
<col width="20%" />
<col width="79%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Le type écrit</th>
<th align="left">Son sens</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>Int</code></td>
<td align="left">Le type <code>Int</code></td>
</tr>
<tr class="even">
<td align="left"><code>Int -&gt; Int</code></td>
<td align="left">Le type de la fonction qui prend un <code>Int</code> et retourne un <code>Int</code></td>
</tr>
<tr class="odd">
<td align="left"><code>Float -&gt; Int</code></td>
<td align="left">Le type de la fonction qui prend un <code>Float</code> et retourne un <code>Int</code></td>
</tr>
<tr class="even">
<td align="left"><code>a -&gt; Int</code></td>
<td align="left">Le type de la fonction qui prend n’importe quel type de variable et retourne un <code>Int</code></td>
</tr>
<tr class="odd">
<td align="left"><code>a -&gt; a</code></td>
<td align="left">Le type de la fonction qui prend n’importe quel type <code>a</code> et retourne une variable du même type <code>a</code></td>
</tr>
<tr class="even">
<td align="left"><code>a -&gt; a -&gt; a</code></td>
<td align="left">Le type de la fonction qui prend de arguments de n’importe quel type<code>a</code> et retourne une variable de type <code>a</code></td>
</tr>
</tbody>
</table>
<p>Dans le type <code>a -&gt; a -&gt; a</code>, la lettre <code>a</code> est une <em>variable de type</em>. Cela signifie que <code>f</code> est une fonction avec deux arguments et que les deux arguments et le résultat ont le même type. La variable de type <code>a</code> peut prendre de nombreuses valeurs différentes Par exemple <code>Int</code>, <code>Integer</code>, <code>Float</code>…</p>
<p>Donc à la place d’avoir un type forcé comme en <code>C</code> et de devoir déclarer une fonction pour <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, etc., nous déclarons une seule fonction comme dans un langage typé de façon dynamique.</p>
<p>C’est parfois appelé le polymorphisme paramétrique. C’est aussi appelé avoir un gâteau et le manger.</p>
<p>Généralement <code>a</code> peut être de n’importe quel type, par exemple un <code>String</code> ou un <code>Int</code>, mais aussi des types plus complexes comme <code>Trees</code>, d’autres fonctions, etc. Mais ici notre type est préfixé par <code>Num a =&gt;</code>.</p>
<p><code>Num</code> est une <em>classe de type</em>. Une classe de type peut être comprise comme un ensemble de types <code>Num</code> contient seulement les types qui se comportent comme des nombres. Plus précisement, <code>Num</code> est une classe qui contient des types qui implémentent une liste spécifique de fonctions, en particulier <code>(+)</code> et <code>(*)</code>.</p>
<p>Les classes de types sont une structure de langage très puissante. Nous pouvons faire des trucs incroyablement puissants avec. Nous verrons cela plus tard.</p>
<p>Finalement, <code>Num a =&gt; a -&gt; a -&gt; a</code> signifie:</p>
<p>soit <code>a</code> un type qui appartient à la classe <code>Num</code>. C’est une fonction qui prend une variable de type <code>a</code> et retourne une fonction de type <code>(a -&gt; a)</code></p>
<p>Oui, c’est étrange. En fait, en Haskell aucune fonction ne prend réellement deux arguments. Au lieu de cela toutes les fonctions n’ont qu’un argument unique. Mais nous retiendrons que prendre deux arguments est équivalent à n’en prendre qu’un et à retourner une fonction qui prend le second argument en paramètre.</p>
<p>Plus précisement <code>f 3 4</code> est équivalent à <code>(f 3) 4</code>. Remarque: <code>f 3</code> est une fonction:</p>
<pre><code>f :: Num a =&gt; a -&gt; a -&gt; a

g :: Num a =&gt; a -&gt; a
g = f 3

g y ⇔ 3*3 + y*y</code></pre>
<p>Une autre notation existe pour les fonctions. La notation lambda nous autorise à créer des fonctions sans leur assigner un nom. On les appelle des fonctions anonymes. nous aurions donc pu écrire:</p>
<pre><code>g = \y -&gt; 3*3 + y*y</code></pre>
<p>Le <code>\</code> esst utilisé car il ressemble à un <code>λ</code> et est un caractère ASCII.</p>
<p>Si vous n’êtes pas habitué à la programmation fonctionnelle, votre cerveau devrait commencer à chauffer Il est temps de faire une vraie application.</p>
<p><a href="code/01_basic/10_Introduction/22_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>22_very_basic.lhs</strong> </a></p>
<hr/>
<p><a href="code/01_basic/10_Introduction/23_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>23_very_basic.lhs</strong></a></p>
<p>Mais juste avant cela, nous devrions vérifier que le système de type marche comme nous le supposons:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
f x y <span class="fu">=</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y

main <span class="fu">=</span> print (f <span class="dv">3</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">4</span>)</code></pre>
</div>
<p>Cela fonctionne, car <code>3</code> est une représentation valide autant pour les nombres fractionnaires comme Float que pour les entiers. Comme <code>2.4</code> est un nombre fractionnaire, <code>3</code> est interprété comme une autre nombre fractionnaire</p>
<p><a href="code/01_basic/10_Introduction/23_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>23_very_basic.lhs</strong> </a></p>
<hr/>
<p><a href="code/01_basic/10_Introduction/24_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>24_very_basic.lhs</strong></a></p>
<p>Si nous forçons notre fonction à travailler avec des types différents, le test échouera:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
f x y <span class="fu">=</span> x<span class="fu">*</span>x <span class="fu">+</span> y<span class="fu">*</span>y

<span class="ot">x ::</span> <span class="dt">Int</span>
x <span class="fu">=</span> <span class="dv">3</span>
<span class="ot">y ::</span> <span class="dt">Float</span>
y <span class="fu">=</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">4</span>
<span class="co">-- won&#39;t work because type x ≠ type y</span>
main <span class="fu">=</span> print (f x y)</code></pre>
</div>
<p>Le compilateur se plaint. Les deux paramètres doivent avoir le même type.</p>
<p>Si vous pensez que c’est une mauvaise idée et que le compilateur devrait faire la transformation depuis un type à un autre pour vous, vous devriez vraiment regarder cette vidéo géniale (et amusante): <a href="https://www.destroyallsoftware.com/talks/wat">WAT</a> (<em>NDT: En Anglais</em>)</p>
<p><a href="code/01_basic/10_Introduction/24_very_basic.lhs" class="cut">01_basic/10_Introduction/<strong>24_very_basic.lhs</strong> </a></p>
<h2 id="essential-haskell">
Notions essentielles
</h2>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/kandinsky_gugg.jpg" alt="Kandinsky Gugg"/>
</div>
<p>Je vous suggère de seulement survoler cette partie Pensez-y seulement comme à une référence. Haskell a beaucoup de caractèristiques Il manque beaucoup d’informations ici. Revenz ici si la notation vous semble étrange.</p>
<p>J’utilise le symbole <code>⇔</code> pour signifier que deux expressions sont équivalentes. C’est une notation extérieure, <code>⇔</code> n’existe pas en Haskell. Je vais aussi utiliser le symoble <code>⇒</code> quelle est la valeur que retourne une fonction.</p>
<h3 id="notations">
Notations
</h3>

<h5 id="arithmetic">
Arithmétique
</h5>

<pre><code>3 + 2 * 6 / 3 ⇔ 3 + ((2*6)/3)</code></pre>
<h5 id="logic">
Logique
</h5>

<pre><code>True || False ⇒ True
True &amp;&amp; False ⇒ False
True == False ⇒ False
True /= False ⇒ True  (/=) est l&#39;opérateur pour &quot;différent de&quot;</code></pre>
<h5 id="powers">
Puissances
</h5>

<pre><code>x^n     pour n un entier (comprenez Int ou Integer)
x**y    pour y tout type de nombre (Float par exemple)</code></pre>
<p><code>Integer</code> n’a aucune limite à part la capacité de votre machine:</p>
<pre><code>4^103
102844034832575377634685573909834406561420991602098741459288064</code></pre>
<p>Yeah! Et aussi les nombres rationnels! Mais vous avez besoin d’importer le module <code>Data.Ratio</code></p>
<pre><code>$ ghci
....
Prelude&gt; :m Data.Ratio
Data.Ratio&gt; (11 % 15) * (5 % 3)
11 % 9</code></pre>
<h5 id="lists">
Listes
</h5>

<pre><code>[]                      ⇔ liste vide
[1,2,3]                 ⇔ Liste d&#39;entiers
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]     ⇔ Liste de chaînes de caractères
1:[2,3]                 ⇔ [1,2,3], (:) ajoute un élément au début
1:2:[]                  ⇔ [1,2]
[1,2] ++ [3,4]          ⇔ [1,2,3,4], (++) concaténation de deux listes
[1,2,3] ++ [&quot;foo&quot;]      ⇔ ERREUR String ≠ Integral
[1..4]                  ⇔ [1,2,3,4]
[1,3..10]               ⇔ [1,3,5,7,9]
[2,3,5,7,11..100]       ⇔ ERREUR! Je ne suis pas si intelligent!
[10,9..1]               ⇔ [10,9,8,7,6,5,4,3,2,1]</code></pre>
<h5 id="strings">
Chaînes de caractères
</h5>

<p>En Haskell les chaînes de caractères sont des listes de <code>Char</code>.</p>
<pre><code>&#39;a&#39; :: Char
&quot;a&quot; :: [Char]
&quot;&quot;  ⇔ []
&quot;ab&quot; ⇔ [&#39;a&#39;,&#39;b&#39;] ⇔  &#39;a&#39;:&quot;b&quot; ⇔ &#39;a&#39;:[&#39;b&#39;] ⇔ &#39;a&#39;:&#39;b&#39;:[]
&quot;abc&quot; ⇔ &quot;ab&quot;++&quot;c&quot;</code></pre>
<blockquote>
<p><em>Remarque</em>: Dans un vrai code vous n’utiliserez pas des listes de char pour représenter du texte. Vous utiliserez plus souvent <code>Data.Text</code> à la place. Si vous voulez représenter un chapelet de caractères ASCII, vous utiliserez <code>Data.ByteString</code>.</p>
</blockquote>
<h5 id="tuples">
Tuples
</h5>

<p>Le type d’un couple est <code>(a,b)</code>. Les éléments d’un tuple peuvent avoir des types différents.</p>
<pre><code>-- tous ces tuples sont valides
(2,&quot;foo&quot;)
(3,&#39;a&#39;,[2,3])
((2,&quot;a&quot;),&quot;c&quot;,3)

fst (x,y)       ⇒  x
snd (x,y)       ⇒  y

fst (x,y,z)     ⇒  ERROR: fst :: (a,b) -&gt; a
snd (x,y,z)     ⇒  ERROR: snd :: (a,b) -&gt; b</code></pre>
<h5 id="deal-with-parentheses">
Traiter avec les parenthèses
</h5>

<p>Pour enlever des parenthèses vous pouvez utiliser deux fonctions: <code>($)</code> et <code>(.)</code>.</p>
<pre><code>-- Par défaut:
f g h x         ⇔  (((f g) h) x)

-- le $ remplace les parenthèses depuis le $
-- jusqu&#39;à la fin de l&#39;expression.
f g $ h x       ⇔  f g (h x) ⇔ (f g) (h x)
f $ g h x       ⇔  f (g h x) ⇔ f ((g h) x)
f $ g $ h x     ⇔  f (g (h x))

-- (.) permet de faire des compositions de fonctions
(f . g) x       ⇔  f (g x)
(f . g . h) x   ⇔  f (g (h x))</code></pre>
<hr/>
<p><a href="code/01_basic/20_Essential_Haskell/10a_Functions.lhs" class="cut">01_basic/20_Essential_Haskell/<strong>10a_Functions.lhs</strong></a></p>
<h3 id="useful-notations-for-functions">
Notations utiles pour les fonctions
</h3>

<p>Juste un mémo:</p>
<pre><code>x :: Int            ⇔ x est de type Int
x :: a              ⇔ x peut être de n&#39;importe quel type
x :: Num a =&gt; a     ⇔ x peut être de n&#39;importe quel type a
                      tant qu&#39; a appartient à la classe de type Num 
f :: a -&gt; b         ⇔ f est une fonction qui prend un a et retourne un b
f :: a -&gt; b -&gt; c    ⇔ f est une fonction qui prend un a et retourne un (b→c)
f :: (a -&gt; b) -&gt; c  ⇔ f est une fonction qui prend un (a→b) et retourne un c</code></pre>
<p>Rappelez-vous que définir le type d’une fonction avant sa déclaration n’est pas obligatoire. Haskell infère le type le plus général pour vous. Mais c’est considéré comme une bonne pratique.</p>
<p><em>Notation Infixée</em></p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">square ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
square x <span class="fu">=</span> x<span class="fu">^</span><span class="dv">2</span></code></pre>
</div>
<p>Remarquez que <code>^</code> utilise une notation infixée. Pour chaque opérateur infixe il y a une notation préfixée associée. Vous devz juste l’écrire entre parenthèses.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">square&#39; x <span class="fu">=</span> (<span class="fu">^</span>) x <span class="dv">2</span>

square&#39;&#39; x <span class="fu">=</span> (<span class="fu">^</span><span class="dv">2</span>) x</code></pre>
</div>
<p>Nous pouvons enlever le <code>x</code> dans les parties de gauche et de droite! On appelle cela la η-réduction</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">square&#39;&#39;&#39; <span class="fu">=</span> (<span class="fu">^</span><span class="dv">2</span>)</code></pre>
</div>
<p>Rmarquez qu nous pouvons déclarer des fonctions avec <code>'</code> dans leur nom. Exemples:</p>
<blockquote>
<p><code>square</code> ⇔ <code>square'</code> ⇔ <code>square''</code> ⇔ <code>square'''</code></p>
</blockquote>
<p><em>Tests</em></p>
<p>Une implémentation de la fonction absolue.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">absolute ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
absolute x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="kw">then</span> x <span class="kw">else</span> <span class="fu">-</span>x</code></pre>
</div>
<p>Remarque: la notation de Haskell pour le <code>if .. then .. else</code> ressemble plus à l’opérateur <code>¤?¤:¤</code> en C. Le <code>else</code> est obligatoire.</p>
<p>Une version équivalente:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">absolute&#39; x
    <span class="fu">|</span> x <span class="fu">&gt;=</span> <span class="dv">0</span> <span class="fu">=</span> x
    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="fu">-</span>x</code></pre>
</div>
<blockquote>
<p>Avertissement: l’indentation est <em>importante</em> en Haskell. Comme en Python, une mauvaise indentation peut détruire votre code!</p>
</blockquote>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
      print <span class="fu">$</span> square <span class="dv">10</span>
      print <span class="fu">$</span> square&#39; <span class="dv">10</span>
      print <span class="fu">$</span> square&#39;&#39; <span class="dv">10</span>
      print <span class="fu">$</span> square&#39;&#39;&#39; <span class="dv">10</span>
      print <span class="fu">$</span> absolute <span class="dv">10</span>
      print <span class="fu">$</span> absolute (<span class="fu">-</span><span class="dv">10</span>)
      print <span class="fu">$</span> absolute&#39; <span class="dv">10</span>
      print <span class="fu">$</span> absolute&#39; (<span class="fu">-</span><span class="dv">10</span>)</code></pre>
</div>
</div>
<p><a href="code/01_basic/20_Essential_Haskell/10a_Functions.lhs" class="cut">01_basic/20_Essential_Haskell/<strong>10a_Functions.lhs</strong> </a></p>
<h2 id="hard-part">
La Partie Difficile
</h2>

<p>La partie difficile peut maintenant commencer.</p>
<h3 id="functional-style">
Le style fonctionnel
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/hr_giger_biomechanicallandscape_500.jpg" alt="Biomechanical Landscape by H.R. Giger"/>
</div>
<p>Dans cette section, je vais vous donner un court exemple de l’impressionante capacité de remaniement de Haskell. Nous allons sélectionner un problème et le résoudre à la manière d’un langage impératif standard. Ensuite, je ferais évoluer le code. Le résultat final sera plus élégant et plus facile à adapter.</p>
<p>résolvons les problèmes suivants:</p>
<blockquote>
<p>Soit une liste d’entiers, retourner la somme des nombres pairs de cette liste.</p>
<p>exemple: <code>[1,2,3,4,5] ⇒  2 + 4 ⇒  6</code></p>
</blockquote>
<p>Pour montrer les différences entre les approches fonctionnelle et impérative, je vais commencer par donner la solution impérative (en JavaScript):</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">evenSum</span>(list) {
    <span class="kw">var</span> result = <span class="dv">0</span>;
    <span class="kw">for</span> (<span class="kw">var</span> i=<span class="dv">0</span>; i&lt; <span class="ot">list</span>.<span class="fu">length</span> ; i++) {
        <span class="kw">if</span> (list[i] % <span class="dv">2</span> ==<span class="dv">0</span>) {
            result += list[i];
        }
    }
    <span class="kw">return</span> result;
}</code></pre>
<p>En Haskell, en revanche, nous n’avons pas de variables ou un boucle <code>for</code>. Une des solutions pour parvenir au même résultat sans boucles est d’utiliser la récursion.</p>
<blockquote>
<p><em>Remarque</em>: La récursion est souvent perçue comme lente dans les langages impératifs. Mais ce n’est généralement pas le cas en programmation fonctionnelle. La plupart du temps Haskell gérera les fonctions récursives efficacement.</p>
</blockquote>
<p>Voici la version <code>C</code> de la fonction récursive. Remarquez que je suppose que la liste d’int fini avec la première valeur <code>0</code>.</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span> evenSum(<span class="dt">int</span> *list) {
    <span class="kw">return</span> accumSum(<span class="dv">0</span>,list);
}

<span class="dt">int</span> accumSum(<span class="dt">int</span> n, <span class="dt">int</span> *list) {
    <span class="dt">int</span> x;
    <span class="dt">int</span> *xs;
    <span class="kw">if</span> (*list == <span class="dv">0</span>) { <span class="co">// if the list is empty</span>
        <span class="kw">return</span> n;
    } <span class="kw">else</span> {
        x = list[<span class="dv">0</span>]; <span class="co">// let x be the first element of the list</span>
        xs = list<span class="dv">+1</span>; <span class="co">// let xs be the list without x</span>
        <span class="kw">if</span> ( <span class="dv">0</span> == (x%<span class="dv">2</span>) ) { <span class="co">// if x is even</span>
            <span class="kw">return</span> accumSum(n+x, xs);
        } <span class="kw">else</span> {
            <span class="kw">return</span> accumSum(n, xs);
        }
    }
}</code></pre>
<p>Gardez ce code à l’esprit. Nous allons le traduire en Haskell. Premièrement,</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">even<span class="ot"> ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a
tail<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</code></pre>
<p><code>even</code> vérifie si un nombre est pair.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">even<span class="ot"> ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
even <span class="dv">3</span>  <span class="ot">⇒</span> <span class="dt">False</span>
even <span class="dv">2</span>  <span class="ot">⇒</span> <span class="dt">True</span></code></pre>
<p><code>head</code> retourne le premier élément d’une liste:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">head<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a
head [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="ot">⇒</span> <span class="dv">1</span>
head []      <span class="ot">⇒</span> <span class="dt">ERROR</span></code></pre>
<p><code>tail</code> retourne tous les éléments d’une liste, sauf le premier:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">tail<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]
tail [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="ot">⇒</span> [<span class="dv">2</span>,<span class="dv">3</span>]
tail [<span class="dv">3</span>]     <span class="ot">⇒</span> []
tail []      <span class="ot">⇒</span> <span class="dt">ERREUR</span></code></pre>
<p>Remarquez que pour toute liste non-vide <code>l</code>, <code>l ⇔ (head l):(tail l)</code></p>
<hr/>
<p><a href="code/02_Hard_Part/11_Functions.lhs" class="cut">02_Hard_Part/<strong>11_Functions.lhs</strong></a></p>
<p>La première solution en Haskell. La fonction <code>evenSum</code> retourne la somme de tous les nombres pairs d’une liste:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 1</span>
<span class="ot">evenSum ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>

evenSum l <span class="fu">=</span> accumSum <span class="dv">0</span> l

accumSum n l <span class="fu">=</span> <span class="kw">if</span> l <span class="fu">==</span> []
                  <span class="kw">then</span> n
                  <span class="kw">else</span> <span class="kw">let</span> x <span class="fu">=</span> head l
                           xs <span class="fu">=</span> tail l
                       <span class="kw">in</span> <span class="kw">if</span> even x
                              <span class="kw">then</span> accumSum (n<span class="fu">+</span>x) xs
                              <span class="kw">else</span> accumSum n xs</code></pre>
</div>
<p>Pour tester une fonction nous pouvons utiliser <code>ghci</code>:</p>
<pre>
% ghci
<span class="low">GHCi, version 7.0.3: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude&gt;</span> :load 11_Functions.lhs
<span class="low">[1 of 1] Compiling Main             ( 11_Functions.lhs, interpreted )
Ok, modules loaded: Main.
*Main&gt;</span> evenSum [1..5]
6
</pre>

<p>Voici un exemple d’exécution<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>:</p>
<pre>
*Main> evenSum [1..5]
accumSum 0 [1,2,3,4,5]
<span class="yellow">1 est impair</span>
accumSum 0 [2,3,4,5]
<span class="yellow">2 est pair</span>
accumSum (0+2) [3,4,5]
<span class="yellow">3 est impair</span>
accumSum (0+2) [4,5]
<span class="yellow">4 est pair</span>
accumSum (0+2+4) [5]
<span class="yellow">5 est impair</span>
accumSum (0+2+4) []
<span class="yellow">l == []</span>
0+2+4
0+6
6
</pre>

<p>En venant d’un langage impératif, tout devrait vous sembler juste. En fait, beaucoup de choses peuvent être améliorées ici. Tout d’abord, nous pouvons généraliser le type.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</code></pre>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span> print <span class="fu">$</span> evenSum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/11_Functions.lhs" class="cut">02_Hard_Part/<strong>11_Functions.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/12_Functions.lhs" class="cut">02_Hard_Part/<strong>12_Functions.lhs</strong></a></p>
<p>Ensuite, nous pouvons utiliser des sous-fonctions grâce à <code>where</code> et <code>let</code>. Ansi, notre fonction <code>accumSum</code> ne polluera pas le <em>namespace</em> de notre module</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 2</span>
<span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a

evenSum l <span class="fu">=</span> accumSum <span class="dv">0</span> l
    <span class="kw">where</span> accumSum n l <span class="fu">=</span>
            <span class="kw">if</span> l <span class="fu">==</span> []
                <span class="kw">then</span> n
                <span class="kw">else</span> <span class="kw">let</span> x <span class="fu">=</span> head l
                         xs <span class="fu">=</span> tail l
                     <span class="kw">in</span> <span class="kw">if</span> even x
                            <span class="kw">then</span> accumSum (n<span class="fu">+</span>x) xs
                            <span class="kw">else</span> accumSum n xs</code></pre>
</div>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> evenSum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/12_Functions.lhs" class="cut">02_Hard_Part/<strong>12_Functions.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/13_Functions.lhs" class="cut">02_Hard_Part/<strong>13_Functions.lhs</strong></a></p>
<p>Puis on utilise le <em>pattern matching</em></p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 3</span>
evenSum l <span class="fu">=</span> accumSum <span class="dv">0</span> l
    <span class="kw">where</span>
        accumSum n [] <span class="fu">=</span> n
        accumSum n (x<span class="fu">:</span>xs) <span class="fu">=</span>
             <span class="kw">if</span> even x
                <span class="kw">then</span> accumSum (n<span class="fu">+</span>x) xs
                <span class="kw">else</span> accumSum n xs</code></pre>
</div>
<p>Qu’est ce que le <em>pattern matching</em> ? Il s’agit d’utiliser des valeurs au lieu de noms de paramètres généraux.</p>
<p>Au lieu d’écrire: <code>foo l = if l == [] then &lt;x&gt; else &lt;y&gt;</code> Vous écrivez tout simplement&nbsp;:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foo [] <span class="fu">=</span>  <span class="fu">&lt;</span>x<span class="fu">&gt;</span>
foo l  <span class="fu">=</span>  <span class="fu">&lt;</span>y<span class="fu">&gt;</span></code></pre>
<p>Mais le <em>pattern matching</em> peut aller encore plus loin. Il est également capable d’inspect les données internes d’un valeur complexe. Nous pouvons ainsi remplacer</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foo l <span class="fu">=</span>  <span class="kw">let</span> x  <span class="fu">=</span> head l
             xs <span class="fu">=</span> tail l
         <span class="kw">in</span> <span class="kw">if</span> even x
             <span class="kw">then</span> foo (n<span class="fu">+</span>x) xs
             <span class="kw">else</span> foo n xs</code></pre>
<p>par</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foo (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> even x
                 <span class="kw">then</span> foo (n<span class="fu">+</span>x) xs
                 <span class="kw">else</span> foo n xs</code></pre>
<p>C’est une caractéristique très utile. Notre code est ainsi plus concis et plus facile à lire.</p>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> evenSum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/13_Functions.lhs" class="cut">02_Hard_Part/<strong>13_Functions.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/14_Functions.lhs" class="cut">02_Hard_Part/<strong>14_Functions.lhs</strong></a></p>
<p>Avec Haskell, nous pouvons simplifier les défitions des fonctions en les <em>η-réduisant</em> . Par exemple, au lieu d’écrire:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f x <span class="fu">=</span> (expression) x</code></pre>
<p>Nous pouvons écrire</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> expression</code></pre>
<p>Utilisons cette méthode pour retirer le <code>l</code>:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 4</span>
<span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a

evenSum <span class="fu">=</span> accumSum <span class="dv">0</span>
    <span class="kw">where</span>
        accumSum n [] <span class="fu">=</span> n
        accumSum n (x<span class="fu">:</span>xs) <span class="fu">=</span>
             <span class="kw">if</span> even x
                <span class="kw">then</span> accumSum (n<span class="fu">+</span>x) xs
                <span class="kw">else</span> accumSum n xs</code></pre>
</div>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> evenSum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/14_Functions.lhs" class="cut">02_Hard_Part/<strong>14_Functions.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/15_Functions.lhs" class="cut">02_Hard_Part/<strong>15_Functions.lhs</strong></a></p>
<h4 id="higher-order-functions">
Fonctions d’ordre supérieur
</h4>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/escher_polygon.png" alt="Escher"/>
</div>
<p>Pour rendre les choses plus faciles, nous devrions utiliser des fonctions d’ordre supérieur. Ce sont des fonctions qui prennent des fonctions en paramètres</p>
<p>Voici quelques exemples:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</code></pre>
<p>Procédons par étapes.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 5</span>
evenSum l <span class="fu">=</span> mysum <span class="dv">0</span> (filter even l)
    <span class="kw">where</span>
      mysum n [] <span class="fu">=</span> n
      mysum n (x<span class="fu">:</span>xs) <span class="fu">=</span> mysum (n<span class="fu">+</span>x) xs</code></pre>
<p>où</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">filter even [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] ⇔  [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</code></pre>
<p>La fonction <code>filter</code> prend une fonction du type (<code>a -&gt; Bool</code>) et une liste de type <code>[a]</code>. Elle retourne une liste qui contient seulement les élements pour qui la fonction a retourné <code>True</code>.</p>
<p>La prochaine étape est d’utiliser une autre technique pour accomplir la même chose qu’une boucle. Nous allons utiliser la fonction <code>foldl</code> pour accumuler une valeur au fur et à mesure que l’on parcoure la liste. La fonction <code>foldl</code> capture un modèle de code général:</p>
<pre>
    myfunc list = foo <span class="blue">initialValue</span> <span class="green">list</span>
    foo accumulated []     = accumulated
    foo tmpValue    (x:xs) = foo (<span class="yellow">bar</span> tmpValue x) xs
</pre>

<p>Qui peut être remplacé par:</p>
<pre>
myfunc list = foldl <span class="yellow">bar</span> <span class="blue">initialValue</span> <span class="green">list</span>
</pre>

<p>Si vous souhaitez vraiment savoir comment la magie se produit, voici la définition de <code>foldl</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl f z [] <span class="fu">=</span> z
foldl f z (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (f z x) xs</code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell">foldl f z [x1,<span class="fu">...</span>xn]
⇔  f (<span class="fu">...</span> (f (f z x1) x2) <span class="fu">...</span>) xn</code></pre>
<p>Mais comme Haskell est paresseux, il n’évalue pas <code>(f z x)</code> et le met simplement dans la pile. C’est pourquoi on utilise généralement <code>foldl'</code>, une version <em>stricte</em> de <code>foldl</code>, Si vous ne comprenez pas encore ce que <em>paresseux</em> ou <em>strict</em> signifie, ne vous inquiétez pas, suivez le code comme si <code>foldl'</code> et <code>foldl</code> étaient identiques</p>
<p>Maintenant notre version de <code>evenSum</code> devient:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 6</span>
<span class="co">-- foldl&#39; n&#39;est pas accessible par défaut</span>
<span class="co">-- nous devons l&#39;importer depuis le module Data.List</span>
<span class="kw">import </span><span class="dt">Data.List</span>
evenSum l <span class="fu">=</span> foldl&#39; mysum <span class="dv">0</span> (filter even l)
  <span class="kw">where</span> mysum acc value <span class="fu">=</span> acc <span class="fu">+</span> value</code></pre>
<p>Nous pouvons aussi simplifier cela en utilisant une <em>lambda-notation</em>. Ainsi nous n’avons pas besoin de créer le nom temporaire <code>mySum</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 7</span>
<span class="co">-- Generally it is considered a good practice</span>
<span class="co">-- to import only the necessary function(s)</span>
<span class="kw">import </span><span class="dt">Data.List</span> (foldl&#39;)
evenSum l <span class="fu">=</span> foldl&#39; (\x y <span class="ot">-&gt;</span> x<span class="fu">+</span>y) <span class="dv">0</span> (filter even l)</code></pre>
</div>
<p>Et bien sûr, nous remarquons que</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(\x y <span class="ot">-&gt;</span> x<span class="fu">+</span>y) ⇔ (<span class="fu">+</span>)</code></pre>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> evenSum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/15_Functions.lhs" class="cut">02_Hard_Part/<strong>15_Functions.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/16_Functions.lhs" class="cut">02_Hard_Part/<strong>16_Functions.lhs</strong></a></p>
<p>Finalement</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 8</span>
<span class="kw">import </span><span class="dt">Data.List</span> (foldl&#39;)
<span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
evenSum l <span class="fu">=</span> foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span> (filter even l)</code></pre>
<p><code>foldl'</code> n’est pas la fonction la plus facile à prendre en main. Si vous n’y êtes pas habitué, vous devriez l’étudier un peu.</p>
<p>Pour mieux comprendre ce qui se passe ici, étudions une évaluation étape par étape:</p>
<pre>
  <span class="yellow">evenSum [1,2,3,4]</span>
⇒ foldl' (+) 0 (<span class="yellow">filter even [1,2,3,4]</span>)
⇒ <span class="yellow">foldl' (+) 0 <span class="blue">[2,4]</span></span>
⇒ <span class="blue">foldl' (+) (<span class="yellow">0+2</span>) [4]</span>
⇒ <span class="yellow">foldl' (+) <span class="blue">2</span> [4]</span>
⇒ <span class="blue">foldl' (+) (<span class="yellow">2+4</span>) []</span>
⇒ <span class="yellow">foldl' (+) <span class="blue">6</span> []</span>
⇒ <span class="blue">6</span>
</pre>

<p>Une autr fonction d’ordre supérieur utile est <code>(.)</code>. Elle correspond à une composition en mathématiques.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(f <span class="fu">.</span> g <span class="fu">.</span> h) x ⇔  f ( g (h x))</code></pre>
<p>Nous pouvons profiter de cet opérateur pour η-réduire notre fonction:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 9</span>
<span class="kw">import </span><span class="dt">Data.List</span> (foldl&#39;)
<span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
evenSum <span class="fu">=</span> (foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span>) <span class="fu">.</span> (filter even)</code></pre>
<p>Nous pouvons maintenant renommer certaines parties pour rendre le tout plus clair:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Version 10</span>
<span class="kw">import </span><span class="dt">Data.List</span> (foldl&#39;)
<span class="ot">sum&#39; ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
sum&#39; <span class="fu">=</span> foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span>
<span class="ot">evenSum ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
evenSum <span class="fu">=</span> sum&#39; <span class="fu">.</span> (filter even)</code></pre>
</div>
<p>Il est temps de discuter de la direction qu’a pris notre code depuis que nous avons introduit plus d’idiomes fonctionnels. Que gagnons-nous à utiliser des fonctions d’ordre supérieur?</p>
<p>D’abord, vous pourriez penser que la principale différence est la brièveté. Mais en réalité, il s’agit d’une meilleure façon de penser. Supposons que nous voulons modifier légèrement notre fonction, par exemple, pour qu’elle renvoie la somme de tous les carrés pairs des éléments de la liste.</p>
<pre><code>[1,2,3,4] ▷ [1,4,9,16] ▷ [4,16] ▷ 20</code></pre>
<p>Mettre la version 10 à jour est très facile:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">squareEvenSum <span class="fu">=</span> sum&#39; <span class="fu">.</span> (filter even) <span class="fu">.</span> (map (<span class="fu">^</span><span class="dv">2</span>))
squareEvenSum&#39; <span class="fu">=</span> evenSum <span class="fu">.</span> (map (<span class="fu">^</span><span class="dv">2</span>))</code></pre>
</div>
<p>Nous avons juste eu à ajouter une autre “fonction de trabsformation”[^0216].</p>
<pre><code>map (^2) [1,2,3,4] ⇔ [1,4,9,16]</code></pre>
<p>La fonction <code>map</code> applique simplementune fonction à tous les élements d’une liste.</p>
<p>Nous n’avons rien modifié <em>à l’intérieur</em> de notre définition de fonction. Cela rend le code plus modulaire. En plus de cela, vous pouvez penser à votre fonction plus mathématiquement. Vous pouvez aussi utilier votre fonction avec d’autres, au besoin: vous pouvez utiliser <code>compose</code>, <code>map</code>, <code>fold</code> ou <code>filter</code> sur notre nouvelle fonction.</p>
<p>Modifier la version 1 est laissé comme un exercice pour le lecteur ☺.</p>
<p>Si vous croyez avoir atteint le bout de la généralisation, vous avez tout faux. Par example, il y a un moyen d’utiliser cette fonction non seulement sur les listes mais aussi sur n’importe quel type récursif. Si vous voulez savoir comment, je vous suggère de lire cet article: <a href="http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire by Meijer, Fokkinga and Paterson</a> (<em>NDT: en anglais, mais là vous vous en seriez douté je pense ☺</em>)</p>
<p>Cet exemple montre à quel point la programmation fonctionnelle pure est géniale. Malheureusement, utiliser cet outil n’est pas adapté à tous les besoins. Ou alors un langage qui le premettrait n’a pas encore été trouvé.</p>
<p>Une des grands pouvoirs de Haskell est sa capacité à créer des DSLs (<em>Domain Specific Language</em>, en français : <em>langage spécifique à un domaine</em>) Il est ainsi facile de changer le pardigme de programmation</p>
<p>En fait, Haskell peut très bien vous permettre d’écrire des programmes impératifs. Comprendre cela a été très difficile pour moi lorsque j’apprenais Haskell. Beaucoup d’efforts tendent à expliquer la supériorité de l’approche fonctionnele. Puis lorsque vous commencez à utliser le style impératif en Haskell, Il peut être difficile de comprendre quand et où l’utliser.</p>
<p>Mais avant de parler de ce super-pouvoir de Haskell, nous devons parler d’un autre aspet essentiel: les <em>Types</em>.</p>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> evenSum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/16_Functions.lhs" class="cut">02_Hard_Part/<strong>16_Functions.lhs</strong> </a></p>
<h3 id="types">
Les types
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/salvador-dali-the-madonna-of-port-lligat.jpg" alt="Dali, the madonna of port Lligat"/>
</div>
<blockquote>
<p><span class="sc"><abbr title="Too long; didn't read">tl;dr</abbr>: </span></p>
<ul>
<li><code>type Name = AnotherType</code> is just an alias and the compiler doesn’t mark any difference between <code>Name</code> and <code>AnotherType</code>.</li>
<li><code>data Name = NameConstructor AnotherType</code> does mark a difference.</li>
<li><code>data</code> can construct structures which can be recursives.</li>
<li><code>deriving</code> is magic and creates functions for you.</li>
</ul>
</blockquote>
<p>En Haskell, les types sont forts et statiques.</p>
<p>Pourquoi est-ce important? Cela vous aidera a éviter <em>beaucoup</em> d’erreurs. En Haskell, la majorité des bugs est repérée durant la compilation de votre programme. Et la raison principale de cela est l’inférence de type durant la compilation. L’inférence de type permet de détecter plus facilement lorsque vous utilisez le mauvais paramètre au mauvais endroit, par exemple</p>
<h4 id="type-inference">
Inférence de type
</h4>

<p>Le typage statique est généralement essentiel pour une exécution rapide. Mais la plupart des langages typés statiquement ont du mal à généraliser des concepts. La “grâce salvatrice” de Haskell est qu’il peut <em>inférer</em> des types.</p>
<p>Voici un exemple simple, la fonction <code>square</code> en Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">square x <span class="fu">=</span> x <span class="fu">*</span> x</code></pre>
<p>Cette fonction peut mettre au carré n’importe quel type <code>Numeral</code>. Vous pouvez l’utilser avec un <code>Int</code>, un <code>Integer</code>, un <code>Float</code>, un <code>Fractional</code> ou même un <code>Complex</code>. Preuve par l’exemple:</p>
<pre><code>% ghci
GHCi, version 7.0.4:
...
Prelude&gt; let square x = x*x
Prelude&gt; square 2
4
Prelude&gt; square 2.1
4.41
Prelude&gt; -- charge le module Data.Complex
Prelude&gt; :m Data.Complex
Prelude Data.Complex&gt; square (2 :+ 1)
3.0 :+ 4.0</code></pre>
<p><code>x :+ y</code> est la notation pour le complex (<i>x + iy</i>)</p>
<p>Comparons maintenant avec la quantité de code nécessaire pour le faire en C:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="dt">int</span>     int_square(<span class="dt">int</span> x) { <span class="kw">return</span> x*x; }

<span class="dt">float</span>   float_square(<span class="dt">float</span> x) {<span class="kw">return</span> x*x; }

complex complex_square (complex z) {
    complex tmp;
    tmp.real = z.real * z.real - z.img * z.img;
    tmp.img = <span class="dv">2</span> * z.img * z.real;
}

complex x,y;
y = complex_square(x);</code></pre>
<p>Pour chaque type, vous avfez besoin d’écrire une nouvelle fonction. Le seul moyen de se débarsser de se problème est d’utiliser des trucs de méta-programmation, par exemple via le pré-processeur. en C++ il y a un meilleur moyen, les <em>templates</em>:</p>
<p><sub><sub>~</sub></sub>~ {.c++} #include <iostream> #include <complex> using namespace std;</p>
<p>template<typename T> T square(T x) { return x*x; }</p>
<p>int main() { // int int sqr_of_five = square(5); cout &lt;&lt; sqr_of_five &lt;&lt; endl; // double cout &lt;&lt; (double)square(5.3) &lt;&lt; endl; // complex cout &lt;&lt; square( complex<double>(5,3) ) &lt;&lt; endl; return 0; } <sub><sub>~</sub></sub>~</p>
<p>C++ fait un bien meilleur travail que C ici. Mais pour des fonctions plus complexes, la syntaxe sera difficile à suivre. Voyez <a href="http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/">cet article</a> pour quelques exemples. (_NDT: toujours en anglais)</p>
<p>En C++ vous devez déclarer qu’un fonction peut marcher avec différents types. En Haskell, c’est le cas contraire. La fonction sera aussi générale que possible par défaut.</p>
<p>L’inférence de type donne à Haskell le sentiment de liberté que les langages dyumaniquement typés proposent. Mais contrairement aux langages dynamiquement typés, la majorité des erreurs est détectée avant de lancer le programme. Généralement, en Haskell:</p>
<blockquote>
<p>“Si ça compile, ça fera certainement ce à quoi vous vous attendiez.”</p>
</blockquote>
<hr/>
<p><a href="code/02_Hard_Part/21_Types.lhs" class="cut">02_Hard_Part/<strong>21_Types.lhs</strong></a></p>
<h4 id="type-construction">
Construction de types
</h4>

<p>Vous pouvez construire vos propres types. D’abord, vous pouvez utiliser des alias ou des synonymes de types.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span>   <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Color</span>  <span class="fu">=</span> <span class="dt">String</span>

<span class="ot">showInfos ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span>  <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showInfos name color <span class="fu">=</span>  <span class="st">&quot;Name: &quot;</span> <span class="fu">++</span> name
                        <span class="fu">++</span> <span class="st">&quot;, Color: &quot;</span> <span class="fu">++</span> color
<span class="ot">name ::</span> <span class="dt">Name</span>
name <span class="fu">=</span> <span class="st">&quot;Robin&quot;</span>
<span class="ot">color ::</span> <span class="dt">Color</span>
color <span class="fu">=</span> <span class="st">&quot;Blue&quot;</span>
main <span class="fu">=</span> putStrLn <span class="fu">$</span> showInfos name color</code></pre>
</div>
<p><a href="code/02_Hard_Part/21_Types.lhs" class="cut">02_Hard_Part/<strong>21_Types.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/22_Types.lhs" class="cut">02_Hard_Part/<strong>22_Types.lhs</strong></a></p>
<p>Mais cela ne vous protège pas tellement. Essayez d’inverser les deux paramètres de <code>showInfos</code> et lancez le programme:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    putStrLn <span class="fu">$</span> showInfos color name</code></pre>
<p>Le code sera compilé et exécuté. En fait vous pouvez remplace Name, Color et String n’importe où. Le compilateur les traitera comme si ils était complétement identiques.</p>
<p>Une autre méthode est de créer vos propres type avec le mot-clé <code>data</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Name</span>   <span class="fu">=</span> <span class="dt">NameConstr</span> <span class="dt">String</span>
<span class="kw">data</span> <span class="dt">Color</span>  <span class="fu">=</span> <span class="dt">ColorConstr</span> <span class="dt">String</span>

<span class="ot">showInfos ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span>  <span class="dt">Color</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
showInfos (<span class="dt">NameConstr</span> name) (<span class="dt">ColorConstr</span> color) <span class="fu">=</span>
      <span class="st">&quot;Name: &quot;</span> <span class="fu">++</span> name <span class="fu">++</span> <span class="st">&quot;, Color: &quot;</span> <span class="fu">++</span> color

name  <span class="fu">=</span> <span class="dt">NameConstr</span> <span class="st">&quot;Robin&quot;</span>
color <span class="fu">=</span> <span class="dt">ColorConstr</span> <span class="st">&quot;Blue&quot;</span>
main <span class="fu">=</span> putStrLn <span class="fu">$</span> showInfos name color</code></pre>
</div>
<p>Maintenant, si vous échangez les paramètres de<code>showInfos</code>, le compilateur se plaint! C’est donc une erreur que vous ne refairez jamais, au suel prix d’être plus bavard.</p>
<p>Remarquez aussi que les constructeurs sont des fonctions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">NameConstr</span><span class="ot">  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Name</span>
<span class="dt">ColorConstr</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Color</span></code></pre>
<p>La syntaxe de <code>data</code> est principalement:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TypeName</span> <span class="fu">=</span>   <span class="dt">ConstructorName</span>  [types]
                <span class="fu">|</span> <span class="dt">ConstructorName2</span> [types]
                <span class="fu">|</span> <span class="fu">...</span></code></pre>
<p>Généralement on utilise le même nom pour le DatatTypeName et le DataTypeConstructor.</p>
<p>Exemple:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Complex</span> a a</code></pre>
<p>Vous pouvez également utiliser cette syntaxe:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DataTypeName</span> <span class="fu">=</span> <span class="dt">DataConstructor</span> {
<span class="ot">                      field1 ::</span> [<span class="kw">type</span> <span class="kw">of</span> field1]
                    ,<span class="ot"> field2 ::</span> [<span class="kw">type</span> <span class="kw">of</span> field2]
                    <span class="fu">...</span>
                    ,<span class="ot"> fieldn ::</span> [<span class="kw">type</span> <span class="kw">of</span> fieldn] }</code></pre>
<p>Et les accesseurs sont définis automatiquement. En outre, vous pouvez utiliser une autre ordre lorsque vous définissez des valeurs.</p>
<p>Exemple:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Complex</span> <span class="fu">=</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Complex</span> {<span class="ot"> real ::</span> a,<span class="ot"> img ::</span> a}
c <span class="fu">=</span> <span class="dt">Complex</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span> <span class="dv">2</span><span class="fu">.</span><span class="dv">0</span>
z <span class="fu">=</span> <span class="dt">Complex</span> { real <span class="fu">=</span> <span class="dv">3</span>, img <span class="fu">=</span> <span class="dv">4</span> }
real c <span class="ot">⇒</span> <span class="dv">1</span><span class="fu">.</span><span class="dv">0</span>
img z <span class="ot">⇒</span> <span class="dv">4</span></code></pre>
<p><a href="code/02_Hard_Part/22_Types.lhs" class="cut">02_Hard_Part/<strong>22_Types.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/23_Types.lhs" class="cut">02_Hard_Part/<strong>23_Types.lhs</strong></a></p>
<h4 id="recursive-type">
Type récursif
</h4>

<p>Nous avons déjà rencontré un type récursif : les listes. Nous pourrions re-créer les listes, avec une syntaxe plus bavarde:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Empty</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre>
<p>Si vous voulez réellement utiliser une syntxe plus simple, utilisez un nom infixe pour les constructeurs.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">::</span><span class="fu">:</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> a <span class="ot">::</span><span class="fu">:</span> (<span class="dt">List</span> a)</code></pre>
<p>Le nombre après <code>infixr</code> donne la priorité.</p>
<p>Si vous voulez pouvoir écrire (<code>Show</code>), lire (<code>Read</code>), tester l’égalite (<code>Eq</code>) et comparer (<code>Ord</code>) votre nouvelle structure, vous pouvez demander à Haskell de dériver les fonctions appropriées pour vous.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">::</span><span class="fu">:</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> a <span class="ot">::</span><span class="fu">:</span> (<span class="dt">List</span> a)
              <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Read</span>,<span class="dt">Eq</span>,<span class="dt">Ord</span>)</code></pre>
</div>
<p>Quand vous ajoutez <code>deriving (Show)</code> à votre déclaration, Haskell crée une fonction <code>show</code> pour vous. Nous verrons bientôt comment utiliser sa propre fonction <code>show</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">convertList [] <span class="fu">=</span> <span class="dt">Nil</span>
convertList (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">::</span><span class="fu">:</span> convertList xs</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
      print (<span class="dv">0</span> <span class="ot">::</span><span class="fu">:</span> <span class="dv">1</span> <span class="ot">::</span><span class="fu">:</span> <span class="dt">Nil</span>)
      print (convertList [<span class="dv">0</span>,<span class="dv">1</span>])</code></pre>
</div>
<p>Ceci écrit:</p>
<pre><code>0 ::: (1 ::: Nil)
0 ::: (1 ::: Nil)</code></pre>
<p><a href="code/02_Hard_Part/23_Types.lhs" class="cut">02_Hard_Part/<strong>23_Types.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/30_Trees.lhs" class="cut">02_Hard_Part/<strong>30_Trees.lhs</strong></a></p>
<h4 id="trees">
Les arbres
</h4>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/magritte-l-arbre.jpg" alt="Magritte, l"/>
</div>
<p>Voici une autre exemple standard : les arbres binaires.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Empty</span>
                 <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a)
                              <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre>
</div>
<p>Créons aussi une fonctions qui transforme une liste en un arbre binaire ordonné.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeFromList [] <span class="fu">=</span> <span class="dt">Empty</span>
treeFromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Node</span> x (treeFromList (filter (<span class="fu">&lt;</span>x) xs))
                             (treeFromList (filter (<span class="fu">&gt;</span>x) xs))</code></pre>
</div>
<p>Remarquez à quel point cette fonction est élégante. En français:</p>
<ul>
<li>une liste vide est convertie en un arbre vide</li>
<li>une liste <code>(x:xs)</code> sera convertie en un arbre où:</li>
<li>La racine est <code>x</code></li>
<li>Le “sous-arbre” de gauche est l’arbre créé à partir des membres de la liste <code>xs</code> strictement inférieurs à <code>x</code></li>
<li>Le “sous-arbre” de droite est l’arbre créé à partir des membres de la liste <code>xs</code> strictement superieurs à <code>x</code></li>
</ul>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> treeFromList [<span class="dv">7</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>]</code></pre>
</div>
<p>Vious devriez obtenir:</p>
<pre><code>Node 7 (Node 2 Empty (Node 4 Empty Empty)) (Node 8 Empty Empty)</code></pre>
<p>C’est représentation de notre arbre informative mais déplaisante.</p>
<p><a href="code/02_Hard_Part/30_Trees.lhs" class="cut">02_Hard_Part/<strong>30_Trees.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/31_Trees.lhs" class="cut">02_Hard_Part/<strong>31_Trees.lhs</strong></a></p>
<p>Juste pour le plaisir, codons un meilleur affichage pour nos arbres. Je me suis simplement amusé à faire une belle fonction pour afficher les arbres de façon générale. Vous pouvez passer cette partie si vous la trouvez difficile à suivre.</p>
<p>Nous avons quelques changements à faire. Enlevons le <code>deriving (Show)</code> de la déclaration de notre type <code>BinTree</code>. Il serait aussi utile de faire de BinTree une instance de (<code>Eq</code> et <code>Ord</code>), nous serons ainsi capable de tester l’égalité et de comparer des arbres.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Empty</span>
                 <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a)
                  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>)</code></pre>
</div>
<p>Sans le <code>deriving (Show)</code>, Haskell ne crée pas de méthode <code>show</code> pour nous. Nous allons créer notre propre version. Pour accomplir cela, nous devons déclarer que notre type <code>BinTree a</code> est une instance de la classe de type <code>Show</code>. La syntaxe générale est:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span>
   show t <span class="fu">=</span> <span class="fu">...</span> <span class="co">-- Déclarez votre fonction ici</span></code></pre>
<p>Voici ma version pour afficher un arbre binaire. Ne vous inquiétez pas de sa complexité apparente. J’ai fais beaucoup d’améliorations pour afficher même les objets les plus étranges.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- declare BinTree a to be an instance of Show</span>
<span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span>
  <span class="co">-- will start by a &#39;&lt;&#39; before the root</span>
  <span class="co">-- and put a : a begining of line</span>
  show t <span class="fu">=</span> <span class="st">&quot;&lt; &quot;</span> <span class="fu">++</span> replace <span class="ch">&#39;\n&#39;</span> <span class="st">&quot;\n: &quot;</span> (treeshow <span class="st">&quot;&quot;</span> t)
    <span class="kw">where</span>
    <span class="co">-- treeshow pref Tree</span>
    <span class="co">--   shows a tree and starts each line with pref</span>
    <span class="co">-- We don&#39;t display the Empty tree</span>
    treeshow pref <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span>
    <span class="co">-- Leaf</span>
    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span>) <span class="fu">=</span>
                  (pshow pref x)

    <span class="co">-- Right branch is empty</span>
    treeshow pref (<span class="dt">Node</span> x left <span class="dt">Empty</span>) <span class="fu">=</span>
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> left)

    <span class="co">-- Left branch is empty</span>
    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> right) <span class="fu">=</span>
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    <span class="co">-- Tree with left and right children non empty</span>
    treeshow pref (<span class="dt">Node</span> x left right) <span class="fu">=</span>
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;|--&quot;</span> <span class="st">&quot;|  &quot;</span> left) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    <span class="co">-- shows a tree using some prefixes to make it nice</span>
    showSon pref before next t <span class="fu">=</span>
                  pref <span class="fu">++</span> before <span class="fu">++</span> treeshow (pref <span class="fu">++</span> next) t

    <span class="co">-- pshow replaces &quot;\n&quot; by &quot;\n&quot;++pref</span>
    pshow pref x <span class="fu">=</span> replace <span class="ch">&#39;\n&#39;</span> (<span class="st">&quot;\n&quot;</span><span class="fu">++</span>pref) (show x)

    <span class="co">-- replaces one char by another string</span>
    replace c new string <span class="fu">=</span>
      concatMap (change c new) string
      <span class="kw">where</span>
          change c new x
              <span class="fu">|</span> x <span class="fu">==</span> c <span class="fu">=</span> new
              <span class="fu">|</span> otherwise <span class="fu">=</span> x<span class="fu">:</span>[] <span class="co">-- &quot;x&quot;</span></code></pre>
</div>
<p>La méthode <code>treeFromList</code> reste identique.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeFromList [] <span class="fu">=</span> <span class="dt">Empty</span>
treeFromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Node</span> x (treeFromList (filter (<span class="fu">&lt;</span>x) xs))
                             (treeFromList (filter (<span class="fu">&gt;</span>x) xs))</code></pre>
</div>
<p>Et maintenant, nous pouvons jouer:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Int binary tree:&quot;</span>
  print <span class="fu">$</span> treeFromList [<span class="dv">7</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">21</span>,<span class="dv">12</span>,<span class="dv">23</span>]</code></pre>
</div>
<pre><code>Arbre binaire d&#39;Int:
&lt; 7
: |--2
: |  |--1
: |  `--4
: |     |--3
: |     `--6
: `--8
:    `--21
:       |--12
:       `--23</code></pre>
<p>Maintenant c’est beaucoup mieux! La racine est montré en commençant la ligne avec le caractère <code>&lt;</code>. Et chaqeue ligne suivante commence avec un <code>:</code>. Mais nous pourrions aussi utiliser un autre type.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">  putStrLn <span class="st">&quot;\nString binary tree:&quot;</span>
  print <span class="fu">$</span> treeFromList [<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>,<span class="st">&quot;baz&quot;</span>,<span class="st">&quot;gor&quot;</span>,<span class="st">&quot;yog&quot;</span>]</code></pre>
</div>
<pre><code>Arbre binaire de chaïnes de caractères
&lt; &quot;foo&quot;
: |--&quot;bar&quot;
: |  `--&quot;baz&quot;
: `--&quot;gor&quot;
:    `--&quot;yog&quot;</code></pre>
<p>Commme nous pouvons tester l’égalité et ordonner des arbres, nous pouvons aussi faire des arbres d’arbres!</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">  putStrLn <span class="st">&quot;\nBinary tree of Char binary trees:&quot;</span>
  print ( treeFromList
           (map treeFromList [<span class="st">&quot;baz&quot;</span>,<span class="st">&quot;zara&quot;</span>,<span class="st">&quot;bar&quot;</span>]))</code></pre>
</div>
<pre><code>Arbre binaire d&#39;arbres binaires de Char:
&lt; &lt; &#39;b&#39;
: : |--&#39;a&#39;
: : `--&#39;z&#39;
: |--&lt; &#39;b&#39;
: |  : |--&#39;a&#39;
: |  : `--&#39;r&#39;
: `--&lt; &#39;z&#39;
:    : `--&#39;a&#39;
:    :    `--&#39;r&#39;</code></pre>
<p>C’est pour cela que j’ai choisi de préfixer chaque ligne par un <code>:</code> (sauf pour la racine).</p>
<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/yo_dawg_tree.jpg" alt="Yo Dawg Tree"/>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">  putStrLn <span class="st">&quot;\nTree of Binary trees of Char binary trees:&quot;</span>
  print <span class="fu">$</span> (treeFromList <span class="fu">.</span> map (treeFromList <span class="fu">.</span> map treeFromList))
             [ [<span class="st">&quot;YO&quot;</span>,<span class="st">&quot;DAWG&quot;</span>]
             , [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]
             , [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]
             , [<span class="st">&quot;YOU&quot;</span>,<span class="st">&quot;LIKE&quot;</span>,<span class="st">&quot;TREES&quot;</span>] ]</code></pre>
</div>
<p>Qui est équivalent à</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">print ( treeFromList (
          map treeFromList
             [ map treeFromList [<span class="st">&quot;YO&quot;</span>,<span class="st">&quot;DAWG&quot;</span>]
             , map treeFromList [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]
             , map treeFromList [<span class="st">&quot;I&quot;</span>,<span class="st">&quot;HEARD&quot;</span>]
             , map treeFromList [<span class="st">&quot;YOU&quot;</span>,<span class="st">&quot;LIKE&quot;</span>,<span class="st">&quot;TREES&quot;</span>] ]))</code></pre>
<p>et donne:</p>
<pre><code>Arbre d&#39;arbres d&#39;arbres de char:
&lt; &lt; &lt; &#39;Y&#39;
: : : `--&#39;O&#39;
: : `--&lt; &#39;D&#39;
: :    : |--&#39;A&#39;
: :    : `--&#39;W&#39;
: :    :    `--&#39;G&#39;
: |--&lt; &lt; &#39;I&#39;
: |  : `--&lt; &#39;H&#39;
: |  :    : |--&#39;E&#39;
: |  :    : |  `--&#39;A&#39;
: |  :    : |     `--&#39;D&#39;
: |  :    : `--&#39;R&#39;
: `--&lt; &lt; &#39;Y&#39;
:    : : `--&#39;O&#39;
:    : :    `--&#39;U&#39;
:    : `--&lt; &#39;L&#39;
:    :    : `--&#39;I&#39;
:    :    :    |--&#39;E&#39;
:    :    :    `--&#39;K&#39;
:    :    `--&lt; &#39;T&#39;
:    :       : `--&#39;R&#39;
:    :       :    |--&#39;E&#39;
:    :       :    `--&#39;S&#39;</code></pre>
<p>Remarquez que les arbres en double ne sont pas insérés. Il n’y a qu’un seul arbre correspondant à <code>&quot;I&quot;,&quot;HEARD&quot;</code>. Nous avons ceci presque gratuitement, car nous avons déclaré Tree comme instance de <code>Eq</code>.</p>
<p>fr:Voyez à quel point cette structure est formidable: Nous pouvons faire des arbres contenant seulement des entiers, des chaînes de caractères, mais aussi d’autres arbres. Et nous pouvons même faire un arbre contenant un arbre d’arbres!</p>
<p><a href="code/02_Hard_Part/31_Trees.lhs" class="cut">02_Hard_Part/<strong>31_Trees.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/40_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>40_Infinites_Structures.lhs</strong></a></p>
<h3 id="infinite-structures">
Structures infinies
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/escher_infinite_lizards.jpg" alt="Escher"/>
</div>
<p>On dit souvent que Haskell est <em>paresseux</em>.</p>
<p>En fait, si vous êtes un petit peu pédant, vous devriez dire que <a href="http://www.haskell.org/haskellwiki/Lazy_vs._non-strict">Haskell est <em>non-strict</em></a> (<em>NDT: En anglais, pour changer</em>). La paresse est juste une implémentation commune aux langages non-stricts.</p>
<p>Alors que signifie “non-strict”? D’après le wiki de Haskell:</p>
<blockquote>
<p>Réduction (terme mathématique pour évaluation) procède depuis l’extérieur.</p>
<p>donc si vous avez <code>(a+(b*c))</code> alors vous réduisez <code>+</code> d’abord, puis vous réduisez <code>(b*c)</code></p>
</blockquote>
<p>Par exemple en Haskell vous pouvez faire:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- numbers = [1,2,..]</span>
<span class="ot">numbers ::</span> [<span class="dt">Integer</span>]
numbers <span class="fu">=</span> <span class="dv">0</span><span class="fu">:</span>map (<span class="dv">1</span><span class="fu">+</span>) numbers

take&#39; n [] <span class="fu">=</span> []
take&#39; <span class="dv">0</span> l <span class="fu">=</span> []
take&#39; n (x<span class="fu">:</span>xs) <span class="fu">=</span> x<span class="fu">:</span>take&#39; (n<span class="fu">-</span><span class="dv">1</span>) xs

main <span class="fu">=</span> print <span class="fu">$</span> take&#39; <span class="dv">10</span> numbers</code></pre>
</div>
<p>Et ça s’arrête.</p>
<p>Comment?</p>
<p>Au lieu d’essayer d’évaluer <code>numbers</code> entièrement, Haskell évalue les éléments seulement lorsque c’est nécessaire.</p>
<p>Remarquez aussi qu’en Haskell, il y a une notation pour les listes infinies</p>
<pre><code>[1..]   ⇔ [1,2,3,4...]
[1,3..] ⇔ [1,3,5,7,9,11...]</code></pre>
<p>et que la majorité des fonctions fonctionnera avec ces listes. Il y a aussi une fonction <code>take</code> équivalente à notre <code>take'</code>.</p>
<p><a href="code/02_Hard_Part/40_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>40_Infinites_Structures.lhs</strong> </a></p>
<hr/>
<p><a href="code/02_Hard_Part/41_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>41_Infinites_Structures.lhs</strong></a></p>
<div style="display:none">
<p>This code is mostly the same as the previous one.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Debug.Trace</span> (trace)
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Empty</span>
                 <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a)
                  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>)</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- declare BinTree a to be an instance of Show</span>
<span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span>
  <span class="co">-- will start by a &#39;&lt;&#39; before the root</span>
  <span class="co">-- and put a : a begining of line</span>
  show t <span class="fu">=</span> <span class="st">&quot;&lt; &quot;</span> <span class="fu">++</span> replace <span class="ch">&#39;\n&#39;</span> <span class="st">&quot;\n: &quot;</span> (treeshow <span class="st">&quot;&quot;</span> t)
    <span class="kw">where</span>
    treeshow pref <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span>
    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span>) <span class="fu">=</span>
                  (pshow pref x)

    treeshow pref (<span class="dt">Node</span> x left <span class="dt">Empty</span>) <span class="fu">=</span>
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> left)

    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> right) <span class="fu">=</span>
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    treeshow pref (<span class="dt">Node</span> x left right) <span class="fu">=</span>
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;|--&quot;</span> <span class="st">&quot;|  &quot;</span> left) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    <span class="co">-- show a tree using some prefixes to make it nice</span>
    showSon pref before next t <span class="fu">=</span>
                  pref <span class="fu">++</span> before <span class="fu">++</span> treeshow (pref <span class="fu">++</span> next) t

    <span class="co">-- pshow replace &quot;\n&quot; by &quot;\n&quot;++pref</span>
    pshow pref x <span class="fu">=</span> replace <span class="ch">&#39;\n&#39;</span> (<span class="st">&quot;\n&quot;</span><span class="fu">++</span>pref) (<span class="st">&quot; &quot;</span> <span class="fu">++</span> show x)

    <span class="co">-- replace on char by another string</span>
    replace c new string <span class="fu">=</span>
      concatMap (change c new) string
      <span class="kw">where</span>
          change c new x
              <span class="fu">|</span> x <span class="fu">==</span> c <span class="fu">=</span> new
              <span class="fu">|</span> otherwise <span class="fu">=</span> x<span class="fu">:</span>[] <span class="co">-- &quot;x&quot;</span></code></pre>
</div>
</div>
<p>Supposons que nous ne nous préoccupions pas d’avoir une arbre ordonné. Voici un arbre binaire infini:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">nullTree <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> nullTree nullTree</code></pre>
</div>
<p>Un arbre complet où chaque noeud est égal à 0. Maintenant je vais vous prouver que nous pouvons manipuler cet arbre avec la fonction suivante:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- take all element of a BinTree</span>
<span class="co">-- up to some depth</span>
treeTakeDepth _ <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Empty</span>
treeTakeDepth <span class="dv">0</span> _     <span class="fu">=</span> <span class="dt">Empty</span>
treeTakeDepth n (<span class="dt">Node</span> x left right) <span class="fu">=</span> <span class="kw">let</span>
          nl <span class="fu">=</span> treeTakeDepth (n<span class="fu">-</span><span class="dv">1</span>) left
          nr <span class="fu">=</span> treeTakeDepth (n<span class="fu">-</span><span class="dv">1</span>) right
          <span class="kw">in</span>
              <span class="dt">Node</span> x nl nr</code></pre>
</div>
<p>Regardez ce qui se passe avec ce programme:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> treeTakeDepth <span class="dv">4</span> nullTree</code></pre>
<p>Le code compile, se lance et s’arrête en donnant ce résultat:</p>
<pre><code>&lt;  0
: |-- 0
: |  |-- 0
: |  |  |-- 0
: |  |  `-- 0
: |  `-- 0
: |     |-- 0
: |     `-- 0
: `-- 0
:    |-- 0
:    |  |-- 0
:    |  `-- 0
:    `-- 0
:       |-- 0
:       `-- 0</code></pre>
<p>Pour nous chauffer encore un peu les neurones, faisons un arbre plus intéressant:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">iTree <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> (dec iTree) (inc iTree)
        <span class="kw">where</span>
           dec (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Node</span> (x<span class="fu">-</span><span class="dv">1</span>) (dec l) (dec r)
           inc (<span class="dt">Node</span> x l r) <span class="fu">=</span> <span class="dt">Node</span> (x<span class="fu">+</span><span class="dv">1</span>) (inc l) (inc r)</code></pre>
</div>
<p>Un autre moyen de créer cet arbre est d’utiliser une fonction d’ordre supérieur. Cette fonction devrait être similaire à <code>map</code> n, mais devrais travailler sur un <code>BinTree</code> au lieu d’une liste. Voici cette fonction:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- apply a function to each node of Tree</span>
<span class="ot">treeMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> b
treeMap f <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Empty</span>
treeMap f (<span class="dt">Node</span> x left right) <span class="fu">=</span> <span class="dt">Node</span> (f x)
                                     (treeMap f left)
                                     (treeMap f right)</code></pre>
</div>
<p><em>NB</em>: Je ne parlerais pas plus de cette fonction ici. Si vous vous intéressez à la généralisation de <code>map</code>à d’autre structures de données, cherchez des informations sur les foncteurs et <code>fmap</code>.</p>
<p>Notre définition est maintenant:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">infTreeTwo ::</span> <span class="dt">BinTree</span> <span class="dt">Int</span>
infTreeTwo <span class="fu">=</span> <span class="dt">Node</span> <span class="dv">0</span> (treeMap (\x <span class="ot">-&gt;</span> x<span class="fu">-</span><span class="dv">1</span>) infTreeTwo)
                    (treeMap (\x <span class="ot">-&gt;</span> x<span class="fu">+</span><span class="dv">1</span>) infTreeTwo)</code></pre>
</div>
<p>Regardez le résultat pour</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> treeTakeDepth <span class="dv">4</span> infTreeTwo</code></pre>
<pre><code>&lt;  0
: |-- -1
: |  |-- -2
: |  |  |-- -3
: |  |  `-- -1
: |  `-- 0
: |     |-- -1
: |     `-- 1
: `-- 1
:    |-- 0
:    |  |-- -1
:    |  `-- 1
:    `-- 2
:       |-- 1
:       `-- 3</code></pre>
<div style="display:none">
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> treeTakeDepth <span class="dv">4</span> nullTree
  print <span class="fu">$</span> treeTakeDepth <span class="dv">4</span> infTreeTwo</code></pre>
</div>
</div>
<p><a href="code/02_Hard_Part/41_Infinites_Structures.lhs" class="cut">02_Hard_Part/<strong>41_Infinites_Structures.lhs</strong> </a></p>
<h2 id="hell-difficulty-part">
Partie de difficulté infernale
</h2>

<p>Félicitations pour être allé si loin! Maitenant, les choses vraiment extrêmes peuvent commencer.</p>
<p>Si vous êtes comme moi, vous avez déjà acqis le style fonctionnel. Vous devriez également comprendre les avantages de la paresse par défaut. Mais vous ne comprenez pas vraiment par où commencer pour faire un vrai programme. et en particulier:</p>
<ul>
<li>Comment s’occuper des effets?</li>
<li>Pourquoi y a t-il une étrange notation impérative lorsque l’on s’occupe de l’Entrée/Sortie? (E/S, <em>IO</em> en anglais.)</li>
</ul>
<p>Soyez préparés, les réponses risquent d’être compliquées. Mais elles en valent la peine.</p>
<hr/>
<p><a href="code/03_Hell/01_IO/01_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>01_progressive_io_example.lhs</strong></a></p>
<h3 id="deal-with-io">
S’occuper de l’E/S (IO)
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/magritte_carte_blanche.jpg" alt="Magritte, Carte blanche"/>
</div>
<blockquote>
<p><span class="sc"><abbr title="Too long; didn't read">tl;dr</abbr>: </span></p>
<p>Une fonction typique qui fait de l’<code>IO</code> ressemble à un programme impératif:</p>
<pre><code>f :: IO a
f = do
  x &lt;- action1
  action2 x
  y &lt;- action3
  action4 x y</code></pre>
<ul>
<li>Pour définir la valeur d’un objet on utilise <code>&lt;-</code> .</li>
<li>Le type de chaque ligne est <code>IO *</code>; dans cet exemple:</li>
<li><code>action1     :: IO b</code></li>
<li><code>action2 x   :: IO ()</code></li>
<li><code>action3     :: IO c</code></li>
<li><code>action4 x y :: IO a</code></li>
<li><code>x :: b</code>, <code>y :: c</code></li>
<li>Quelques objets ont le type <code>IO a</code>, cela devrait vous aider à choisir. En particulier vous ne pouvez pas utiliser de fonctions pures directement ici. Pour utiliser des fonctions pures vous pourriez faire <code>action2 (pureFunction x)</code> par exemple.</li>
</ul>
</blockquote>
<p>Dans cette section, je vais expliquer comment utiliser l’IO, pas comment ça marche. Vous verrez comment Haskell sépare les parties pures et impures du programme.</p>
<p>Ne vous arrêtez pas sur les détails de la syntaxe Les réponses viendront dans la section suivante.</p>
<p>Que cherchons-nous à faire?</p>
<blockquote>
<p>Demander une liste de nombres à l’utilisateur. Afficher la somme de ces nombres.</p>
</blockquote>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">toList ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
toList input <span class="fu">=</span> read (<span class="st">&quot;[&quot;</span> <span class="fu">++</span> input <span class="fu">++</span> <span class="st">&quot;]&quot;</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a list of numbers (separated by comma):&quot;</span>
  input <span class="ot">&lt;-</span> getLine
  print <span class="fu">$</span> sum (toList input)</code></pre>
</div>
<p>Il devrait être simple de comprendre le comportement de ce programme. Analysons les types en détails.</p>
<pre><code>putStrLn :: String -&gt; IO ()
getLine  :: IO String
print    :: Show a =&gt; a -&gt; IO ()</code></pre>
<p>Ou, plus intéressant, on remarque que chaque expression dans le bloc <code>do</code> est de type <code>IO a</code>.</p>
<pre>
main = do
  putStrLn "Enter ... " :: <span class="high">IO ()</span>
  getLine               :: <span class="high">IO String</span>
  print Something       :: <span class="high">IO ()</span>
</pre>

<p>Nous devrions aussi prêter attention à l’effet du symbole <code>&lt;-</code>.</p>
<pre><code>do
 x &lt;- something</code></pre>
<p>Si <code>something :: IO a</code> alors <code>x :: a</code>.</p>
<p>Une autre remarque important sur l’<code>IO</code>: Toutes les lignes d’un bloc <code>do</code> doivent être d’une des deux formes:</p>
<pre><code>action1             :: IO a
                    -- in this case, generally a = ()</code></pre>
<p>ou</p>
<pre><code>value &lt;- action2    -- where
                    -- action2 :: IO b
                    -- value   :: b</code></pre>
<p>Ces deux types de ligne correspondent à deux différents types de séquençage d’action. La signification de cette phrase devrait être plus claire à la fin de la prochaine section.</p>
<p><a href="code/03_Hell/01_IO/01_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>01_progressive_io_example.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Hell/01_IO/02_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>02_progressive_io_example.lhs</strong></a></p>
<p>Maintenant voyons comment ce programme se comporte. Par exemple, que ce passe-t-il si l’utilisateur entre une mauvaise valeur? Essayons:</p>
<pre><code>    % runghc 02_progressive_io_example.lhs
    Enter a list of numbers (separated by comma):
    foo
    Prelude.read: no parse</code></pre>
<p>Argh! Un message d’erreur et un crash! Notre première amélioration sera de répondre avec un message plus amical.</p>
<p>Pour faire cela, nous devons détecter que quelque chose s’est mal passé. Voici un moyen de le faire: utiliser le type <code>Maybe</code>. C’est un type très commun en Haskell.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Maybe</span></code></pre>
</div>
<p>Quelle est cette chose? <code>Maybe</code> est un type qui prend un paramètre. Sa définition est:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre>
<p>C’est un bon moyen de dire qu’il y a eu une erreur en essayant de créer/évaluer une valeur. La fonction <code>maybeRead</code> est un bon exemple de cela. C’est une fonction similaire à <code>read</code><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>, mais si quelque chose ne va pas la valeur retournée est <code>Nothing</code>. Si la valeur est bonne, la valeur retournée est <code>Just &lt;la valeur&gt;</code>. N’essayez pas trop de comprendre cette fonction. J’utilise un fonction de plus bas niveau que <code>read</code>; <code>reads</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">maybeRead ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
maybeRead s <span class="fu">=</span> <span class="kw">case</span> reads s <span class="kw">of</span>
                  [(x,<span class="st">&quot;&quot;</span>)]    <span class="ot">-&gt;</span> <span class="dt">Just</span> x
                  _           <span class="ot">-&gt;</span> <span class="dt">Nothing</span></code></pre>
</div>
<p>Maintenant, pour être plus lisible, on définie une fonction comme ceci: Si la chaîne a un mauvais format, elle retournera <code>Nothing</code>. Sinon, par exemple pour “1,2,3”, cela retournera <code>Just [1,2,3]</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getListFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Integer</span>]
getListFromString str <span class="fu">=</span> maybeRead <span class="fu">$</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;]&quot;</span></code></pre>
</div>
<p>Nous avons juste à tester la valeur dans notre fonction principale.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a list of numbers (separated by comma):&quot;</span>
  input <span class="ot">&lt;-</span> getLine
  <span class="kw">let</span> maybeList <span class="fu">=</span> getListFromString input <span class="kw">in</span>
      <span class="kw">case</span> maybeList <span class="kw">of</span>
          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> print (sum l)
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Bad format. Good Bye.&quot;</span></code></pre>
</div>
<p>En cas d’erreur, on affiche un joli message.</p>
<p>Remarquez que le type de chaque expresstion dans le bloc <code>do</code> de <code>main</code> reste de la forme <code>IO a</code>. La seule construction étrange est <code>error</code>. Je dirais juste que <code>error msg</code> prend le type nécessaire (ici, <code>IO ()</code>).</p>
<p>Un chose très importante à noter est le type de toutes les fonctions définies jusqu’ici. Il n’y a qu’une seule fonction qui contient <code>IO</code> dans son type: <code>main</code>. Cela signifie que <code>main</code> est impure. Mais <code>main</code> utilise <code>getListFromString</code>, qui est pure. Nous pouvons donc facilement repérer quelles fonctions sont pures et lesquelles sont impures, seulement en regardant leurs type.</p>
<p>Pourquoi la pureté a-t-elle de l’importance? Parmis ses nombreux avantages, en voici trois:</p>
<ul>
<li>Il est beaucoup plus facile de penser à du code pur qu’à du code impur.</li>
<li>La pureté vous protège de tous les bugs difficiles à reproduire qui sont dûs aux effets collatéraux.</li>
<li>Vous pouvez évaluer des fonctions pures dans n’importe quell ordre ou en parallèle, sans prendre de risques.</li>
</ul>
<p>C’est pourquoi vous devriez mettre le plus de code possible dans des fonctions pures.</p>
<p><a href="code/03_Hell/01_IO/02_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>02_progressive_io_example.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Hell/01_IO/03_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>03_progressive_io_example.lhs</strong></a></p>
<p>La prochaine étape sera de demader la liste de nombre à l’utilisateur encore et encore jusqu’à ce qu’il entre une réponse valide</p>
<p>Nous gardons la première partie:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="ot">maybeRead ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
maybeRead s <span class="fu">=</span> <span class="kw">case</span> reads s <span class="kw">of</span>
                  [(x,<span class="st">&quot;&quot;</span>)]    <span class="ot">-&gt;</span> <span class="dt">Just</span> x
                  _           <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">getListFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Integer</span>]
getListFromString str <span class="fu">=</span> maybeRead <span class="fu">$</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;]&quot;</span></code></pre>
</div>
<p>Maintenant nous créons la fonction qui demandera une liste d’entiers à l’utilisateur jusqu’à ce que l’entrée soit correcte</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]
askUser <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a list of numbers (separated by comma):&quot;</span>
  input <span class="ot">&lt;-</span> getLine
  <span class="kw">let</span> maybeList <span class="fu">=</span> getListFromString input <span class="kw">in</span>
      <span class="kw">case</span> maybeList <span class="kw">of</span>
          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> return l
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</code></pre>
</div>
<p>Cette fonction est de type <code>IO [Integer]</code>. cela signifie que la valeur trouvée est de type <code>[Integer</code>] et est le résultat d’actions d’E/S. Certaines personnes expliqueraient en agitant leurs mains:</p>
<blockquote>
<p>«C’est un <code>[Integer]</code> dans un <code>IO</code>»</p>
</blockquote>
<p>Si vous voulez comprendre les détails derrière tout cela, vous devrez lire la prochaine section. MAis si vous voulez seulement <em>utiliser</em> l’E/S, pratiquer juste une peu et rappelez-vous de penser aux types.</p>
<p>Finalement notre fonction <code>main</code>est plus simple:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  list <span class="ot">&lt;-</span> askUser
  print <span class="fu">$</span> sum list</code></pre>
</div>
<p>Nous avons fini notre introduction à l’<code>IO</code>. C’était rapide. Voici les principales choses à se rappeler:</p>
<ul>
<li>Dans le bloc <code>do</code>, chaque expression doit avoir le type <code>IO a</code>. Vous êtes donc limité dans le nombre d’expression disponibles. Par exemple, <code>getLine</code>, <code>print</code>, <code>putStrLn</code>, etc…</li>
<li>Essayez d’externaliser le plus possible les fonctions pures.</li>
<li>le type <code>IO a</code> signifie: un <em>action</em> d’E/S qui retourne un élément de type a. L’<code>IO</code> représente des actions; <code>IO a</code> est le type d’une fonction. Lisez la prochaine section si vous êtes curieux.</li>
</ul>
<p>Si vous pratiquez un peu, vous devriez être capable d’<em>utiliser</em> l’<code>IO</code>.</p>
<blockquote>
<p>-Exercices_:</p>
<ul>
<li>Faites un programme qui additionne tous ses arguments. Utilisez la fonction <code>getArgs</code>.</li>
</ul>
</blockquote>
<p><a href="code/03_Hell/01_IO/03_progressive_io_example.lhs" class="cut">03_Hell/01_IO/<strong>03_progressive_io_example.lhs</strong> </a></p>
<h3 id="io-trick-explained">
Le truc des IO révélé
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/magritte_pipe.jpg" alt="Magritte, ceci n"/>
</div>
<blockquote>
<p>Voici un <span class="sc"><abbr title="Trop long; pas lu">tlpl</abbr>: </span> pour cette section.</p>
<p>Pour séparer les parties pures et impures, <code>main</code> est définie comme une fonction. qui modifie l’état du monde.</p>
<pre><code>main :: World -&gt; World</code></pre>
<p>Une fonction aura des effets collatéraux si elle a ce type. Mais regardez cette fonction <code>main</code> typique:</p>
<pre><code>
main w0 =
    let (v1,w1) = action1 w0 in
    let (v2,w2) = action2 v1 w1 in
    let (v3,w3) = action3 v2 w2 in
    action4 v3 w3</code></pre>
<p>Nous avons beaucoup d’élements temporaires (ici, <code>w1</code>, <code>w2</code> et <code>w3</code>) qui doivent être passés à la prochauine action.</p>
<p>Nous créons une fonction <code>bind</code> ou <code>(&gt;&gt;=)</code>. Avec <code>bind</code> nous n’avons plus besoin de noms temporaires.</p>
<pre><code>main =
  action1 &gt;&gt;= action2 &gt;&gt;= action3 &gt;&gt;= action4</code></pre>
<p>Bonus: Haskell a un sucre syntaxique:</p>
<pre><code>main = do
  v1 &lt;- action1
  v2 &lt;- action2 v1
  v3 &lt;- action3 v2
  action4 v3</code></pre>
</blockquote>
<p>Pourquoi avons-nous utilisé cette syntaxe étrange, et quel est exactement le type <code>IO</code>? Cela peut sembler un peu magique.</p>
<p>Pour l’instant, oublions les parties pures de notre programme, et concentrons-nous sur les parties impures:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]
askUser <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a list of numbers (separated by commas):&quot;</span>
  input <span class="ot">&lt;-</span> getLine
  <span class="kw">let</span> maybeList <span class="fu">=</span> getListFromString input <span class="kw">in</span>
      <span class="kw">case</span> maybeList <span class="kw">of</span>
          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> return l
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  list <span class="ot">&lt;-</span> askUser
  print <span class="fu">$</span> sum list</code></pre>
<p>Première remarque: on dirait de l’impératif. Haskell est assez puissant pour faire sembler impératif du code impur. Par exemple, si vous le vouliez vous pourriez créer <code>while</code> en Haskell. En fait, pour utiliser les <code>IO</code>, le style impératif est généralement plus approprié.</p>
<p>Mais vous devriez avoir remarqué que la notation est inhabituelle. Voici pourquoi, en détail.</p>
<p>Dans un langage impur, l’état du monde peut être vu comme une énorme variable globale cachée. Cette variable cachée est accessible par toutes les fonctions du langage/ Par exemple, vous pouvez lire et écrire un fichier dans n’importe quelle fonction. L’existence hypothétique du fichier est une différence dans les états possibles que le monde peut prendre.</p>
<p>En Haskell cet état n’est pas caché. Au contraire, il est dit <em>explicitement</em> que <code>main</code> est une fonction qui change <em>potentiellement</em> l’état du monde. Son type est donc quelque chose comme:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> <span class="dt">World</span></code></pre>
<p>Les fonctions n’ont pas toutes accès à cette variable. Celle qui y ont accès sont impures. Les fonctions qui ne peuvent pas agir sur la variable sont pures<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</p>
<p>Haskell considère l’état u monde comme une variable à passer à <code>main</code>. Mais son type réel est plus proche de celui ci<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> ((),<span class="dt">World</span>)</code></pre>
<p>Le type <code>()</code> est le type unité. Rien à voir ici.</p>
<p>Maintenant reécrivons notre fonction <code>main</code> avec cela à l’esprit:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main w0 <span class="fu">=</span>
    <span class="kw">let</span> (list,w1) <span class="fu">=</span> askUser w0 <span class="kw">in</span>
    <span class="kw">let</span> (x,w2) <span class="fu">=</span> print (sum list,w1) <span class="kw">in</span>
    x</code></pre>
<p>D’abord, on remarque que toutes les fonctions avec des effets collatéraux doivent avoir le type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">World</span> <span class="ot">-&gt;</span> (a,<span class="dt">World</span>)</code></pre>
<p>ou <code>a  est le type du résultat. Par exemple, un fonction</code>getChar<code>aura le type</code>World -&gt; (Char, World).</p>
<p>Une autre chose à noter est le truc pour corriger l’ordre d’évaluation. En Haskell, pour évaluer <code>f a b</code>, vous avez beaucoup de choix:</p>
<ul>
<li>évaluer d’abord <code>a</code> puis <code>b</code> puis <code>f a b</code></li>
<li>évaluer d’abord <code>b</code> puis <code>a</code> puis <code>f a b</code></li>
<li>évaluer <code>a</code> et <code>b</code> en même temps puis <code>f a b</code></li>
</ul>
<p>Ceci est vrai car nous travaillons sur une partie pure du langage.</p>
<p>Maintenant, si vous regardez la fonction <code>main</code>, vous voyez tout de suite qu’il faut évaluer la première ligne avant la seconde, car pour évaluer la seconde ligne vous devez utliser un parmètre donné par l’évaluation de la première ligne.</p>
<p>Ce truc marche très bien. Le compilateur donnera à chaque étape un pointeur sur l’id d’un vrai monde. En réalité, <code>print</code> sera évaluée comme:</p>
<ul>
<li>Écrit quelque chose sur l’écran</li>
<li>Modifie l’id du monde</li>
<li>renvoyer <code>((), id du nouveau monde)</code>.</li>
</ul>
<p>Maintenant, si vous regardez le style de la fonction <code>main</code>, c’est clairement peu maniable. Essayons de fair la même chose avec la fonction <code>askUser</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">askUser ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> ([<span class="dt">Integer</span>],<span class="dt">World</span>)</code></pre>
<p>Avant:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]
askUser <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a list of numbers:&quot;</span>
  input <span class="ot">&lt;-</span> getLine
  <span class="kw">let</span> maybeList <span class="fu">=</span> getListFromString input <span class="kw">in</span>
      <span class="kw">case</span> maybeList <span class="kw">of</span>
          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> return l
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser</code></pre>
<p>Après:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">askUser w0 <span class="fu">=</span>
    <span class="kw">let</span> (_,w1)     <span class="fu">=</span> putStrLn <span class="st">&quot;Enter a list of numbers:&quot;</span> <span class="kw">in</span>
    <span class="kw">let</span> (input,w2) <span class="fu">=</span> getLine w1 <span class="kw">in</span>
    <span class="kw">let</span> (l,w3)     <span class="fu">=</span> <span class="kw">case</span> getListFromString input <span class="kw">of</span>
                      <span class="dt">Just</span> l   <span class="ot">-&gt;</span> (l,w2)
                      <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> askUser w2
    <span class="kw">in</span>
        (l,w3)</code></pre>
<p>C’est similaire, mais malaisé. Voyez ces noms temporaires <code>w?</code>.</p>
<p>Voici la leçon: l’implémentation naïve des IO dans les langages fonctionnels purs est maladroite!</p>
<p>Heureusement, il ya un meilleur moyen de résoudre ce problème. Nous voyons un motif. Chaque ligne est de la forme:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> (y,w&#39;) <span class="fu">=</span> action x w <span class="kw">in</span></code></pre>
<p>Même si pour quelques lignes l’argument <code>x</code> n’est pas nécessaire. La sortie est un couple, <code>(answer, newWorldValue)</code>. Chaque fonction <code>f</code> doit avoir un type similaire à:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">World</span> <span class="ot">-&gt;</span> (a,<span class="dt">World</span>)</code></pre>
<p>Il n’y apas seulement ça, nous pouvons aussi remarquer que nous suivaons toujours le même motif:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> (y,w1) <span class="fu">=</span> action1 w0 <span class="kw">in</span>
<span class="kw">let</span> (z,w2) <span class="fu">=</span> action2 w1 <span class="kw">in</span>
<span class="kw">let</span> (t,w3) <span class="fu">=</span> action3 w2 <span class="kw">in</span>
<span class="fu">...</span></code></pre>
<p>Chaque action peut prendre de 0 à n paramètres. Et en particulier, chaque action peut prendre comme paramètre le résultat de la ligne du dessus.</p>
<p>Par exemple, nous pourrions aussi avoir:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> (_,w1) <span class="fu">=</span> action1 x w0   <span class="kw">in</span>
<span class="kw">let</span> (z,w2) <span class="fu">=</span> action2 w1     <span class="kw">in</span>
<span class="kw">let</span> (_,w3) <span class="fu">=</span> action3 x z w2 <span class="kw">in</span>
<span class="fu">...</span></code></pre>
<p>Et, bien entendu, <code>actionN w :: (World) -&gt; (a,World)</code>.</p>
<blockquote>
<p>IMPORTANT: Il y a seulement 2 patterns importants à considérer:</p>
<pre><code>let (x,w1) = action1 w0 in
let (y,w2) = action2 x w1 in</code></pre>
<p>et</p>
<pre><code>let (_,w1) = action1 w0 in
let (y,w2) = action2 w1 in</code></pre>
</blockquote>
<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/jocker_pencil_trick.jpg" alt="Jocker pencil trick" class="left"/>
</div>
<p>Maintenant nous allons faire un tour de magie. Nous allons faire disparaître le symbole temporaire du monde. Nous allons <code>attacher</code> (<em>NDT: <code>bind</code> en anglais</em>) les deux lignes. Définissons la fonction <code>bind</code>. Son type est intimidant au départ:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> (<span class="dt">World</span> <span class="ot">-&gt;</span> (a,<span class="dt">World</span>))
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (<span class="dt">World</span> <span class="ot">-&gt;</span> (b,<span class="dt">World</span>)))
        <span class="ot">-&gt;</span> (<span class="dt">World</span> <span class="ot">-&gt;</span> (b,<span class="dt">World</span>))</code></pre>
<p>Mais rappelez-vous que <code>(World -&gt; (a,World))</code> est le type d’un action des IO. Renommons-le pour plus de clareté:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">IO</span> a <span class="fu">=</span> <span class="dt">World</span> <span class="ot">-&gt;</span> (a, <span class="dt">World</span>)</code></pre>
<p>Quelques exemples de fonctions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">getLine<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span>
print<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre>
<p><code>getLine</code> est une action d’E/S qui prend le monde en paramètre et retourne un couple <code>(String, World)</code>. Cela peut être résumé par: <code>getLine</code> est de type <code>IO String</code>, que nous pouvons voir comme une action ’E/S qui retournera une chaîne de caractères “dans une E/S”.</p>
<p>La fonction <code>print</code> est elle aussi intéressante. Elle prend un argument qui peut être montré. En réalité elle prend deux arguments. LE premier est la valeur et le deuxième est l’état du monde. Elle retourne un couple de type <code>((), World)</code>. Cela signifie qu’elle change l’état du monde, mais ne produit pas d’autre donnée.</p>
<p>Ce type nous aide à simplifier le type de <code>bind</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">IO</span> a
        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> b</code></pre>
<p>Cela dit que <code>bind</code> prend deux action d’E/S comme paramètres et retourne une autre action d’E/S.</p>
<p>Maintenant, rappelez-vous des motifs <em>importants</em>. Le premier était:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> (x,w1) <span class="fu">=</span> action1 w0 <span class="kw">in</span>
<span class="kw">let</span> (y,w2) <span class="fu">=</span> action2 x w1 <span class="kw">in</span>
(y,w2)</code></pre>
<p>Voyez les types:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">action1  ::</span> <span class="dt">IO</span> a
<span class="ot">action2  ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b
(y,w2)<span class="ot">   ::</span> <span class="dt">IO</span> b</code></pre>
<p>Cela ne vous semble pas familier?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(bind action1 action2) w0 <span class="fu">=</span>
    <span class="kw">let</span> (x, w1) <span class="fu">=</span> action1 w0
        (y, w2) <span class="fu">=</span> action2 x w1
    <span class="kw">in</span>  (y, w2)</code></pre>
<p>L’idée est de cacher l’argument <code>World</code> avec cette fonction. Allons-y: Par exemple si nous avions voulu simuler:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> (line1,w1) <span class="fu">=</span> getLine w0 <span class="kw">in</span>
<span class="kw">let</span> ((),w2) <span class="fu">=</span> print line1 <span class="kw">in</span>
((),w2)</code></pre>
<p>Maintenant, en utilisant la fonction <code>bind</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(res,w2) <span class="fu">=</span> (bind getLine (\l <span class="ot">-&gt;</span> print l)) w0</code></pre>
<p>Comme <code>print</code> est de type <code>(World -&gt; ((),World))</code>, nous savons que <code>res = ()</code> (type nul) Si vous ne voyez pas ce qui est magique ici, essayons avec trois lignes cette fois.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> (line1,w1) <span class="fu">=</span> getLine w0 <span class="kw">in</span>
<span class="kw">let</span> (line2,w2) <span class="fu">=</span> getLine w1 <span class="kw">in</span>
<span class="kw">let</span> ((),w3) <span class="fu">=</span> print (line1 <span class="fu">++</span> line2) <span class="kw">in</span>
((),w3)</code></pre>
<p>Qui est équivalent à:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(res,w3) <span class="fu">=</span> (bind getLine (\line1 <span class="ot">-&gt;</span>
             (bind getLine (\line2 <span class="ot">-&gt;</span>
               print (line1 <span class="fu">++</span> line2))))) w0</code></pre>
<p>Avez-vous remarqué quelque chose ? Oui, aucune variable <code>World</code> temporaire n’est utilisée! C’est <em>MA</em>.<em>GIQUE</em>.</p>
<p>Nous pouvons utiliser une meilleure notation. Utilisons <code>(&gt;&gt;=)</code> au lieu de <code>bind</code>. `<code>est une fonction infixe, comme</code>(+)<code>; pour mémoire:</code>3 + 4 ⇔ (+) 3 4`</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">(res,w3) <span class="fu">=</span> (getLine <span class="fu">&gt;&gt;=</span>
           (\line1 <span class="ot">-&gt;</span> getLine <span class="fu">&gt;&gt;=</span>
           (\line2 <span class="ot">-&gt;</span> print (line1 <span class="fu">++</span> line2)))) w0</code></pre>
<p>Ho Ho Ho! Joyeux Noël! fr; HAskell a un sucre syntaxique pour nous:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span>
  x <span class="ot">&lt;-</span> action1
  y <span class="ot">&lt;-</span> action2
  z <span class="ot">&lt;-</span> action3
  <span class="fu">...</span></code></pre>
<p>Est remplacé par:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span>
action2 <span class="fu">&gt;&gt;=</span> (\y <span class="ot">-&gt;</span>
action3 <span class="fu">&gt;&gt;=</span> (\z <span class="ot">-&gt;</span>
<span class="fu">...</span>
)))</code></pre>
<p>Remarquez que vous pouvez utliser <code>x</code> dans <code>action2</code> et <code>x</code> et <code>y</code> dans <code>action3</code></p>
<p>Mais que se passe-t-il pour les lignes qui n’utilisent pas le <code>&lt;-</code>? FAcile, une autre fonction <code>blindBind</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">blindBind ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b
blindBind action1 action2 w0 <span class="fu">=</span>
    bind action (\_ <span class="ot">-&gt;</span> action2) w0</code></pre>
<p>Je n’ai pas simplifié cette définition pour plus de clareté. Bien sûr, nous pouvons utiliser une meilleure notation avec l’opérateur <code>(&gt;&gt;)</code>.</p>
<p>Et</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span>
    action1
    action2
    action3</code></pre>
<p>Est transformé en</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">action1 <span class="fu">&gt;&gt;</span>
action2 <span class="fu">&gt;&gt;</span>
action3</code></pre>
<p>Aussi, une autre fonction est réellement utile.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">putInIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
putInIO x <span class="fu">=</span> <span class="dt">IO</span> (\w <span class="ot">-&gt;</span> (x,w))</code></pre>
<p>C’est le moyen énéral de mettre des valeurs pures dans le “contexte d’E/S”. Le nom général pour <code>putInIO</code> est <code>return</code>. C’est un très mauvais nom lorsque vous commencer à programmer en Haskell. <code>return</code> est très différent de ce que vous pourriez être habitué à utliser.</p>
<hr/>
<p><a href="code/03_Hell/01_IO/21_Detailled_IO.lhs" class="cut">03_Hell/01_IO/<strong>21_Detailled_IO.lhs</strong></a></p>
<p>Pour finir, traduisons notre exemple:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]
askUser <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Enter a list of numbers (separated by commas):&quot;</span>
  input <span class="ot">&lt;-</span> getLine
  <span class="kw">let</span> maybeList <span class="fu">=</span> getListFromString input <span class="kw">in</span>
      <span class="kw">case</span> maybeList <span class="kw">of</span>
          <span class="dt">Just</span> l  <span class="ot">-&gt;</span> return l
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  list <span class="ot">&lt;-</span> askUser
  print <span class="fu">$</span> sum list</code></pre>
<p>Est traduis en:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Maybe</span>

<span class="ot">maybeRead ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
maybeRead s <span class="fu">=</span> <span class="kw">case</span> reads s <span class="kw">of</span>
                  [(x,<span class="st">&quot;&quot;</span>)]    <span class="ot">-&gt;</span> <span class="dt">Just</span> x
                  _           <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
<span class="ot">getListFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Integer</span>]
getListFromString str <span class="fu">=</span> maybeRead <span class="fu">$</span> <span class="st">&quot;[&quot;</span> <span class="fu">++</span> str <span class="fu">++</span> <span class="st">&quot;]&quot;</span>
<span class="ot">askUser ::</span> <span class="dt">IO</span> [<span class="dt">Integer</span>]
askUser <span class="fu">=</span> 
    putStrLn <span class="st">&quot;Enter a list of numbers (sep. by commas):&quot;</span> <span class="fu">&gt;&gt;</span>
    getLine <span class="fu">&gt;&gt;=</span> \input <span class="ot">-&gt;</span>
    <span class="kw">let</span> maybeList <span class="fu">=</span> getListFromString input <span class="kw">in</span>
      <span class="kw">case</span> maybeList <span class="kw">of</span>
        <span class="dt">Just</span> l <span class="ot">-&gt;</span> return l
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> askUser

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> askUser <span class="fu">&gt;&gt;=</span>
  \list <span class="ot">-&gt;</span> print <span class="fu">$</span> sum list</code></pre>
</div>
<p>vous pouvez compiler ce code pour vérifier qu’il marche.</p>
<p>Imaginez à quoi il ressemblerait sans le <code>(&gt;&gt;)</code> et <code>(&gt;&gt;=)</code>.</p>
<p><a href="code/03_Hell/01_IO/21_Detailled_IO.lhs" class="cut">03_Hell/01_IO/<strong>21_Detailled_IO.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Hell/02_Monads/10_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>10_Monads.lhs</strong></a></p>
<h3 id="monads">
Les monades
</h3>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/dali_reve.jpg" alt="Dali, reve. It represents a weapon out of the mouth of a tiger, itself out of the mouth of another tiger, itself out of the mouth of a fish itself out of a grenade. I could have choosen a picture of the Human centipede as it is a very good representation of what a monad really is. But just to think about it, I find this disgusting and that wasn"/>
</div>
<p>Maintenant le secret peut être révélé: <code>IO</code> est une <em>monade</em>. Être une monade signifie que vous avez accès à du sucre syntaxique avec la notation <code>do</code>. Mais principalement, vous avez accès à un motif de codage qui tempérera le flux de votre code.</p>
<blockquote>
<p><strong>Remarques importantes</strong>:</p>
<ul>
<li>Le monades n’ont pas forcément quelque chose à voir avec les effets! Il y a beaucoup de monades <em>pures</em>.</li>
<li>Les monades ont plus à faire avec du séquençage.</li>
</ul>
</blockquote>
<p>En Haskell, <code>Monad</code> est une classe de type. Pour être une instance d’une classe de type, vous devez fournir les fonctions <code>(&gt;&gt;=)</code> et <code>return</code>. La fonction <code>(&gt;&gt;)</code> est dérivée de <code>(&gt;&gt;=)</code>. Voici commment la classe de typr <code>Monad</code> est déclarée (basiquement):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m  <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
<span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a

<span class="ot">  (&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
  f <span class="fu">&gt;&gt;</span> g <span class="fu">=</span> f <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> g

  <span class="co">-- Vous pouvez ignorer cette fonction généralement,</span>
  <span class="co">-- je crois qu&#39;elle existe pour des raisons historiques</span>
<span class="ot">  fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a
  fail <span class="fu">=</span> error</code></pre>
<blockquote>
<p>Remarques:</p>
<ul>
<li>le mot-clé <code>class</code> n’est pas votre ami. Une classe en Haskell <em>n’est pas</em> du même genre que celle des langages orientés-objet. Elles ont beaucoup de similarités avec les interfaces de Java. Un meilleur mot aurait été <code>typeClass</code>, ce qui signifierait un ensemble de types. Pour qu’un type appartiennent à une classe, toutes les fonctions de cette classe doivent être fournies pour ce type.</li>
<li>Dans cet exemple particulier de classe de type, le type <code>m</code> doit être un type qui prend un argument. par exemple <code>IO a</code>, mais aussi <code>Maybe a</code>, <code>[a]</code>, etc…</li>
<li>Pour être une monade utile, votre fonction doit obéir à quelques règles. Si votre construction n’obéit pas à ces règles, des choses étranges pourrait se produire:</li>
</ul>
<p><sub>~</sub> return a &gt;&gt;= k == k a m &gt;&gt;= return == m m &gt;&gt;= (-&gt; k x &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h <sub>~</sub></p>
</blockquote>
<h4 id="maybe-monad">
Maybe est une monade
</h4>

<p>Il y a beaucoup de types différents qui sont des instances de <code>Monad</code>. L’un des plus faciles à décrire est <code>Maybe</code>. Si vous avez une séquence de valeurs <code>Maybe</code>, vous pouvez utiliser les monades pour les manipuler. C’est particulièrement utile pour enlever des constructions <code>if..then..else..</code> trop nombreuses.</p>
<p>Imaginez une opération bancaire complexe. Vous êtes éligible pour gagner 700€ seulement si vous pouvez effectuer une liste d’opérations sans tomber en dessous de zéro.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">deposit  value account <span class="fu">=</span> account <span class="fu">+</span> value
withdraw value account <span class="fu">=</span> account <span class="fu">-</span> value

<span class="ot">eligible ::</span> (<span class="dt">Num</span> a,<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
eligible account <span class="fu">=</span>
  <span class="kw">let</span> account1 <span class="fu">=</span> deposit <span class="dv">100</span> account <span class="kw">in</span>
    <span class="kw">if</span> (account1 <span class="fu">&lt;</span> <span class="dv">0</span>)
    <span class="kw">then</span> <span class="dt">False</span>
    <span class="kw">else</span>
      <span class="kw">let</span> account2 <span class="fu">=</span> withdraw <span class="dv">200</span> account1 <span class="kw">in</span>
      <span class="kw">if</span> (account2 <span class="fu">&lt;</span> <span class="dv">0</span>)
      <span class="kw">then</span> <span class="dt">False</span>
      <span class="kw">else</span>
        <span class="kw">let</span> account3 <span class="fu">=</span> deposit <span class="dv">100</span> account2 <span class="kw">in</span>
        <span class="kw">if</span> (account3 <span class="fu">&lt;</span> <span class="dv">0</span>)
        <span class="kw">then</span> <span class="dt">False</span>
        <span class="kw">else</span>
          <span class="kw">let</span> account4 <span class="fu">=</span> withdraw <span class="dv">300</span> account3 <span class="kw">in</span>
          <span class="kw">if</span> (account4 <span class="fu">&lt;</span> <span class="dv">0</span>)
          <span class="kw">then</span> <span class="dt">False</span>
          <span class="kw">else</span>
            <span class="kw">let</span> account5 <span class="fu">=</span> deposit <span class="dv">1000</span> account4 <span class="kw">in</span>
            <span class="kw">if</span> (account5 <span class="fu">&lt;</span> <span class="dv">0</span>)
            <span class="kw">then</span> <span class="dt">False</span>
            <span class="kw">else</span>
              <span class="dt">True</span>

main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> eligible <span class="dv">300</span> <span class="co">-- True</span>
  print <span class="fu">$</span> eligible <span class="dv">299</span> <span class="co">-- False</span></code></pre>
</div>
<p><a href="code/03_Hell/02_Monads/10_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>10_Monads.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Hell/02_Monads/11_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>11_Monads.lhs</strong></a></p>
<p>Maintenant, améliorons cela en utilisant le fait que <code>Maybe</code> est une Monade.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">deposit ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
deposit value account <span class="fu">=</span> <span class="dt">Just</span> (account <span class="fu">+</span> value)

<span class="ot">withdraw ::</span> (<span class="dt">Num</span> a,<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
withdraw value account <span class="fu">=</span> <span class="kw">if</span> (account <span class="fu">&lt;</span> value) 
                         <span class="kw">then</span> <span class="dt">Nothing</span> 
                         <span class="kw">else</span> <span class="dt">Just</span> (account <span class="fu">-</span> value)

<span class="ot">eligible ::</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
eligible account <span class="fu">=</span> <span class="kw">do</span>
  account1 <span class="ot">&lt;-</span> deposit <span class="dv">100</span> account 
  account2 <span class="ot">&lt;-</span> withdraw <span class="dv">200</span> account1 
  account3 <span class="ot">&lt;-</span> deposit <span class="dv">100</span> account2 
  account4 <span class="ot">&lt;-</span> withdraw <span class="dv">300</span> account3 
  account5 <span class="ot">&lt;-</span> deposit <span class="dv">1000</span> account4
  <span class="dt">Just</span> <span class="dt">True</span>

main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> eligible <span class="dv">300</span> <span class="co">-- Just True</span>
  print <span class="fu">$</span> eligible <span class="dv">299</span> <span class="co">-- Nothing</span></code></pre>
</div>
<p><a href="code/03_Hell/02_Monads/11_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>11_Monads.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Hell/02_Monads/12_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>12_Monads.lhs</strong></a></p>
<p>Pas mauvais, mais nous pouvons faire encore mieux:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">deposit ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
deposit value account <span class="fu">=</span> <span class="dt">Just</span> (account <span class="fu">+</span> value)

<span class="ot">withdraw ::</span> (<span class="dt">Num</span> a,<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
withdraw value account <span class="fu">=</span> <span class="kw">if</span> (account <span class="fu">&lt;</span> value) 
                         <span class="kw">then</span> <span class="dt">Nothing</span> 
                         <span class="kw">else</span> <span class="dt">Just</span> (account <span class="fu">-</span> value)

<span class="ot">eligible ::</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
eligible account <span class="fu">=</span>
  deposit <span class="dv">100</span> account <span class="fu">&gt;&gt;=</span>
  withdraw <span class="dv">200</span> <span class="fu">&gt;&gt;=</span>
  deposit <span class="dv">100</span>  <span class="fu">&gt;&gt;=</span>
  withdraw <span class="dv">300</span> <span class="fu">&gt;&gt;=</span>
  deposit <span class="dv">1000</span> <span class="fu">&gt;&gt;</span>
  return <span class="dt">True</span>

main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> eligible <span class="dv">300</span> <span class="co">-- Just True</span>
  print <span class="fu">$</span> eligible <span class="dv">299</span> <span class="co">-- Nothing</span></code></pre>
</div>
<p>Nous avons prouvé que les monades sont un bon moyen de rendre notre code plus élégant. Remarquez que cette idée d’organisation de code, en particulier pour <code>Maybe</code>, peut être utilisée dans la plupart des langages impératifs. En fait, c’est le type de construction que nous faisons naturellement.</p>
<blockquote>
<p>Un remarque importante:</p>
<p>Le premier élement de la séquence qui sera évalué comme <code>Nothing</code> stoppera l’évaluation. Cela signifie que vous n’exécutez pas toutes les lignes. Vous avgfez cela gratuitement, grâce à la paresse.</p>
</blockquote>
<p>Vous pourriez aussi revoir ces exemples avec la définition de <code>(&gt;&gt;=)</code> pour <code>Maybe</code> en tête:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
<span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
    <span class="dt">Nothing</span>  <span class="fu">&gt;&gt;=</span> _  <span class="fu">=</span> <span class="dt">Nothing</span>
    (<span class="dt">Just</span> x) <span class="fu">&gt;&gt;=</span> f  <span class="fu">=</span> f x

    return x <span class="fu">=</span> <span class="dt">Just</span> x</code></pre>
<p>La monade <code>Maybe</code> a prouvé par un simple exemple qu’elle est utile. Nous avons vu l’utilité de la monade <code>IO</code>. Mais maintenant, voici un exemple plus cool, les listes.</p>
<p><a href="code/03_Hell/02_Monads/12_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>12_Monads.lhs</strong> </a></p>
<hr/>
<p><a href="code/03_Hell/02_Monads/13_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>13_Monads.lhs</strong></a></p>
<h4 id="the-list-monad">
La monade List
</h4>

<div>
<img src="/Scratch/img/blog/Haskell-the-Hard-Way/golconde.jpg" alt="Golconde de Magritte"/>
</div>
<p>La monade List nouis aide à simuler des calculs non-détertiministe. C’est parti:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span> (guard)

allCases <span class="fu">=</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]

<span class="ot">resolve ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>,<span class="dt">Int</span>)]
resolve <span class="fu">=</span> <span class="kw">do</span>
              x <span class="ot">&lt;-</span> allCases
              y <span class="ot">&lt;-</span> allCases
              z <span class="ot">&lt;-</span> allCases
              guard <span class="fu">$</span> <span class="dv">4</span><span class="fu">*</span>x <span class="fu">+</span> <span class="dv">2</span><span class="fu">*</span>y <span class="fu">&lt;</span> z
              return (x,y,z)

main <span class="fu">=</span> <span class="kw">do</span>
  print resolve</code></pre>
</div>
<p>Ma. GIQUE.&nbsp;:</p>
<pre><code>[(1,1,7),(1,1,8),(1,1,9),(1,1,10),(1,2,9),(1,2,10)]</code></pre>
<p>Pour la monade List, il y a aussi un sucre syntaxique:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">  print <span class="fu">$</span> [ (x,y,z) <span class="fu">|</span> x <span class="ot">&lt;-</span> allCases,
                      y <span class="ot">&lt;-</span> allCases,
                      z <span class="ot">&lt;-</span> allCases,
                      <span class="dv">4</span><span class="fu">*</span>x <span class="fu">+</span> <span class="dv">2</span><span class="fu">*</span>y <span class="fu">&lt;</span> z ]</code></pre>
</div>
<p>Je ne listerais pas toutes les monades, mais il y en a beaucoup. Utiliser les monades simplifie la manipulations de plusieurs notions dans les langages purs. Les monades sont très utiles, en particulier pour:</p>
<ul>
<li>L’E/S;</li>
<li>calculs non-déterministes,</li>
<li>générer des nombres pseudo-aléatoires,</li>
<li>garder un état de configuration,</li>
<li>écrire un état,</li>
<li>…</li>
</ul>
<p>Si vous m’avez suivi jusqu’ici, alors vous avez terminé! Vous connaissez les monades<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>!</p>
<p><a href="code/03_Hell/02_Monads/13_Monads.lhs" class="cut">03_Hell/02_Monads/<strong>13_Monads.lhs</strong> </a></p>
<h2 id="appendix">
Appendice
</h2>

<p>Cette section n’est pas vraiment sur l’apprentissage d’Haskell. Elle est ici pour discuter de quelques détails.</p>
<hr/>
<p><a href="code/04_Appendice/01_More_on_infinite_trees/10_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>10_Infinite_Trees.lhs</strong></a></p>
<h3 id="more-on-infinite-tree">
Revenons sur les arbres infinis
</h3>

<p>Dans la section sur <a href="#infinite-structures">les structures infinies</a> nous avons vu quelques constructions simples. Malheureusement, nous avons enlevé deux propriétés de notre arbre:</p>
<ol style="list-style-type: decimal">
<li>Pas de valeurs identiques</li>
<li>Arbre bien ordonné</li>
</ol>
<p>Dans cette section nous allons tenter de garder la première propriété. Concernant la seconde, nous ne devons pas nous en préoccuper ici mais nous discuterons de comment la garder le plus possible.</p>
<div style="display:none">
<p>This code is mostly the same as the one in the <a href="#trees">tree section</a>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Empty</span> 
                 <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a) 
                  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>)

<span class="co">-- declare BinTree a to be an instance of Show</span>
<span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span>
  <span class="co">-- will start by a &#39;&lt;&#39; before the root</span>
  <span class="co">-- and put a : a begining of line</span>
  show t <span class="fu">=</span> <span class="st">&quot;&lt; &quot;</span> <span class="fu">++</span> replace <span class="ch">&#39;\n&#39;</span> <span class="st">&quot;\n: &quot;</span> (treeshow <span class="st">&quot;&quot;</span> t)
    <span class="kw">where</span>
    treeshow pref <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span>
    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span>) <span class="fu">=</span> 
                  (pshow pref x)

    treeshow pref (<span class="dt">Node</span> x left <span class="dt">Empty</span>) <span class="fu">=</span> 
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> left)

    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> right) <span class="fu">=</span> 
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    treeshow pref (<span class="dt">Node</span> x left right) <span class="fu">=</span> 
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;|--&quot;</span> <span class="st">&quot;|  &quot;</span> left) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    <span class="co">-- show a tree using some prefixes to make it nice</span>
    showSon pref before next t <span class="fu">=</span> 
                  pref <span class="fu">++</span> before <span class="fu">++</span> treeshow (pref <span class="fu">++</span> next) t

    <span class="co">-- pshow replace &quot;\n&quot; by &quot;\n&quot;++pref</span>
    pshow pref x <span class="fu">=</span> replace <span class="ch">&#39;\n&#39;</span> (<span class="st">&quot;\n&quot;</span><span class="fu">++</span>pref) (show x)

    <span class="co">-- replace on char by another string</span>
    replace c new string <span class="fu">=</span>
      concatMap (change c new) string
      <span class="kw">where</span>
          change c new x 
              <span class="fu">|</span> x <span class="fu">==</span> c <span class="fu">=</span> new
              <span class="fu">|</span> otherwise <span class="fu">=</span> x<span class="fu">:</span>[] <span class="co">-- &quot;x&quot;</span></code></pre>
</div>
</div>
<p>Notre première étape est de créer une liste de nombres pseudo-aléatoires:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">shuffle <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> (x<span class="fu">*</span><span class="dv">3123</span>) <span class="ot">`mod`</span> <span class="dv">4331</span>) [<span class="dv">1</span><span class="fu">..</span>]</code></pre>
</div>
<p>Pour mémoire, voici la définition de <code>treeFromList</code></p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeFromList []    <span class="fu">=</span> <span class="dt">Empty</span>
treeFromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Node</span> x (treeFromList (filter (<span class="fu">&lt;</span>x) xs))
                             (treeFromList (filter (<span class="fu">&gt;</span>x) xs))</code></pre>
</div>
<p>et <code>treeTakeDepth</code>:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">treeTakeDepth _ <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Empty</span>
treeTakeDepth <span class="dv">0</span> _     <span class="fu">=</span> <span class="dt">Empty</span>
treeTakeDepth n (<span class="dt">Node</span> x left right) <span class="fu">=</span> <span class="kw">let</span>
          nl <span class="fu">=</span> treeTakeDepth (n<span class="fu">-</span><span class="dv">1</span>) left
          nr <span class="fu">=</span> treeTakeDepth (n<span class="fu">-</span><span class="dv">1</span>) right
          <span class="kw">in</span>
              <span class="dt">Node</span> x nl nr</code></pre>
</div>
<p>Voyez le résultats de:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
      putStrLn <span class="st">&quot;take 10 shuffle&quot;</span>
      print <span class="fu">$</span> take <span class="dv">10</span> shuffle
      putStrLn <span class="st">&quot;\ntreeTakeDepth 4 (treeFromList shuffle)&quot;</span>
      print <span class="fu">$</span> treeTakeDepth <span class="dv">4</span> (treeFromList shuffle)</code></pre>
</div>
<pre><code>% runghc 02_Hard_Part/41_Infinites_Structures.lhs
take 10 shuffle
[3123,1915,707,3830,2622,1414,206,3329,2121,913]
treeTakeDepth 4 (treeFromList shuffle)

&lt; 3123
: |--1915
: |  |--707
: |  |  |--206
: |  |  `--1414
: |  `--2622
: |     |--2121
: |     `--2828
: `--3830
:    |--3329
:    |  |--3240
:    |  `--3535
:    `--4036
:       |--3947
:       `--4242</code></pre>
<p>Le code fonctionne! Attention cependant, cela marchere seulement si vous avez toujours quelque chose à mettre dans une branche.</p>
<p>Par exemple</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">treeTakeDepth <span class="dv">4</span> (treeFromList [<span class="dv">1</span><span class="fu">..</span>]) </code></pre>
<p>tournera en boucle pour toujours. Simplement parce que le code essayera d’accéder à première valeur de <code>filter (&lt;1) [2..]</code>. Mais <code>filter</code> n’est pas assez intelligent pour comprendre que le résultat est une liste vide.</p>
<p>Toutefois, cela reste un exemple sympa de ce qu’un programme non-stricit a à offrir.</p>
<p>Laissé pour exercice au lecteur:</p>
<ul>
<li>Prouver l’existence d’un nombre <code>n</code> tel que <code>treeTakeDepth n (treeFromList shuffle)</code> provoquera une boucle infinie.</li>
<li>Trouver une borne supérieur <code>n</code>.</li>
<li>Prouver qu’il n(y a pas de liste <code>shuffle</code> qui termine le programme pour n’importe quelle profondeur.</li>
</ul>
<p><a href="code/04_Appendice/01_More_on_infinite_trees/10_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>10_Infinite_Trees.lhs</strong> </a></p>
<hr/>
<p><a href="code/04_Appendice/01_More_on_infinite_trees/11_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>11_Infinite_Trees.lhs</strong></a></p>
<div style="display:none">
<p>This code is mostly the same as the preceding one.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Debug.Trace</span> (trace)
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Empty</span> 
                 <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a) 
                  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>)</code></pre>
</div>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- declare BinTree a to be an instance of Show</span>
<span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">BinTree</span> a) <span class="kw">where</span>
  <span class="co">-- will start by a &#39;&lt;&#39; before the root</span>
  <span class="co">-- and put a : a begining of line</span>
  show t <span class="fu">=</span> <span class="st">&quot;&lt; &quot;</span> <span class="fu">++</span> replace <span class="ch">&#39;\n&#39;</span> <span class="st">&quot;\n: &quot;</span> (treeshow <span class="st">&quot;&quot;</span> t)
    <span class="kw">where</span>
    treeshow pref <span class="dt">Empty</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span>
    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> <span class="dt">Empty</span>) <span class="fu">=</span> 
                  (pshow pref x)

    treeshow pref (<span class="dt">Node</span> x left <span class="dt">Empty</span>) <span class="fu">=</span> 
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> left)

    treeshow pref (<span class="dt">Node</span> x <span class="dt">Empty</span> right) <span class="fu">=</span> 
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    treeshow pref (<span class="dt">Node</span> x left right) <span class="fu">=</span> 
                  (pshow pref x) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;|--&quot;</span> <span class="st">&quot;|  &quot;</span> left) <span class="fu">++</span> <span class="st">&quot;\n&quot;</span> <span class="fu">++</span>
                  (showSon pref <span class="st">&quot;`--&quot;</span> <span class="st">&quot;   &quot;</span> right)

    <span class="co">-- show a tree using some prefixes to make it nice</span>
    showSon pref before next t <span class="fu">=</span> 
                  pref <span class="fu">++</span> before <span class="fu">++</span> treeshow (pref <span class="fu">++</span> next) t

    <span class="co">-- pshow replace &quot;\n&quot; by &quot;\n&quot;++pref</span>
    pshow pref x <span class="fu">=</span> replace <span class="ch">&#39;\n&#39;</span> (<span class="st">&quot;\n&quot;</span><span class="fu">++</span>pref) (<span class="st">&quot; &quot;</span> <span class="fu">++</span> show x)

    <span class="co">-- replace on char by another string</span>
    replace c new string <span class="fu">=</span>
      concatMap (change c new) string
      <span class="kw">where</span>
          change c new x 
              <span class="fu">|</span> x <span class="fu">==</span> c <span class="fu">=</span> new
              <span class="fu">|</span> otherwise <span class="fu">=</span> x<span class="fu">:</span>[] <span class="co">-- &quot;x&quot;</span>

treeTakeDepth _ <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Empty</span>
treeTakeDepth <span class="dv">0</span> _     <span class="fu">=</span> <span class="dt">Empty</span>
treeTakeDepth n (<span class="dt">Node</span> x left right) <span class="fu">=</span> <span class="kw">let</span>
          nl <span class="fu">=</span> treeTakeDepth (n<span class="fu">-</span><span class="dv">1</span>) left
          nr <span class="fu">=</span> treeTakeDepth (n<span class="fu">-</span><span class="dv">1</span>) right
          <span class="kw">in</span>
              <span class="dt">Node</span> x nl nr</code></pre>
</div>
</div>
<p>Pour résoudre ces problèmes nous allons modifier légèrement nos fonctions <code>treeFromList</code> et <code>shuffle</code>.</p>
<p>Un premier problème est le manque de nombres différents dans notre immlémentation de <code>shuffle</code>. Nous avons généré seulement <code>4331</code> nombres différents. Pour résoudre cela nous allons faire un meilleure fonction <code>shuffle</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">shuffle <span class="fu">=</span> map rand [<span class="dv">1</span><span class="fu">..</span>]
          <span class="kw">where</span> 
              rand x <span class="fu">=</span> ((p x) <span class="ot">`mod`</span> (x<span class="fu">+</span>c)) <span class="fu">-</span> ((x<span class="fu">+</span>c) <span class="ot">`div`</span> <span class="dv">2</span>)
              p x <span class="fu">=</span> m<span class="fu">*</span>x<span class="fu">^</span><span class="dv">2</span> <span class="fu">+</span> n<span class="fu">*</span>x <span class="fu">+</span> o <span class="co">-- some polynome</span>
              m <span class="fu">=</span> <span class="dv">3123</span>    
              n <span class="fu">=</span> <span class="dv">31</span>
              o <span class="fu">=</span> <span class="dv">7641</span>
              c <span class="fu">=</span> <span class="dv">1237</span></code></pre>
</div>
<p>Cette fonction à la propriété de ne pas avoir de bornes supérieure ou inférieure. Mais avoir une meilleure list <code>shuffle</code> n’est pas assez pour entrer dans une boucle infinie.</p>
<p>Généralement, nous ne pouvons pas décider que <code>filter (&lt;x) xs</code> est vide. Donc pour résoudre le problème, je vais autoriser quelques erreurs dans la création de notre arbre binaire. Cette nouvelle version du code peut créer des arbres binaires qui n’ont pas à suivre les propriétés suivantes pour quelque uns de leurs noeuds:</p>
<blockquote>
<p>Tous les élements de la branche de gauche doit être strictement inférieur au la valeur racine.</p>
</blockquote>
<p>Remarquez que cela donnera <em>souvent</em> un arbre ordonné. En outre, avec cette construction, chaque noeud est unique dans l’arbre.</p>
<p>Voici notre nouvelle version de <code>treeFromList</code>. Nous avons simplement remplacé <code>filter</code> par <code>safefilter</code>.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeFromList ::</span> (<span class="dt">Ord</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeFromList []    <span class="fu">=</span> <span class="dt">Empty</span>
treeFromList (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Node</span> x left right
          <span class="kw">where</span> 
              left <span class="fu">=</span> treeFromList <span class="fu">$</span> safefilter (<span class="fu">&lt;</span>x) xs
              right <span class="fu">=</span> treeFromList <span class="fu">$</span> safefilter (<span class="fu">&gt;</span>x) xs</code></pre>
</div>
<p>Cette nouvelle fonction <code>safefilter</code> est presque équivalente à <code>filter</code> mais n’entre pas dans des boucles infinies si le résultat est une liste finie. Si elle ne peut pas trouver un élément pour lequel le test est vrai après 10000 étapes consécutives, alors elle considère que la recherche est finie.</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">safefilter ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
safefilter f l <span class="fu">=</span> safefilter&#39; f l nbTry
  <span class="kw">where</span>
      nbTry <span class="fu">=</span> <span class="dv">10000</span>
      safefilter&#39; _ _ <span class="dv">0</span> <span class="fu">=</span> []
      safefilter&#39; _ [] _ <span class="fu">=</span> []
      safefilter&#39; f (x<span class="fu">:</span>xs) n <span class="fu">=</span> 
                  <span class="kw">if</span> f x 
                     <span class="kw">then</span> x <span class="fu">:</span> safefilter&#39; f xs nbTry 
                     <span class="kw">else</span> safefilter&#39; f xs (n<span class="fu">-</span><span class="dv">1</span>) </code></pre>
</div>
<p>Maintenant faites tourner le programme et soyez heureux:</p>
<div class="codehighlight">
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
      putStrLn <span class="st">&quot;take 10 shuffle&quot;</span>
      print <span class="fu">$</span> take <span class="dv">10</span> shuffle
      putStrLn <span class="st">&quot;\ntreeTakeDepth 8 (treeFromList shuffle)&quot;</span>
      print <span class="fu">$</span> treeTakeDepth <span class="dv">8</span> (treeFromList <span class="fu">$</span> shuffle)</code></pre>
</div>
<p>Vous devriez réaliser que le temps nécessaire pour afficher chaque valeur est différent. C’est parce que Haskell calcule chaque valeur lorsqu’il en a besoin. Et dans ce cas, il est demandé de l’afficher à l’écran.</p>
<p>Vous pouvez même essayer de remplacer la profondeur de <code>8</code> par <code>100</code>. Cela marchera sans tuer votre RAM! La gestion de la mémoire est faite naturellement par Haskell.</p>
<p>Laissé comme exercices au lecteur:</p>
<ul>
<li>Même avec une grande valeur constante pour <code>deep</code> et <code>nbTry</code>, cela semble marcher correctement. Mais dans le pire des cas, cela peut devenir exponentiel. Créez la pire liste à donner comme paramètre à <code>treeFromList</code>. <em>indice</em>: pensez à (<code>[0,-1,-1,....,-1,1,-1,...,-1,1,...]</code>).</li>
<li>J’ai commencé à implémenter <code>safefilter</code> comme ceci:
<pre>
  safefilter' f l = if filter f (take 10000 l) == []
                then []
                else filter f l
  </pre>
  
Expliquer pourquoi cela ne fonctionne pas et peut entrer dans une boucle infinie.</li>
<li>Supposez que <code>shuffle</code> est une liste de nombre réellement aléatoires avec de plus en plus de bornes. Si vous étudiez un peu cette structure, vous découvrirez qu’elle a toutes les chances d’être finie. En utilisant le code suivant (supposez que nous pouvons utliser <code>safefilter'</code> directement comme si cela n’était pas dans le <code>where</code> de <code>safefilter</code>. trouvez une définition de <code>f</code> telle que, avec une probabilité de <code>1</code>, <code>treeFromList' shuffle</code> est infinie?. Et prouvez-le. Avertissement, ce n’est qu’une conjecture.</li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell">treeFromList&#39; []  n <span class="fu">=</span> <span class="dt">Empty</span>
treeFromList&#39; (x<span class="fu">:</span>xs) n <span class="fu">=</span> <span class="dt">Node</span> x left right
    <span class="kw">where</span>
        left <span class="fu">=</span> treeFromList&#39; (safefilter&#39; (<span class="fu">&lt;</span>x) xs (f n)
        right <span class="fu">=</span> treeFromList&#39; (safefilter&#39; (<span class="fu">&gt;</span>x) xs (f n)
        f <span class="fu">=</span> <span class="fu">???</span></code></pre>
<p><a href="code/04_Appendice/01_More_on_infinite_trees/11_Infinite_Trees.lhs" class="cut">04_Appendice/01_More_on_infinite_trees/<strong>11_Infinite_Trees.lhs</strong> </a></p>
<h2 id="remerciements">Remerciements</h2>
<p>Merci à <a href="http://reddit.com/r/haskell"><code>/r/haskell</code></a> et <a href="http://reddit.com/r/programming"><code>/r/programming</code></a>. Vos commentaires étaient plus que bienvenus.</p>
<p>Particulièrement, je voudrais remercier mille fois <a href="https://github.com/Emm">Emm</a> pour le temps qu’il a consacré à corriger mon anglais. Merci beaucoup.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Même si tous les langages récents essayent de les cacher, ils restent présents.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Je sais que je triche. Mais je parlerais de la non-rigueur plus tard. <!-- IL FAUDRA TROUVER UNE AUTRE TRADUCTION POUR NON-STRICTNESS --><a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Qui est elle-même très similaire à la fonction <code>eval</code> de javascript, appliquée sur une chaîne contenant du code au format JSON.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Il y a quelques exceptions <em>peu sûres</em> à cette règle. Mais vous ne devriez pas en voir en application réelle, sauf pour le <em>debugging</em>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Pour les curieux, le vrai type est <code>data IO a = IO {unIO :: State# RealWorld -&gt; (# State# RealWorld, a #)}</code>. Tous les <code>#</code> ont rapport avec l’optimisation et j’ai échangé quelques champs dans mon exemple. Mais c’est l’idée de base.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>Vous aurez quand même besoin de pratiquer un peu pour vous habituer à elles et pour comprendre quand les utiliser ou créer les vôtres. Mais vous avez déjà fait un grand pas dans cette direction.<a href="#fnref6">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>

</feed>
