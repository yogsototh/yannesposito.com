<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>YBlog - Absorb Github Events</title>
        <meta name="keywords" content="programming" />

        <link rel="shortcut icon" type="image/x-icon" href="../../../../Scratch/img/favicon.ico" />
        <link rel="stylesheet" type="text/css" href="../../../../Scratch/css/scientific.css" />
        <link rel="stylesheet" type="text/css" href="../../../../Scratch/js/highlight/styles/solarized_dark.css" />
        <link rel="stylesheet" type="text/css" href="../../../../Scratch/css/solarized.css" />
		<!-- Font -->
        <link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" />
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://feeds.feedburner.com/yannespositocomen" />
        <!--[if lt IE 9]>
        <script src="http://ie7-js.googlecode.com/svn/version/2.1(beta4)/IE9.js"></script>
        <![endif]-->

    </head>
    <body lang="en" class="article">
        <div id="content">
	        			<div id="header">
			    <div id="choix">
        	        <div id="choixlang">
                        <a href="../../../../Scratch/fr/blog/Absorb-Github-Events/">French</a> 
        	        </div>
					<div id="switchcss"><a href="#">Change Theme</a></div>
                    <div class="tomenu"><a href="#navigation">↓ Menu ↓</a></div>
        	        <div class="flush"></div>
        	    </div>
			</div>

			<div id="titre">
				<h1>Absorb Github Events</h1>
				
			</div>
			<div class="flush"></div>
			<div id="afterheader" class="article">
				<div class="corps">
					<div>
<img src="../../../../Scratch/img/blog/Absorb-Github-Events/main.png" alt="Main image" />
</div>
<div class="intro">
<p><span class="sc"><abbr title="Too long; didn't read">tl;dr</abbr>: </span> How to absorb octopussies events in real time.</p>
<p>This article should be the first of a series of articles. The goal of this series of articles is to show how to display a dashboard about a bunch of events in real time. For this you’ll need many different parts:</p>
<ul>
<li>You should first absorbs the events</li>
<li>then you might need to enrich them,</li>
<li>afterward, you’ll need to aggregate them,</li>
<li>you also need to give a way to question the aggregates via an <span class="sc"><abbr title="Application Program Interface">api</abbr></span>,</li>
<li>and finally you’ll need to provide a nice dashboard using the <span class="sc"><abbr title="Application Program Interface">api</abbr></span></li>
</ul>
<p>So let’s start by a way to get all github events in realtime.</p>
<p>For this series we’ll use the events provided by <a href="http://github.com">github</a>. The Eel (“Muraine” in French) is one of the few octopus predator.</p>
</div>
<h2 id="the-concepts">The concepts</h2>
<p>Actually all events are accessible via the <a href="https://api.github.com/events"><code>https://api.github.com/events</code></a> <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>. When logged you are generally allowed to call this <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span> about 5000 times per hour. A bit more than one time per second. During my tests I had less than 20 events per second.</p>
<p>github can change the max number of call per hour dynamically. So this information is provided in the header of the <span class="sc"><abbr title="HyperText Transfer Protocol">http</abbr></span> response.</p>
<p>Mainly the algorithm will be:</p>
<blockquote>
<p>Forever:</p>
<ol style="list-style-type: decimal">
<li>call <code>/events</code></li>
<li>analyze the three Headers: How many call can we use? At which time the number of calls reset? Compute how much time to wait before our next call.</li>
<li>Analyze the data and put them somewhere safe where they’ll could be processed next.</li>
</ol>
</blockquote>
<p>Apparently it seems easy (it won’t). Let’s try it.</p>
<p>One of the goal of this series being not only to handle events in real time but to be able to handle a tremendous number of events in real time. The actual amount of data provided by github is quite low. But in general you’ll want to optimize things to be able to absorb a full firehose of events.</p>
<p>For example, twitter can provide more than 20000 events per seconds. The twitter firehose forces you to use a single entry point. More than that, you have to deal with a single core to download the data and parse them. To be able to absorb such amount of data you generally don’t parse completely the data.</p>
<p>Another provider is facebook. Their approach is much nicer for the developer. You declare an <span class="sc"><abbr title="Secure HyperText Transfer Protocol">https</abbr></span> entry point and they send you the data by making <code>POST</code> calls. It is then much easier to dispatch the packet between multiple hosts using a load balancer such as <code>haproxy</code> for example.</p>
<p>Concerning github, I am not fond of their method to retrieve their data. It is kind of the worse of facebook and twitter. Worse than that, if the number of events per second is superior to some threshold you start losing events!</p>
<p>So, now the choice of the weapon we’ll use to handle that. It is 2015 and it is out of question to use low-level and/or error prone technology. But speed will still be an important factor.</p>
<p>If like me you don’t consider Java as a high-level programming language. And if you look at benchmarks, you’ll see that Python is slow. Then the choice belong mostly in functional programming languages:</p>
<ul>
<li>javascript</li>
<li>Clojure</li>
<li>Haskell</li>
<li>Common Lisp</li>
<li>OCaml</li>
</ul>
<p>While javascript is by far the most popular choice, it is also the worst of the list in term of language quality.</p>
<p>As the choice is mine, I’ll then choose Haskell. Haskell provide a really great control, a lot of error will be discarded naturally by the language properties. Concurrent and parallel programming will be <em>very</em> easy to achieve.</p>
<p>Don’t forget one of the goal is also to provide an example tool. But in the real world, you also want to be able to handle thousands of events per second.</p>
<p>The next article will certainly use clojure.</p>
<h2 id="initialize-your-environment.">Initialize your environment.</h2>
<p>If you are on Mac or on Ubuntu you should install Haskell with this script:</p>
<pre><code>curl -O https://raw.githubusercontent.com/yogsototh/install-haskell/master/install-haskell.sh
chmod ugo+x install-haskell.sh
sudo ./install-haskell $USER</code></pre>
<p>Then create a simple new project:</p>
<pre><code>cabal new muraine</code></pre>
<p>Or if you don’t want to type things, just clone my repository. There will be a branch for each step.</p>
<pre><code>TODO: git clone ...
TODO: git checkout step1
...</code></pre>
<h2 id="first-step-http-requests">First step: <span class="sc"><abbr title="HyperText Transfer Protocol">http</abbr></span> requests</h2>
<p>The first thing to do is to add all the needed dependencies. In a first time, we’ll only need to make <span class="sc"><abbr title="HyperText Transfer Protocol">http</abbr></span> requests and work with the responses.</p>
<p>Update your <code>muraine.cabal</code> file as follow:</p>
<pre><code>  ...
  build-depends:       base &gt;=4.7 &amp;&amp; &lt;4.8<span class="highlight">,</span>
                       <span class="highlight">http-conduit,</span>
                       <span class="highlight">bytestring</span>
  ...</code></pre>
<p>Then edit the <code>Main.hs</code> file such that it contains this:</p>
<blockquote>
<p>☞ Haskell can be quite a strange programming language. It is <em>very</em> explicit about a <em>lot</em> of things. So yes. One of the cost to pay to have better confidence in the correctness of your program is to be slightly more verbose than some other very terse language (Haskell is quite very good at terseness thought) and be used to some strange magic notations and sometimes strange <span class="sc"><abbr title="Application Program Interface">api</abbr></span>.</p>
<p>If you are not familiar with Haskell. Try not be focused on details and just try to read the flow. Once you have to do things yourself, the Haskell compiler will be here to help you in your journey.</p>
<p>The worst case scenario with Haskell is discovering a new library lacking some documentation and playing the <em>type tetris</em> game.</p>
</blockquote>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Network.HTTP.Conduit</span> (simpleHttp)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    response <span class="ot">&lt;-</span> simpleHttp <span class="st">&quot;http://www.google.com&quot;</span>
    L.putStrLn response</code></pre>
<p>And now to run this code simply launch this command:</p>
<pre><code>cabal run</code></pre>
<p>Now you should receive some <span class="sc"><abbr title="HyperText Markup Language">html</abbr></span>.</p>
<p>Let’s explain each part very slowly:</p>
<p>The first line declare the current file as a module named <code>Main</code>. Then we import some functions from other modules. From the module <code>Network.HTTP.Conduit</code> we import the function <code>simpleHttp</code>. We import the module <code>Data.ByteString.Lazy.Char8</code> but as its name is too long we’ll reference it as <code>L</code>. And now we’ll could use <code>L.funcname</code>.</p>
<p>then the line:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()</code></pre>
<p>Is a type declaration for the <code>main</code> variable name. Here <code>main</code> is of type <code>IO ()</code> which means, that we’ll do some impure stuff and will return nothing (the <code>()</code> part).</p>
<p>Finally we define the main function:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> <span class="kw">do</span>
    response <span class="ot">&lt;-</span> simpleHttp <span class="st">&quot;http://www.google.com&quot;</span>
    L.putStrLn response</code></pre>
<p>The <code>do</code> is a syntactical sugar in Haskell. It means that for each of the following “line” at the end an action will be performed. It is a bit like modifying the end of line behaviour. It is the way of Haskell to make explicit the part where we will use effects and where we will be completely pure<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>In the first line we call the function <code>simpleHttp</code> with the url of google as argument. The function return an <code>IO Response</code>. So instead of writing <code>response = simpleHttp ...</code> we use the <code>&lt;-</code> which will take only the <code>Response</code> of the <code>IO Response</code>. and now <code>response</code> is a variable of type <code>Response</code>.</p>
<p>In the next line we simply print the <code>response</code>.</p>
<p>It is now time to receive some github events. Simply udpate the <span class="sc"><abbr title="Uniform Ressource Locator">url</abbr></span>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Network.HTTP.Conduit</span> (simpleHttp)
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    response <span class="ot">&lt;-</span> simpleHttp <span class="st">&quot;https://api.github.com/events&quot;</span>
    L.putStrLn response</code></pre>
<p>Unfortunately you should receive an error (line wrapping added for readability):</p>
<pre><code>StatusCodeException (Status {statusCode = 403, statusMessage
 = &quot;Forbidden&quot;}) [(&quot;Cache-Control&quot;,&quot;no-cache&quot;),(&quot;Connection&quot;
,&quot;close&quot;),(&quot;Content-Type&quot;,&quot;text/html&quot;),(&quot;X-Response-Body-Sta
rt&quot;,&quot;Request forbidden by administrative rules. Please make 
sure your request has a User-Agent header (http://developer.
github.com/v3/#user-agent-required). Check https://developer
.github.com for other possible causes.&quot;),(&quot;X-Request-URL&quot;,&quot;G
ET https://api.github.com:443/events&quot;)] (CJ {expose = []})</code></pre>
<p>It is a bit hard to read, but in the mess you can read:</p>
<pre><code>Request forbidden by administrative rules.
Please make sure your request has a User-Agent header
(http://developer.github.com/v3/#user-agent-required).
Check https://developer.github.com for other possible causes.</code></pre>
<p>Damn, github want us to add a <code>User-Agent</code> header. But the library we use doesn’t add one by default. We should add it manually. Don’t be afraid by the syntax. It might be ugly, but it does a great job at keeping concerns separated.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import           </span><span class="dt">Network.HTTP.Conduit</span>
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">LZ</span>

<span class="ot">simpleHTTPWithUserAgent ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">LZ.ByteString</span>)
simpleHTTPWithUserAgent url <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> parseUrl url
    <span class="kw">let</span> request <span class="fu">=</span> r {requestHeaders <span class="fu">=</span> [(<span class="st">&quot;User-Agent&quot;</span>,<span class="st">&quot;HTTP-Conduit&quot;</span>)]}
    withManager (httpLbs request)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    response <span class="ot">&lt;-</span> simpleHTTPWithUserAgent <span class="st">&quot;https://api.github.com/events&quot;</span>
    LZ.putStrLn (responseBody response)</code></pre>
<p>Now, that is better. But, to start really working with the github <span class="sc"><abbr title="Application Program Interface">api</abbr></span>, we need to manage the headers.</p>
<p>Here is how we display them:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">B</span> <span class="co">-- strict bytestrings</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span> ((&lt;&gt;)) <span class="co">-- for concatenating bytestrings</span>

<span class="fu">...</span>

<span class="highlight"><span class="ot">showHeader ::</span> <span class="dt">Header</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span class="highlight">showHeader (name, value) <span class="fu">=</span></span>
  <span class="highlight">B.putStrLn (original name <span class="fu">&lt;&gt;</span> <span class="st">&quot;: &quot;</span> <span class="fu">&lt;&gt;</span> value)</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    response <span class="ot">&lt;-</span> simpleHTTPWithUserAgent <span class="st">&quot;https://api.github.com/events&quot;</span>
    LZ.putStrLn (responseBody response)
    <span class="highlight">mapM_ showHeader (responseHeaders response)</span></code></pre>
<p>The <code>responseHeaders response</code> will return a list of <code>Header</code> and a <code>Header</code> is a couple <code>(header_name,value)</code>.</p>
<p>So <code>mapM_</code> will execute a function over a list, here the list of <code>Headers</code>. For each header we execute <code>showHeader</code>.</p>
<p><code>showHeader</code> take a <code>Header</code> and print it on screen.</p>
<p>There should be three headers beginning by <code>X-RateLimit</code>. The number of authorized access should be quite low:</p>
<pre><code>X-RateLimit-Limit: 60
X-RateLimit-Remaining: 57
X-RateLimit-Reset: 1427738616</code></pre>
<p>So you have the right to connect to the github <span class="sc"><abbr title="Application Program Interface">api</abbr></span> only 60 times by hour. It will be far from real time high volume events. Fortunately, the limit can be greatly improved by being connected. So you can provide a username and password.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">...</span>
<span class="highlight"><span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)</span>
<span class="highlight"><span class="kw">import </span><span class="dt">System.Exit</span> (exitFailure)</span>
<span class="fu">...</span>


<span class="ot">simpleHTTPWithUserAgent ::</span> <span class="dt">String</span> <span class="highlight"><span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
                           <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">LZ.ByteString</span>)
simpleHTTPWithUserAgent url <span class="highlight">user pass</span> <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> parseUrl url
    <span class="kw">let</span> request <span class="fu">=</span> r {requestHeaders <span class="fu">=</span> [(<span class="st">&quot;User-Agent&quot;</span>,<span class="st">&quot;HTTP-Conduit&quot;</span>)]}
        <span class="highlight">requestWithAuth <span class="fu">=</span> applyBasicAuth (B.pack user)</span>
                                         <span class="highlight">(B.pack pass)</span>
                                         <span class="highlight">request</span>
    withManager (httpLbs <span class="highlight">requestWithAuth</span>)


<span class="ot">showHelpAndExit ::</span> <span class="dt">IO</span> ()
showHelpAndExit <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;provide your github username and password please&quot;</span>
    exitFailure

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    <span class="kw">case</span> args <span class="kw">of</span>
         [user,pass] <span class="ot">-&gt;</span> continueWithUserAndPass user pass
         _ <span class="ot">-&gt;</span> showHelpAndExit

<span class="ot">continueWithUserAndPass ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
continueWithUserAndPass user pass <span class="fu">=</span> <span class="kw">do</span>
    response <span class="ot">&lt;-</span> simpleHTTPWithUserAgent <span class="st">&quot;https://api.github.com/events&quot;</span> user pass
    LZ.putStrLn (responseBody response)
    mapM_ showHeader (responseHeaders response)</code></pre>
<p>Now if you run:</p>
<pre><code>cabal run [nickname] [password]</code></pre>
<p>Your <code>X-RateLimit-Limit</code> should have raised to <code>5000</code>! Note it is not over <code>9000</code> thought.</p>
<h2 id="waiting-the-right-amount-of-time">Waiting the right amount of time</h2>
<p>To optimize the number of call we can make to the githup <span class="sc"><abbr title="Application Program Interface">api</abbr></span>, we’ll have to manage <span class="sc"><abbr title="HyperText Transfer Protocol">http</abbr></span> headers. What are the useful headers:</p>
<pre><code>X-RateLimit-Remaining: 4999
X-RateLimit-Reset: 1428149482
Date: Sat, 04 Apr 2015 11:14:38 GMT
ETag: 05502a61685deb37109b648ea2107135</code></pre>
<p>So, to optimize the number of call we can make we should use the following number:</p>
<pre><code>time to wait before next call in seconds:
    t = (X-RateLimit-Reset - Date in epoch) / X-RateLimit-Remaining
    max (t - time taken by last request, 0)</code></pre>
<p>If we could make request instantaneously we should wait only for <code>t</code>. But as our request has taken time, it means we already waited this time. So if the request was longer than the time to wait, we should make the request as soon as possible.</p>
<p>So most of informations we need are provided by the <span class="sc"><abbr title="HyperText Transfer Protocol">http</abbr></span> headers. We also need to measure how much time our request took.</p>
<h3 id="date-time-hell">Date &amp; Time Hell</h3>
<p>To make things harder to use github maliciously used different format for the header <code>Date</code> and <code>X-RateLimit-Reset</code>.</p>
<p>This shouldn’t be a big problem to resolve. We should use the <a href="https://hackage.haskell.org/package/time">time</a> package. And here we enter in the great world of date type translations. From string or int to Time, etc…</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="fu">...</span>
    <span class="kw">import </span><span class="dt">Data.Time.Format</span> (readTime)
    <span class="kw">import </span><span class="dt">Data.Time.Clock.POSIX</span> (getPOSIXTime,utcTimeToPOSIXSeconds)
    <span class="fu">...</span>
<span class="ot">    rfc822DateFormat ::</span> <span class="dt">String</span>
    rfc822DateFormat <span class="fu">=</span> <span class="st">&quot;%a, %_d %b %Y %H:%M:%S %Z&quot;</span>
    
<span class="ot">    epochFromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
    epochFromString <span class="fu">=</span> floor <span class="fu">.</span> utcTimeToPOSIXSeconds <span class="fu">.</span> readTime defaultTimeLocale rfc822DateFormat</code></pre>
<p>Now we can pass from a String representation to an epoch one. We also need to measure how much time our requests took.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">System.CPUTime</span> (getCPUTime)
<span class="fu">...</span>
<span class="ot">time ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Double</span>, a)
time action <span class="fu">=</span> <span class="kw">do</span>
    startTime <span class="ot">&lt;-</span> getCPUTime
    res <span class="ot">&lt;-</span> action
    endTime <span class="ot">&lt;-</span> getCPUTime
    return (fromIntegral (endTime <span class="fu">-</span> startTime)<span class="fu">/</span><span class="dv">1000000000</span>,res)
<span class="fu">...</span>
getEvents user pass <span class="fu">=</span> <span class="kw">do</span>
    (req_time, response) <span class="ot">&lt;-</span> time (simpleHTTPWithUserAgent <span class="st">&quot;https://api.github.com/events&quot;</span> user pass)
    <span class="fu">...</span></code></pre>
<p>Another important aspect is to pass the ETag each of each preceding request. For this it is time to refactor our code a bit to make it more readable.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">authHttpCall ::</span> <span class="dt">String</span> <span class="co">-- ^ URL</span>
                <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="co">-- ^ User</span>
                <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="co">-- ^ Password</span>
                <span class="ot">-&gt;</span> <span class="dt">RequestHeaders</span> <span class="co">-- ^ Headers</span>
                <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">LZ.ByteString</span>)
authHttpCall url user pass headers <span class="fu">=</span> <span class="kw">do</span>
    r <span class="ot">&lt;-</span> parseUrl url
    <span class="kw">let</span> request <span class="fu">=</span> r {requestHeaders <span class="fu">=</span> headers }
        requestWithAuth <span class="fu">=</span> applyBasicAuth (B.pack user) (B.pack pass) request
    withManager (httpLbs requestWithAuth)

<span class="ot">httpGHEvents ::</span> <span class="dt">String</span> <span class="co">-- ^ User</span>
                <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="co">-- ^ Password</span>
                <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">B.ByteString</span> <span class="co">-- ^ ETag if one</span>
                <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Response</span> <span class="dt">LZ.ByteString</span>)
httpGHEvents user pass etag <span class="fu">=</span>
    authHttpCall  <span class="st">&quot;https://api.github.com/events&quot;</span> user pass headers
    <span class="kw">where</span>
        headers <span class="fu">=</span> (<span class="st">&quot;User-Agent&quot;</span>,<span class="st">&quot;HTTP-Conduit&quot;</span>)<span class="fu">:</span>
            maybe [] (\e <span class="ot">-&gt;</span> [(<span class="st">&quot;If-None-Match&quot;</span>,B.tail (B.tail e))]) etag</code></pre>
<p>And then</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getEvents ::</span> <span class="dt">String</span>             <span class="co">-- ^ Github username</span>
          <span class="ot">-&gt;</span> <span class="dt">String</span>             <span class="co">-- ^ Github password</span>
          <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">B.ByteString</span> <span class="co">-- ^ ETag</span>
          <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
getEvents user pass etag <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- Call /events on github</span>
    (req_time, response) <span class="ot">&lt;-</span> time (httpGHEvents user pass etag)
    <span class="kw">if</span> statusIsSuccessful (responseStatus response)
        <span class="kw">then</span> <span class="kw">do</span>
            <span class="kw">let</span> headers <span class="fu">=</span> responseHeaders response
            <span class="co">-- If the server returned a date we use it</span>
            <span class="co">-- otherwise we use the local current time</span>
            serverDateEpoch <span class="ot">&lt;-</span> <span class="kw">case</span> lookup <span class="st">&quot;Date&quot;</span> headers <span class="kw">of</span>
                                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> fmap round getPOSIXTime
                                <span class="dt">Just</span> d <span class="ot">-&gt;</span> return (epochFromString (B.unpack d))
            <span class="kw">let</span> etagResponded <span class="fu">=</span> lookup <span class="st">&quot;ETag&quot;</span> headers
                remainingHeader <span class="fu">=</span> lookup <span class="st">&quot;X-RateLimit-Remaining&quot;</span> headers
                remaining <span class="fu">=</span> maybe <span class="dv">1</span> (read <span class="fu">.</span> B.unpack) remainingHeader
                resetHeader <span class="fu">=</span> lookup <span class="st">&quot;X-RateLimit-Reset&quot;</span> headers
                reset <span class="fu">=</span> maybe <span class="dv">1</span> (read <span class="fu">.</span> B.unpack) resetHeader
                timeBeforeReset <span class="fu">=</span> reset <span class="fu">-</span> serverDateEpoch
                t <span class="fu">=</span> <span class="dv">1000000</span> <span class="fu">*</span> timeBeforeReset <span class="ot">`div`</span> remaining
                timeToWaitIn_us <span class="fu">=</span> max <span class="dv">0</span> (t <span class="fu">-</span> floor (<span class="dv">1000000</span> <span class="fu">*</span> req_time))
            publish (responseBody response)
            threadDelay timeToWaitIn_us
            getEvents user pass etagResponded
        <span class="kw">else</span> <span class="kw">do</span>
            putStrLn <span class="st">&quot;Something went wrong&quot;</span>
            threadDelay <span class="dv">100000</span> <span class="co">-- 100ms</span>
            getEvents user pass etag</code></pre>
<h3 id="pagination">Pagination</h3>
<p>From the github specification we should follow the <span class="sc"><abbr title="HyperText Transfer Protocol">http</abbr></span> header <code>Link</code>. But in reality concerning all events, we should only rely on the <code>page</code> param.</p>
<p>So for now I won’t parse the header.</p>
<p>Notice, parsing in Haskell is really great, so I may add a section in the end.</p>
<h2 id="refactoring-one-step-back">Refactoring (one step back)</h2>
<p>Now our code start to have function with more than 30 lines. Which is really a <em>lot</em> in Haskell.</p>
<p>Furthermore the way github provide its events is really awful when you want to get them all. Compare this to the twitter and Facebook method.</p>
<p>Each time we will read one page, we should take care not to add an already present event.</p>
<p>So we should remember the first and last id of the preceding page. More than that we should also remember the very first id of the page 1.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Data</span> <span class="dt">CallInfo</span> <span class="fu">=</span> <span class="dt">CallInfo</span> {<span class="ot"> firstIdPageOne ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
                         ,<span class="ot"> searchFirstId ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
                         ,<span class="ot"> precedingPageFirstId ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
                         ,<span class="ot"> precedingPageLastId ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
                         ,<span class="ot"> currentPage ::</span> <span class="dt">Int</span>
                         }</code></pre>
<p>So the algorithm to read become error prone very fast. I am not confident enough to use the date on the events as I am not sure the are aggregated in the same time.</p>
<p>So we are contrived to believe there is less than 30 events between two call.</p>
<p>Hypothesis: between two call less than one page of events (30) occurs</p>
<p>Even with such an hypothesis the code is complex and bug prone.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CallInfo</span> <span class="fu">=</span> <span class="dt">CallInfo</span> { _<span class="ot">user            ::</span> <span class="dt">String</span>             <span class="co">-- ^ Github username</span>
                         , _<span class="ot">pass            ::</span> <span class="dt">String</span>             <span class="co">-- ^ Github password</span>
                         , _<span class="ot">etag            ::</span> <span class="dt">Maybe</span> <span class="dt">B.ByteString</span> <span class="co">-- ^ ETag</span>
                         , _<span class="ot">timeToWait      ::</span> <span class="dt">Int</span>                <span class="co">-- ^ Time to wait in micro seconds</span>
                         , _<span class="ot">firstId         ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>         <span class="co">-- ^ First Event Id</span>
                         , _<span class="ot">lastId          ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>         <span class="co">-- ^ Last  Event Id</span>
                         , _<span class="ot">searchedFirstId ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>         <span class="co">-- ^ First Event Id searched</span>
                         , _<span class="ot">page            ::</span> <span class="dt">Int</span>                <span class="co">-- ^ Page</span>
                         } <span class="kw">deriving</span> (<span class="dt">Show</span>)

<span class="co">-- | given an HTTP response compute the next CallInfo and also publish events</span>
<span class="co">-- Beware, this is an heuristic with the hypothesis that there is no more than</span>
<span class="co">-- one page to download, by one page.</span>
<span class="ot">getCallInfoFromResponse ::</span> <span class="dt">CallInfo</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="dt">LZ.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">CallInfo</span>
getCallInfoFromResponse callInfo response req_time <span class="fu">=</span> <span class="kw">do</span>
    print callInfo
    <span class="kw">if</span> statusIsSuccessful (responseStatus response)
        <span class="kw">then</span> <span class="kw">do</span>
            <span class="kw">let</span> headers <span class="fu">=</span> responseHeaders response
            t <span class="ot">&lt;-</span> getTimeToWaitFromHeaders headers
            <span class="kw">let</span>
              <span class="co">-- Time to wait is time between two HTTP call minus the time</span>
              <span class="co">-- the last HTTP call took to answer</span>
              timeToWaitIn_us <span class="fu">=</span> max <span class="dv">0</span> (t <span class="fu">-</span> floor (<span class="dv">1000000</span> <span class="fu">*</span> req_time))
              events <span class="fu">=</span> decode (responseBody response)
              nextFirstId <span class="fu">=</span> <span class="kw">if</span> _page callInfo <span class="fu">==</span> <span class="dv">1</span> <span class="fu">||</span> isNothing (_firstId callInfo)
                              <span class="kw">then</span> getFirstId events
                              <span class="kw">else</span> _firstId callInfo
              nextLastId <span class="fu">=</span> getLastId events
              containsSearchedFirstId <span class="fu">=</span> containsId (_searchedFirstId callInfo) events
              etagResponded <span class="fu">=</span> lookup <span class="st">&quot;ETag&quot;</span> headers
              <span class="co">-- Read next pages until we reach the old first ID of the first page</span>
              <span class="co">-- of the preceeding loop</span>
              <span class="co">-- return a new page if the first ID wasn't found</span>
              nextPage <span class="fu">=</span> <span class="kw">if</span> containsSearchedFirstId <span class="fu">||</span> (_page callInfo <span class="fu">&gt;=</span> <span class="dv">10</span>)
                          <span class="kw">then</span> <span class="dv">1</span>
                          <span class="kw">else</span> _page callInfo <span class="fu">+</span> <span class="dv">1</span>
              nextSearchedFirstId <span class="fu">=</span> <span class="kw">if</span> containsSearchedFirstId <span class="fu">||</span> (_page callInfo <span class="fu">&gt;=</span> <span class="dv">10</span>)
                                      <span class="kw">then</span> nextFirstId
                                      <span class="kw">else</span> _searchedFirstId callInfo
            publish events (_searchedFirstId callInfo) (_lastId callInfo)
            return (callInfo { _firstId <span class="fu">=</span> nextFirstId
                             , _lastId <span class="fu">=</span> nextLastId
                             , _page <span class="fu">=</span> nextPage
                             , _etag <span class="fu">=</span> etagResponded
                             , _timeToWait <span class="fu">=</span> timeToWaitIn_us
                             , _searchedFirstId <span class="fu">=</span> nextSearchedFirstId
                             })
        <span class="kw">else</span>
            putStrLn (<span class="kw">if</span> notModified304 <span class="fu">==</span> responseStatus response
                        <span class="kw">then</span> <span class="st">&quot;Nothing changed&quot;</span>
                        <span class="kw">else</span> <span class="st">&quot;Something went wrong&quot;</span>)
            return callInfo</code></pre>
<h2 id="rant">Rant</h2>
<p>So this code is working most of the time. And if we get more than 30 events between two call, the only issue is that we lose some events. From experience, having more than 30 events between two call is quite a rare event.</p>
<p>But seriously. The github API is a pain to get all events.</p>
<blockquote>
<p>It is nearly impossible using only github event <em>ids</em> to get all events for sure.</p>
</blockquote>
<p>Even if they don’t want to provide a streaming or a push API, they could make a system using the ETAG or another system to be sure we don’t miss any events nor we don’t publish an event twice in the system.</p>
<p>This system is completely impossible to scale. Seriously, how could you do something serious with it? What if the number of event double for example?</p>
<p>So please, github. Could you provide a better way to handle your <em>firehose</em>?</p>
<p>Another problem.</p>
<p>When twitter send a retweet, we get all necessary information to display and analyze this retweet. It contains not only the information for the retweet but also the complete original tweet.</p>
<p>Here, we can’t get very useful information for example. If we want to analyze the languages on github in real time. Our only witness is contained in the extensions in the files commited. But for our great despair, github events don’t contain them.</p>
<p>To get them you have to make another call to the API on the commit id itself. Which is a shame, as we only have 5000 event per hour at our disposal. And if we make less than 1 call by second we enter in the case where more than 30 events will occurs between two calls.</p>
<h2 id="exporting-data-to-something-useful">Exporting data to something useful</h2>
<p>Part of the problem is to think as if everything was stream.</p>
<p>Functional programming fits this spirit. So for all the system to work, everything should fit the “streaming” convention.</p>
<p>In particular, we should create a stream of events that will be used later.</p>
<p>So there are a lot of pub/sub system. At work I use kafka. It is great, but for this article I’ll use <a href="http://nats.io">NATS</a>. The first reason is that I am curious. Another reason is to make my code more portable. The Haskell’s kafka libraries are binded to a <code>C</code> one. On the other hand, the <code>nats-queue</code> package doesn’t have such an external dependency. Furthermore, NATS code wasn’t modified for about one year. Which can mean two things.</p>
<ol style="list-style-type: decimal">
<li>Nobody care about it anymore,</li>
<li>The code is really stable.</li>
</ol>
<p>In the hope for the second option, I’m eager to give it a try.</p>
<p>So a queue system is quite simple. Many producers write in a queue. Many consumer read the queue. Each message should be consumed only once between all consumer.</p>
<p>Don’t worry, if you love Kafka, a future article will talk about it.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The reality is quite more complicated than that. But hey, try to explain IO monad in less than 100 words…<a href="#fnref1">↩</a></p></li>
</ol>
</div>
				</div>
                <div id="afterarticle">
                    <div id="social">
                        <a target="_blank" href="http://feeds.feedburner.com/yannespositocomen" class="social">r</a>
                        ·
                         <a target="_blank" href="https://twitter.com/home?status=http://yannesposito.com/Scratch/en/blog/Absorb-Github-Events/%20via%20@yogsototh" class="social">t</a>
                        ·
                        <a target="_blank" href="http://www.facebook.com/sharer/sharer.php?u=/Scratch/en/blog/Absorb-Github-Events/" class="social">`</a>
                        ·
                         <a target="_blank" href="https://plus.google.com/share?url=http://yannesposito.com/Scratch/en/blog/Absorb-Github-Events/" class="social">g</a>
                        <br />
                        <a class="message" href="../../../../Scratch/en/blog/Social-link-the-right-way/">These social sharing links preserve your privacy</a>
                    </div>
        	        <div id="navigation">
                        <a href="../../../../">Home</a>
                        <span class="sep">¦</span>
        	            <a href="../../../../Scratch/en/blog">Blog</a>
                        <span class="sep">¦</span>
                        <a href="../../../../Scratch/en/softwares">Softwares</a>
                        <span class="sep">¦</span>
                        <a href="../../../../Scratch/en/about">About</a>
        	        </div>
                    <div id="totop"><a href="#header">↑ Top ↑</a></div>
				    <div class="corps" id="comment">
            	        <h2 class="first">Comments</h2>
				    	<div id="disqus_thread"></div>
        		    	<script type="text/javascript">
        		    	    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        		    	    var disqus_shortname = 'yannesposito'; // required: replace example with your forum shortname
                            var disqus_identifier = '/Scratch/en/blog/Absorb-Github-Events/index.html';

        		    	    /* * * DON'T EDIT BELOW THIS LINE * * */
        		    	    (function() {
        		    	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        		    	        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        		    	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        		    	    })();
        		    	</script>
        		    	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        		    	<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
				    </div>
                    <div class="tomenu"><a>↑ Menu ↑</a></div>
				    <div id="bottom">
            	        <div>
            	            Published on 2015-03-27
            	        </div>
            	        <div>
            	            <a href="https://twitter.com/yogsototh">Follow @yogsototh</a>
            	        </div>
            	        <div>
                            <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Yann Esposito©</a>
            	        </div>
            	        <div>
            	            Done with
            	            <a href="http://www.vim.org" target="_blank">Vim</a>
				    		<span class="pala">&amp;</span>
                            <a href="http://nanoc.ws" target="_blank"><span class="strike">nanoc</span></a>
				    		<a href="http://jaspervdj.be/hakyll" target="_blank">Hakyll</a>
            	        </div>
            	    </div>
                </div>
			</div>

        </div>
        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.0/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="/Scratch/js/vendor/jquery-1.10.0.min.js"><\/script>')</script>
        <script src="../../../../Scratch/js/jquery.scrolldepth.min.js"></script>
        <script src="../../../../Scratch/js/jquery.cookie.js"></script>
        <script src="../../../../Scratch/js/index.js"></script>
        <script src="../../../../Scratch/js/highlight/highlight.pack.js"></script>
        <script src="../../../../Scratch/js/article.js"></script>
        <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </body>
</html>
