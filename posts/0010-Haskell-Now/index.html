<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Learn Haskell Now!</title><meta name=author content="Yann Esposito"><meta name=description content="A short and intense introduction
to Haskell. This is an update of my old (2012) article. A lot of things
have changed since then. Mostly I changed my approach about the easiest
way to install a Haskell playground. I removed the not as important
part, and added a short introduction about starting a new project."><meta name=keywords content="Haskell programming functional
tutorial"><link rel=stylesheet href=/css/y.css><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=icon href=/favicon.ico><meta name=theme-color media="(prefers-color-scheme: light)" content="#d84100"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#2E3440"><header><div id=logo><a href=/><div class=vis-hidden>Go to Home</div><svg width="5em" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" stroke="#00" stroke-width="1" fill="#2e3440"/><circle class="i1" cx="32" cy="32" r="12" stroke="#800" stroke-width="1" fill="#c20"/><circle class="i0" cx="32" cy="32" r="5" stroke-width="1" stroke="#f60" fill="#fa0"/><ellipse class="e" cx="32" cy="14" rx="14" ry="8" stroke-width="0" fill="#fff"/></svg></a></div><div class=content><h1>Learn Haskell Now!</h1><div class=meta><span class=yyydate>[2019-12-15 Sun]</span> on
<a href=https://her.esy.fun><span class=author>Yann Esposito</span>'s blog</a></div><div class=abstract>A short and intense introduction to Haskell. This is an update of my old
(2012) article. A lot of things have changed since then. Mostly I
changed my approach about the easiest way to install a Haskell
playground. I removed the not as important part, and added a short
introduction about starting a new project.</div></div></header><main id=content><nav id=toc role=doc-toc><ul><li><a href=#introduction id=toc-introduction>Introduction</a><ul><li><a href=#install id=toc-install>Install</a><li><a href="#don't-be-afraid" id="toc-don't-be-afraid">Don't be
afraid</a><li><a href=#very-basic-haskell id=toc-very-basic-haskell>Very basic
Haskell</a><ul><li><a href=#function-declaration id=toc-function-declaration>Function declaration</a><li><a href=#a-type-example id=toc-a-type-example>A Type
Example</a></ul></ul><li><a href=#essential-haskell id=toc-essential-haskell>Essential
Haskell</a><ul><li><a href=#notations id=toc-notations>Notations</a><li><a href=#useful-notations-for-functions id=toc-useful-notations-for-functions>Useful notations for
functions</a></ul><li><a href=#first-dive id=toc-first-dive>First dive</a><ul><li><a href=#functional-style id=toc-functional-style>Functional
style</a><ul><li><a href=#higher-order-functions id=toc-higher-order-functions>Higher Order Functions</a></ul><li><a href=#types id=toc-types>Types</a><ul><li><a href=#type-inference id=toc-type-inference>Type
inference</a><li><a href=#type-construction id=toc-type-construction>Type
construction</a><li><a href=#recursive-type id=toc-recursive-type>Recursive
type</a><li><a href=#trees id=toc-trees>Trees</a><li><a href=#more-advanced-types id=toc-more-advanced-types>More
Advanced Types</a></ul><li><a href=#infinite-structures id=toc-infinite-structures>Infinite
Structures</a><ul><li><a href=#infinite-trees id=toc-infinite-trees>Infinite
Trees</a><li><a href=#fibonnacci-infinite-list id=toc-fibonnacci-infinite-list>Fibonnacci infinite list</a></ul></ul><li><a href=#dive-into-the-impure id=toc-dive-into-the-impure>Dive
into the impure</a><ul><li><a href=#deal-with-io id=toc-deal-with-io>Deal With IO</a><li><a href=#io-trick-explained id=toc-io-trick-explained>IO trick
explained</a><li><a href=#monads id=toc-monads>Monads</a><ul><li><a href=#monad-intuition id=toc-monad-intuition>Monad
Intuition</a><li><a href=#maybe-is-a-monad id=toc-maybe-is-a-monad>Maybe is a
monad</a><li><a href=#the-list-monad id=toc-the-list-monad>The list
monad</a></ul></ul><li><a href=#start-swimming id=toc-start-swimming>Start swimming</a><ul><li><a href=#start-a-new-project id=toc-start-a-new-project>Start a
new project</a><ul><li><a href=#bootstrap-a-project-template-files id=toc-bootstrap-a-project-template-files>Bootstrap a project template
files</a><li><a href=#create-a-few-nix-files id=toc-create-a-few-nix-files>Create a few nix files</a><li><a href=#checking-your-environment id=toc-checking-your-environment>Checking your environment</a><li><a href=#add-a-library id=toc-add-a-library>Add a
library</a><li><a href=#better-defaults id=toc-better-defaults>Better
defaults</a></ul></ul><li><a href=#conclusion id=toc-conclusion>Conclusion</a><li><a href=#thanks id=toc-thanks>Thanks</a></ul></nav><article><blockquote><p><strong>Prelude</strong><p>In 2012, I really believed that every developer should learn Haskell.
This is why I wrote my old article. This is the end of 2019 and I still
strongly believe that. I think you should at least be able to understand
enough Haskell to write a simple tool. There are some features in
Haskell that I really miss in most programming languages and that would
not appear to be difficult to provide. Typically sum types. A concept so
simple yet so helpful.<p>Since I wrote my article the Haskell ecosystem has evolved:<ol><li>Project building has different existing solutions. When I wrote this
article I made some web applications that I can no longer build today. I
mean, if I really want to invest some time, I'm sure I could upgrade
those projects to build again. But this is not worth the hassle. Now we
have <code class=verbatim>stack</code>, <code class=verbatim>nix</code>, <code class=verbatim>cabal new-build</code> and I'm sure other
solutions.<li>GHC is able to do a lot more magic. This is beyond the scope of an
introduction material in my opinion. While the learning curve is as
steep as before, the highest point of learning just climbed higher and
higher with each successive new GHC release.<li>Still no real consencus about how to work, learn, and use Haskell.
In my opinion there are three different perspectives on Haskell that
could definitively change how you make decisions about different aspect
of Haskell programming. I believe the main groups of ideolgies are
application developers, library developers and the main compiler (GHC)
developers. I find those tensions a proof of a healthy environment.
There are different solutions to the same problems and that is perfectly
fine. This is different when you compare to other language ecosystems
where decisions are more controlled or enforced. I feel fine with both
approaches. But you must understand that there is no central mindset
within Haskellers unlike I can find in some other programming language
communities.<li>I think that Haskell is now perceived as a lot more serious
programming language now. A lot more big projects uses Haskell. Haskell
proved its utility to write succesful complex entreprise projects.</ol><p>While the ecosystem evolved I believe that I myself have certainly
matured. Since 2013 I'm paid to develop in Clojure. I write most of my
personal side projects in Haskell or in some Haskell-inspired
language.<p>As such I can follow two functional programming communities growth
and evolution. I am kind of confident that my Haskell understanding is a
lot better than before. But I still think, the ability to learn new
Haskell subject is infinite.<p>Someday I would like to write a post about my current team philosophy
about programming. Our main rule is to use as few features of a
programming language as possible to achieve our goal. This is a kind of
merge between minimalism and pragmatism that in the end provide a
tremendous amount of benefits. This is why, even if I like to play with
the latest Haskell trendy features, I generally program without those.
With just a very few amount of Haskell features you will already be in
enviromnent with a <strong>lot</strong> of benefits as compared to many
programming languages.<p>So enough talk, here is my updated article. I added a section about
how to create a new project template with nix.<p>I will try to write other articles about how to write a real program
in Haskell. I tried to add those to this already long article, but, it
occurs to be more work than expected. So I preferred stop at this point
for now and provide separate articles in the future related to Haskell
application development.</blockquote><h1 id=introduction>Introduction</h1><p>I really believe that every developer should learn Haskell. I don't
think every dev needs to be a super Haskell ninja, but they should at
least discover what Haskell has to offer. Learning Haskell opens your
mind.<p>Mainstream languages share the same foundations:<ul><li>variables<li>loops<li>pointers<a href=#fn1 class=footnote-ref id=fnref1 role=doc-noteref><sup>1</sup></a><li>data structures, objects and classes (for most)</ul><p>Haskell is very different. The language uses a lot of concepts I had
never heard about before. Many of those concepts will help you become a
better programmer.<p>But learning Haskell can be (and will certainly be) hard. It was for
me. In this article I try to provide as much help as possible to
accelerate your learning.<p>This article will certainly be hard to follow. This is on purpose.
There is no shortcut to learning Haskell. It is hard and challenging.
But I believe this is a good thing. It is because it is hard that
Haskell is interesting and rewarding.<p>Today, I could not really provide a conventional path to learn
Haskell. So I think the best I can do is point you to the <a href=https://www.haskell.html/documentation/>haskell.org</a>
documentation website. And you will see that most path involve a long
learning process. By that, I mean that you should read a long book and
invest a lot of hours and certainly days before having a good idea about
what Haskell is all about.<p>In contrast, this article is a brief and dense overview of all major
aspects of Haskell. I also added some information I lacked while I
learned Haskell.<p>The article contains five parts:<ul><li><p><strong>Essential Haskell</strong>: Haskell syntax, and some
essential notions.<li><p><strong>First Dive</strong>:<ul><li>Functional style; a progressive example, from imperative to
functional style<li>Types; types and a standard binary tree example<li>Infinite Structure; manipulate an infinite binary tree!</ul><li><p><strong>Dive into the impure</strong>:<ul><li>Deal with IO; A minimal example<li>IO trick explained; the hidden detail I lacked to understand IO<li>Monads; incredible how we can generalize</ul><li><p><strong>Start swimming</strong>: Start a new project.</ul><h2 id=install>Install</h2><figure><img src=./Haskell-logo.png.webp alt="Haskell logo"><figcaption aria-hidden=true>Haskell logo</figcaption></figure><p>If you are not using either Linux nor macOS, you should look here: <a href=https://www.haskell.html/downloads/>https://www.haskell.org/downloads/</a>.
Otherwise, you can follow my advice to use nix:<ol><li><p>Install <a href=https://nixos.html/nix>nix</a> (The version I
used while writting this article was nix (Nix) 2.3.1, future 2.X.X
versions should work with the examples in this article)<li><p>create a new empty directory <code class=verbatim>hsenv</code>
somewhere<li><p>Put the following <code class=verbatim>shell.nix</code> file
inside it<div class=sourceCode id=cb1 data-tangle=shell.nix><pre class="sourceCode nix"><code class="sourceCode nix"><span id=cb1-1><a href=#cb1-1 aria-hidden=true tabindex=-1></a><span class=op>{</span> <span class=va>nixpkgs</span> <span class=op>?</span> <span class=bu>import</span> <span class=op>(</span><span class=bu>fetchTarball</span> <span class=va>https</span><span class=op>://</span><span class=ss>github.com/NixOS/nixpkgs/archive/19.09.tar.gz</span><span class=op>)</span> <span class=op>{}</span> <span class=op>}</span>:</span>
<span id=cb1-2><a href=#cb1-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span></span>
<span id=cb1-3><a href=#cb1-3 aria-hidden=true tabindex=-1></a>  <span class=va>inherit</span> (<span class=va>nixpkgs</span>) <span class=va>pkgs</span>;</span>
<span id=cb1-4><a href=#cb1-4 aria-hidden=true tabindex=-1></a>  <span class=va>inherit</span> (<span class=va>pkgs</span>) <span class=va>haskellPackages</span>;</span>
<span id=cb1-5><a href=#cb1-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb1-6><a href=#cb1-6 aria-hidden=true tabindex=-1></a>  <span class=va>haskellDeps</span> <span class=op>=</span> <span class=va>ps</span><span class=op>:</span> <span class=kw>with</span> ps<span class=op>;</span> <span class=op>[</span></span>
<span id=cb1-7><a href=#cb1-7 aria-hidden=true tabindex=-1></a>    base</span>
<span id=cb1-8><a href=#cb1-8 aria-hidden=true tabindex=-1></a>    protolude</span>
<span id=cb1-9><a href=#cb1-9 aria-hidden=true tabindex=-1></a>    containers</span>
<span id=cb1-10><a href=#cb1-10 aria-hidden=true tabindex=-1></a>  <span class=op>];</span></span>
<span id=cb1-11><a href=#cb1-11 aria-hidden=true tabindex=-1></a></span>
<span id=cb1-12><a href=#cb1-12 aria-hidden=true tabindex=-1></a>  <span class=va>ghc</span> <span class=op>=</span> haskellPackages.ghcWithPackages haskellDeps<span class=op>;</span></span>
<span id=cb1-13><a href=#cb1-13 aria-hidden=true tabindex=-1></a></span>
<span id=cb1-14><a href=#cb1-14 aria-hidden=true tabindex=-1></a>  <span class=va>nixPackages</span> <span class=op>=</span> <span class=op>[</span></span>
<span id=cb1-15><a href=#cb1-15 aria-hidden=true tabindex=-1></a>    ghc</span>
<span id=cb1-16><a href=#cb1-16 aria-hidden=true tabindex=-1></a>    pkgs.gdb</span>
<span id=cb1-17><a href=#cb1-17 aria-hidden=true tabindex=-1></a>    haskellPackages.cabal-install</span>
<span id=cb1-18><a href=#cb1-18 aria-hidden=true tabindex=-1></a>  <span class=op>];</span></span>
<span id=cb1-19><a href=#cb1-19 aria-hidden=true tabindex=-1></a><span class=kw>in</span></span>
<span id=cb1-20><a href=#cb1-20 aria-hidden=true tabindex=-1></a>pkgs.stdenv.mkDerivation <span class=op>{</span></span>
<span id=cb1-21><a href=#cb1-21 aria-hidden=true tabindex=-1></a>  <span class=va>name</span> <span class=op>=</span> <span class=st>&quot;env&quot;</span><span class=op>;</span></span>
<span id=cb1-22><a href=#cb1-22 aria-hidden=true tabindex=-1></a>  <span class=va>buildInputs</span> <span class=op>=</span> nixPackages<span class=op>;</span></span>
<span id=cb1-23><a href=#cb1-23 aria-hidden=true tabindex=-1></a>  <span class=va>shellHook</span> <span class=op>=</span> <span class=st>&#39;&#39;</span></span>
<span id=cb1-24><a href=#cb1-24 aria-hidden=true tabindex=-1></a><span class=st>     export PS1=&quot;\n\[[hs:\033[1;32m\]\W\[\033[0m\]]&gt; &quot;</span></span>
<span id=cb1-25><a href=#cb1-25 aria-hidden=true tabindex=-1></a><span class=st>  &#39;&#39;</span><span class=op>;</span></span>
<span id=cb1-26><a href=#cb1-26 aria-hidden=true tabindex=-1></a><span class=op>}</span></span></code></pre></div><li><p>In the <code class=verbatim>hsenv</code> directory, in a
terminal, run <code class=verbatim>nix-shell --pure</code>. You should
wait a lot of time for everything to download. And you should be ready.
You will have in your PATH:<ul><li><code class=verbatim>ghc</code>, the Haskell compiler<li><code class=verbatim>ghci</code> that we can described as a
Haskell REPL<li><code class=verbatim>runghc</code> that will be able to interpret
a Haskell file<li><code class=verbatim>cabal</code> which is the main tool to deal
with Haskell projects<li>the Haskell libraries <code class=verbatim>protolude</code> and
<code class=verbatim>containers</code>.</ul><li><p>To test your env, rung <code class=verbatim>ghci</code> and
type <code class=verbatim>import Protolude</code> you should see
something like this:<pre><code>~/hsenv&gt; nix-shell
[nix-shell:~/hsenv]$ ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude&gt; import Protolude
Prelude Protolude&gt;
</code></pre></ol><p>Congratulations you should be ready to start now.<div class=notes><ul><li>There are multiple ways to install Haskell and I don't think there
is a full consensus between developer about what is the best method. If
you whish to use another method take a look at <a href=http://haskell.html>haskell.org</a>.<li>This install method is only suitable for using as a playground and I
think perfectly adapted to run code example from this article. I do not
recommend it for serious development.<li><code class=verbatim>nix</code> is a generic package manager and
goes beyond Haskell. One great good point is that it does not only
manage Haskell packages but really a lot of other kind of packages. This
can be helpful if you need to depends on a Haskell package that itself
depends on a system library, for example <code class=verbatim>ncurses</code>.<li>I use <a href=http://nixos.html/nix><code class=verbatim>nix</code></a> for other projects unrelated to Haskell.
For example, I use the nix-shell bang pattern for shell script for which
I can assume the executable I want are present.</ul></div><div class=notes><p><strong>BONUS</strong>: use <a href=https://direnv.net><code class=verbatim>direnv</code></a><pre><code>~ cd hsenv
~ echo &quot;use nix&quot; &gt; .envrc
~ direnv allow
</code></pre><p>Now each time you'll cd into your hsenv directory you'll get the
environment set for you.</div><h2 id="don't-be-afraid">Don't be afraid</h2><figure><img src=./munch_TheScream.jpg.webp alt="The Scream"><figcaption aria-hidden=true>The Scream</figcaption></figure><p>Many books/articles about Haskell start by introducing some esoteric
formula (quick sort, Fibonacci, etc…). I will do the exact opposite. At
first I won't show you any Haskell super power. I will start with
similarities between Haskell and other programming languages. Let's jump
to the mandatory "Hello World".<div class=sourceCode id=cb4 data-tangle=hello.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb4-1><a href=#cb4-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=st>&quot;Hello World!&quot;</span></span></code></pre></div><pre class=example><code>~ runghc hello.hs
Hello World!
</code></pre><p>Now, a program asking your name and replying "Hello" using the name
you entered:<div class=sourceCode id=cb6 data-tangle=name.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb6-1><a href=#cb6-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true tabindex=-1></a>    <span class=fu>print</span> <span class=st>&quot;What is your name?&quot;</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true tabindex=-1></a>    name <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true tabindex=-1></a>    <span class=fu>print</span> (<span class=st>&quot;Hello &quot;</span> <span class=op>++</span> name <span class=op>++</span> <span class=st>&quot;!&quot;</span>)</span></code></pre></div><p>First, let us compare this with similar programs in a few imperative
languages:<div class=sourceCode id=cb7><pre class="sourceCode python"><code class="sourceCode python"><span id=cb7-1><a href=#cb7-1 aria-hidden=true tabindex=-1></a><span class=co># Python</span></span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true tabindex=-1></a><span class=bu>print</span> <span class=st>&quot;What is your name?&quot;</span></span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true tabindex=-1></a>name <span class=op>=</span> <span class=bu>raw_input</span>()</span>
<span id=cb7-4><a href=#cb7-4 aria-hidden=true tabindex=-1></a><span class=bu>print</span> <span class=st>&quot;Hello </span><span class=sc>%s</span><span class=st>!&quot;</span> <span class=op>%</span> name</span></code></pre></div><div class=sourceCode id=cb8><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id=cb8-1><a href=#cb8-1 aria-hidden=true tabindex=-1></a><span class=co># Ruby</span></span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true tabindex=-1></a><span class=fu>puts</span> <span class=st>&quot;What is your name?&quot;</span></span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true tabindex=-1></a>name <span class=kw>=</span> <span class=fu>gets</span><span class=at>.chomp</span></span>
<span id=cb8-4><a href=#cb8-4 aria-hidden=true tabindex=-1></a><span class=fu>puts</span> <span class=st>&quot;Hello </span><span class=sc>#{</span>name<span class=sc>}</span><span class=st>!&quot;</span></span></code></pre></div><div class=sourceCode id=cb9 data-org-language=C><pre class="sourceCode c"><code class="sourceCode c"><span id=cb9-1><a href=#cb9-1 aria-hidden=true tabindex=-1></a><span class=co>// In C</span></span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true tabindex=-1></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true tabindex=-1></a><span class=dt>int</span> main <span class=op>(</span><span class=dt>int</span> argc<span class=op>,</span> <span class=dt>char</span> <span class=op>**</span>argv<span class=op>)</span> <span class=op>{</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true tabindex=-1></a>    <span class=dt>char</span> name<span class=op>[</span><span class=dv>666</span><span class=op>];</span> <span class=co>// &lt;- An Evil Number!</span></span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true tabindex=-1></a>    <span class=co>// What if my name is more than 665 character long?</span></span>
<span id=cb9-6><a href=#cb9-6 aria-hidden=true tabindex=-1></a>    printf<span class=op>(</span><span class=st>&quot;What is your name?</span><span class=sc>\n</span><span class=st>&quot;</span><span class=op>);</span></span>
<span id=cb9-7><a href=#cb9-7 aria-hidden=true tabindex=-1></a>    scanf<span class=op>(</span><span class=st>&quot;</span><span class=sc>%s</span><span class=st>&quot;</span><span class=op>,</span> name<span class=op>);</span></span>
<span id=cb9-8><a href=#cb9-8 aria-hidden=true tabindex=-1></a>    printf<span class=op>(</span><span class=st>&quot;Hello </span><span class=sc>%s</span><span class=st>!</span><span class=sc>\n</span><span class=st>&quot;</span><span class=op>,</span> name<span class=op>);</span></span>
<span id=cb9-9><a href=#cb9-9 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> <span class=dv>0</span><span class=op>;</span></span>
<span id=cb9-10><a href=#cb9-10 aria-hidden=true tabindex=-1></a><span class=op>}</span></span></code></pre></div><p>The structure is the same, but there are some syntax differences. The
main part of this tutorial will be dedicated to explaining why.<p>In Haskell there is a <code class=verbatim>main</code> function and
every object has a type. The type of <code class=verbatim>main</code>
is <code class=verbatim>IO ()</code>. This means <code class=verbatim>main</code> will cause side effects.<p>Just remember that Haskell can look a lot like mainstream imperative
languages.<h2 id=very-basic-haskell>Very basic Haskell</h2><figure><img src=./picasso_owl.jpg.webp alt="Picasso minimal owl"><figcaption aria-hidden=true>Picasso minimal owl</figcaption></figure><p>Before continuing you need to be warned about some essential
properties of Haskell.<p><em>Functional</em><p>Haskell is a functional language. If you have an imperative language
background, you'll have to learn a lot of new things. Hopefully many of
these new concepts will help you to program even in imperative
languages.<p><em>Advanced Static Typing</em><p>Instead of being in your way like in <code class=verbatim>C</code>,
<code class=verbatim>C++</code> or <code class=verbatim>Java</code>,
the type system is here to help you.<p><em>Purity</em><p>Generally your functions won't modify anything in the outside world.
This means they can't modify the value of a variable, can't get user
input, can't write on the screen, can't launch a missile. On the other
hand, parallelism will be very easy to achieve. Haskell makes it clear
where effects occur and where your code is pure. Also, it will be far
easier to reason about your program. Most bugs will be prevented in the
pure parts of your program.<p>Furthermore, pure functions follow a fundamental law in Haskell:<blockquote><p>Applying a function with the same parameters always returns the same
value.</blockquote><p><em>Laziness</em><p>Laziness by default is an uncommon language design. By default,
Haskell evaluates something only when it is needed. In consequence, it
provides an elegant way to manipulate infinite structures, for
example.<p>A last warning about how you should read Haskell code. For me, it is
like reading scientific papers. Some parts are clear, but when you see a
formula, just focus and read slower. Also, while learning Haskell, it
<em>really</em> doesn't matter much if you don't understand syntax
details. If you meet a <code class=verbatim>>>=</code>, <code class=verbatim>&lt;$></code>, <code class=verbatim>&lt;-</code>
or any other weird symbol, just ignore them and follows the flow of the
code.<h3 id=function-declaration>Function declaration</h3><p>You might be used to declaring functions like this:<p>In <code class=verbatim>C</code>:<div class=sourceCode id=cb10 data-org-language=C><pre class="sourceCode c"><code class="sourceCode c"><span id=cb10-1><a href=#cb10-1 aria-hidden=true tabindex=-1></a><span class=dt>int</span> f<span class=op>(</span><span class=dt>int</span> x<span class=op>,</span> <span class=dt>int</span> y<span class=op>)</span> <span class=op>{</span></span>
<span id=cb10-2><a href=#cb10-2 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y<span class=op>;</span></span>
<span id=cb10-3><a href=#cb10-3 aria-hidden=true tabindex=-1></a><span class=op>}</span></span></code></pre></div><p>In JavaScript:<div class=sourceCode id=cb11><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id=cb11-1><a href=#cb11-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>f</span>(x<span class=op>,</span>y) {</span>
<span id=cb11-2><a href=#cb11-2 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y<span class=op>;</span></span>
<span id=cb11-3><a href=#cb11-3 aria-hidden=true tabindex=-1></a>}</span></code></pre></div><p>in Python:<div class=sourceCode id=cb12><pre class="sourceCode python"><code class="sourceCode python"><span id=cb12-1><a href=#cb12-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> f(x,y):</span>
<span id=cb12-2><a href=#cb12-2 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span></code></pre></div><p>in Ruby:<div class=sourceCode id=cb13><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id=cb13-1><a href=#cb13-1 aria-hidden=true tabindex=-1></a><span class=cf>def</span> f(x,y)</span>
<span id=cb13-2><a href=#cb13-2 aria-hidden=true tabindex=-1></a>    x<span class=kw>*</span>x <span class=kw>+</span> y<span class=kw>*</span>y</span>
<span id=cb13-3><a href=#cb13-3 aria-hidden=true tabindex=-1></a><span class=cf>end</span></span></code></pre></div><p>In Scheme:<div class=sourceCode id=cb14><pre class="sourceCode scheme"><code class="sourceCode scheme"><span id=cb14-1><a href=#cb14-1 aria-hidden=true tabindex=-1></a>(<span class=ex>define</span><span class=fu> </span>(f x y)</span>
<span id=cb14-2><a href=#cb14-2 aria-hidden=true tabindex=-1></a>    (<span class=op>+</span> (<span class=op>*</span> x x) (<span class=op>*</span> y y)))</span></code></pre></div><p>Finally, the Haskell way is:<div class=sourceCode id=cb15><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb15-1><a href=#cb15-1 aria-hidden=true tabindex=-1></a>f x y <span class=ot>=</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span></code></pre></div><p>Very clean. No parenthesis, no <code class=verbatim>def</code>.<p>Don't forget, Haskell uses functions and types a lot. It is thus very
easy to define them. The syntax was particularly well thought out for
these objects.<h3 id=a-type-example>A Type Example</h3><p>Although it is not mandatory, type information for functions is
usually made explicit. It's not mandatory because the compiler is smart
enough to infer it for you. It's a good idea because it indicates intent
and understanding.<p>Let's play a little. We declare the type using <code class=verbatim>::</code><div class=sourceCode id=cb16 data-tangle=basic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb16-1><a href=#cb16-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span></span>
<span id=cb16-2><a href=#cb16-2 aria-hidden=true tabindex=-1></a>f x y <span class=ot>=</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span>
<span id=cb16-3><a href=#cb16-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb16-4><a href=#cb16-4 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> (f <span class=dv>2</span> <span class=dv>3</span>)</span></code></pre></div><pre class=example><code>[nix-shell:~/hsenv]$ runghc basic.hs
13
</code></pre><p>Now try<div class=sourceCode id=cb18 data-tangle=error_basic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb18-1><a href=#cb18-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span></span>
<span id=cb18-2><a href=#cb18-2 aria-hidden=true tabindex=-1></a>f x y <span class=ot>=</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span>
<span id=cb18-3><a href=#cb18-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb18-4><a href=#cb18-4 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> (f <span class=fl>2.3</span> <span class=fl>4.2</span>)</span></code></pre></div><p>You should get this error:<pre class=example><code>[nix-shell:~/hsenv]$ runghc error_basic.hs

error_basic.hs:4:17: error:
    • No instance for (Fractional Int) arising from the literal ‘2.3’
    • In the first argument of ‘f’, namely ‘2.3’
      In the first argument of ‘print’, namely ‘(f 2.3 4.2)’
      In the expression: print (f 2.3 4.2)
  |
4 | main = print (f 2.3 4.2)
  |                 ^^^
</code></pre><p>The problem: <code class=verbatim>4.2</code> isn't an Int.<p>The solution: don't declare a type for <code class=verbatim>f</code> for the moment and let Haskell infer the most
general type for us:<div class=sourceCode id=cb20 data-tangle=float_basic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb20-1><a href=#cb20-1 aria-hidden=true tabindex=-1></a>f x y <span class=ot>=</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span>
<span id=cb20-2><a href=#cb20-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb20-3><a href=#cb20-3 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> (f <span class=fl>2.3</span> <span class=fl>4.2</span>)</span></code></pre></div><pre class=example><code>[nix-shell:~/hsenv]$ runghc float_basic.hs
22.93
</code></pre><p>It works! Luckily, we don't have to declare a new function for every
single type. For example, in <code class=verbatim>C</code>, you'll
have to declare a function for <code class=verbatim>int</code>, for
<code class=verbatim>float</code>, for <code class=verbatim>long</code>, for <code class=verbatim>double</code>,
etc…<p>But, what type should we declare? To discover the type Haskell has
found for us, just launch ghci:<pre class=example><code>% ghci
GHCi, version 7.0.4: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package ffi-1.0 ... linking ... done.
Prelude&gt; let f x y = x*x + y*y
Prelude&gt; :type f
f :: Num a =&gt; a -&gt; a -&gt; a
</code></pre><p>Uh? What is this strange type?<div class=sourceCode id=cb23><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb23-1><a href=#cb23-1 aria-hidden=true tabindex=-1></a><span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a</span></code></pre></div><p>First, let's focus on the right part <code class=verbatim>a -> a -> a</code>. To understand it, just look
at a list of progressive examples:<table><thead><tr class=header><th>The written type<th>Its meaning<tbody><tr class=odd><td><code class=verbatim>Int</code><td>the type <code class=verbatim>Int</code><tr class=even><td><code class=verbatim>Int -> Int</code><td>the type function from <code class=verbatim>Int</code> to <code class=verbatim>Int</code><tr class=odd><td><code class=verbatim>Float -> Int</code><td>the type function from <code class=verbatim>Float</code> to <code class=verbatim>Int</code><tr class=even><td><code class=verbatim>a -> Int</code><td>the type function from any type to <code class=verbatim>Int</code><tr class=odd><td><code class=verbatim>a -> a</code><td>the type function from any type <code class=verbatim>a</code> to
the same type <code class=verbatim>a</code><tr class=even><td><code class=verbatim>a -> a -> a</code><td>the type function of two arguments of any type <code class=verbatim>a</code> to the same type <code class=verbatim>a</code></table><p>In the type <code class=verbatim>a -> a -> a</code>, the
letter <code class=verbatim>a</code> is a <em>type variable</em>. It
means <code class=verbatim>f</code> is a function with two arguments
and both arguments and the result have the same type. The type variable
<code class=verbatim>a</code> could take many different type values.
For example <code class=verbatim>Int</code>, <code class=verbatim>Integer</code>, <code class=verbatim>Float</code>…<p>So instead of having a forced type like in <code class=verbatim>C</code> and having to declare a function for <code class=verbatim>int</code>, <code class=verbatim>long</code>, <code class=verbatim>float</code>, <code class=verbatim>double</code>,
etc., we declare only one function like in a dynamically typed
language.<p>This is sometimes called parametric polymorphism. It's also called
having your cake and eating it too.<p>Generally <code class=verbatim>a</code> can be any type, for
example a <code class=verbatim>String</code> or an <code class=verbatim>Int</code>, but also more complex types, like <code class=verbatim>Trees</code>, other functions, etc… But here our type
is prefixed with <code class=verbatim>Num a =></code>.<p><code class=verbatim>Num</code> is a <em>type class</em>. A type
class can be understood as a set of types. <code class=verbatim>Num</code> contains only types which behave like
numbers. More precisely, <code class=verbatim>Num</code> is class
containing types which implement a specific list of functions, and in
particular <code class=verbatim>(+)</code> and <code class=verbatim>(*)</code>.<p>Type classes are a very powerful language construct. We can do some
incredibly powerful stuff with this. More on this later.<p>Finally, <code class=verbatim>Num a => a -> a -> a</code>
means:<p>Let <code class=verbatim>a</code> be a type belonging to the <code class=verbatim>Num</code> type class. This is a function from type
<code class=verbatim>a</code> to (<code class=verbatim>a -> a</code>).<p>Yes, strange. In fact, in Haskell no function really has two
arguments. Instead all functions have only one argument. But we will
note that taking two arguments is equivalent to taking one argument and
returning a function taking the second argument as a parameter.<p>More precisely <code class=verbatim>f 3 4</code> is equivalent to
<code class=verbatim>(f 3) 4</code>. Note <code class=verbatim>f 3</code> is a function:<div class=sourceCode id=cb24><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb24-1><a href=#cb24-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a</span>
<span id=cb24-2><a href=#cb24-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb24-3><a href=#cb24-3 aria-hidden=true tabindex=-1></a><span class=ot>g ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a</span>
<span id=cb24-4><a href=#cb24-4 aria-hidden=true tabindex=-1></a>g <span class=ot>=</span> f <span class=dv>3</span></span>
<span id=cb24-5><a href=#cb24-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb24-6><a href=#cb24-6 aria-hidden=true tabindex=-1></a>g y ⇔ <span class=dv>3</span><span class=op>*</span><span class=dv>3</span> <span class=op>+</span> y<span class=op>*</span>y</span></code></pre></div><p>Another notation exists for functions. The lambda notation allows us
to create functions without assigning them a name. We call them
anonymous functions. We could also have written:<div class=sourceCode id=cb25><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb25-1><a href=#cb25-1 aria-hidden=true tabindex=-1></a>g <span class=ot>=</span> \y <span class=ot>-&gt;</span> <span class=dv>3</span><span class=op>*</span><span class=dv>3</span> <span class=op>+</span> y<span class=op>*</span>y</span></code></pre></div><p>The <code class=verbatim>\</code> is used because it looks like
<code class=verbatim>λ</code> and is ASCII.<p>If you are not used to functional programming your brain should be
starting to heat up. It is time to make a real application.<p>But just before that, we should verify the type system works as
expected:<div class=sourceCode id=cb26 data-tangle=typed_float_basic.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb26-1><a href=#cb26-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a</span>
<span id=cb26-2><a href=#cb26-2 aria-hidden=true tabindex=-1></a>f x y <span class=ot>=</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span>
<span id=cb26-3><a href=#cb26-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb26-4><a href=#cb26-4 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> (f <span class=dv>3</span> <span class=fl>2.4</span>)</span></code></pre></div><p>It works, because, <code class=verbatim>3</code> is a valid
representation both for Fractional numbers like Float and for Integer.
As <code class=verbatim>2.4</code> is a Fractional number, <code class=verbatim>3</code> is then interpreted as being also a Fractional
number.<p>If we force our function to work with different types, it will
fail:<div class=sourceCode id=cb27><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb27-1><a href=#cb27-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> a</span>
<span id=cb27-2><a href=#cb27-2 aria-hidden=true tabindex=-1></a>f x y <span class=ot>=</span> x<span class=op>*</span>x <span class=op>+</span> y<span class=op>*</span>y</span>
<span id=cb27-3><a href=#cb27-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb27-4><a href=#cb27-4 aria-hidden=true tabindex=-1></a><span class=ot>x ::</span> <span class=dt>Int</span></span>
<span id=cb27-5><a href=#cb27-5 aria-hidden=true tabindex=-1></a>x <span class=ot>=</span> <span class=dv>3</span></span>
<span id=cb27-6><a href=#cb27-6 aria-hidden=true tabindex=-1></a><span class=ot>y ::</span> <span class=dt>Float</span></span>
<span id=cb27-7><a href=#cb27-7 aria-hidden=true tabindex=-1></a>y <span class=ot>=</span> <span class=fl>2.4</span></span>
<span id=cb27-8><a href=#cb27-8 aria-hidden=true tabindex=-1></a><span class=co>-- won&#39;t work because type x ≠ type y</span></span>
<span id=cb27-9><a href=#cb27-9 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> (f x y)</span></code></pre></div><p>The compiler complains. The two parameters must have the same
type.<p>If you believe that this is a bad idea, and that the compiler should
make the transformation from one type to another for you, you should
really watch this great (and funny) video: <a href=https://www.destroyallsoftware.com/talks/wat>WAT</a><h1 id=essential-haskell>Essential Haskell</h1><figure><img src=./kandinsky_gugg.jpg.webp alt="Kandinsky Gugg"><figcaption aria-hidden=true>Kandinsky Gugg</figcaption></figure><p>I suggest that you skim this part. Think of it as a reference.
Haskell has a lot of features. A lot of information is missing here.
Come back here if the notation feels strange.<p>I use the <code class=verbatim>⇔</code> symbol to state that two
expression are equivalent. It is a meta notation, <code class=verbatim>⇔</code> does not exists in Haskell. I will also use
<code class=verbatim>⇒</code> to show what the return value of an
expression is.<h2 id=notations>Notations</h2><p>Arithmetic<pre><code>3 + 2 * 6 / 3 ⇔ 3 + ((2*6)/3)
</code></pre><p>Logic<pre><code>True || False ⇒ True
True &amp;&amp; False ⇒ False
True == False ⇒ False
True /= False ⇒ True  (/=) is the operator for different
</code></pre><p>Powers<pre><code>x^n     for n an integral (understand Int or Integer)
x**y    for y any kind of number (Float for example)
</code></pre><p><code class=verbatim>Integer</code> has no limit except the
capacity of your machine:<pre class=example><code>4^103
102844034832575377634685573909834406561420991602098741459288064
</code></pre><p>Yeah! And also rational numbers FTW! But you need to import the
module <code class=verbatim>Data.Ratio</code>:<pre class=example><code>$ ghci
....
Prelude&gt; :m Data.Ratio
Data.Ratio&gt; (11 % 15) * (5 % 3)
11 % 9
</code></pre><p>Lists<pre class=example><code>[]                      ⇔ empty list
[1,2,3]                 ⇔ List of integral
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]     ⇔ List of String
1:[2,3]                 ⇔ [1,2,3], (:) prepend one element
1:2:[]                  ⇔ [1,2]
[1,2] ++ [3,4]          ⇔ [1,2,3,4], (++) concatenate
[1,2,3] ++ [&quot;foo&quot;]      ⇔ ERROR String ≠ Integral
[1..4]                  ⇔ [1,2,3,4]
[1,3..10]               ⇔ [1,3,5,7,9]
[2,3,5,7,11..100]       ⇔ ERROR! I am not so smart!
[10,9..1]               ⇔ [10,9,8,7,6,5,4,3,2,1]
</code></pre><p>Strings<p>In Haskell strings are list of <code class=verbatim>Char</code>.<pre class=example><code>&#39;a&#39; :: Char
&quot;a&quot; :: [Char]
&quot;&quot;  ⇔ []
&quot;ab&quot; ⇔ [&#39;a&#39;,&#39;b&#39;] ⇔  &#39;a&#39;:&quot;b&quot; ⇔ &#39;a&#39;:[&#39;b&#39;] ⇔ &#39;a&#39;:&#39;b&#39;:[]
&quot;abc&quot; ⇔ &quot;ab&quot;++&quot;c&quot;
</code></pre><blockquote><p><em>Remark</em>: In real code you shouldn't use list of char to
represent text. You should mostly use <code class=verbatim>Data.Text</code> instead. If you want to represent a
stream of ASCII char, you should use <code class=verbatim>Data.ByteString</code>.</blockquote><p>Tuples<p>The type of couple is <code class=verbatim>(a,b)</code>. Elements
in a tuple can have different types.<pre class=example><code>-- All these tuples are valid
(2,&quot;foo&quot;)
(3,&#39;a&#39;,[2,3])
((2,&quot;a&quot;),&quot;c&quot;,3)

fst (x,y)       ⇒  x
snd (x,y)       ⇒  y

fst (x,y,z)     ⇒  ERROR: fst :: (a,b) -&gt; a
snd (x,y,z)     ⇒  ERROR: snd :: (a,b) -&gt; b
</code></pre><p>Deal with parentheses<p>To remove some parentheses you can use two functions: <code class=verbatim>($)</code> and <code class=verbatim>(.)</code>.<pre class=example><code>-- By default:
f g h x         ⇔  (((f g) h) x)

-- the $ replace parenthesis from the $
-- to the end of the expression
f g $ h x       ⇔  f g (h x) ⇔ (f g) (h x)
f $ g h x       ⇔  f (g h x) ⇔ f ((g h) x)
f $ g $ h x     ⇔  f (g (h x))

-- (.) the composition function
(f . g) x       ⇔  f (g x)
(f . g . h) x   ⇔  f (g (h x))
</code></pre><h2 id=useful-notations-for-functions>Useful notations for
functions</h2><p>Just a reminder:<pre class=example><code>x :: Int            ⇔ x is of type Int
x :: a              ⇔ x can be of any type
x :: Num a =&gt; a     ⇔ x can be any type a
                      such that a belongs to Num type class
f :: a -&gt; b         ⇔ f is a function from a to b
f :: a -&gt; b -&gt; c    ⇔ f is a function from a to (b→c)
f :: (a -&gt; b) -&gt; c  ⇔ f is a function from (a→b) to c
</code></pre><p>Remember that defining the type of a function before its declaration
isn't mandatory. Haskell infers the most general type for you. But it is
considered a good practice to do so.<p><em>Infix notation</em><div class=sourceCode id=cb38 data-tangle=functions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb38-1><a href=#cb38-1 aria-hidden=true tabindex=-1></a><span class=ot>square ::</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a</span>
<span id=cb38-2><a href=#cb38-2 aria-hidden=true tabindex=-1></a>square x <span class=ot>=</span> x<span class=op>^</span><span class=dv>2</span></span></code></pre></div><p>Note <code class=verbatim>^</code> uses infix notation. For each
infix operator there its associated prefix notation. You just have to
put it inside parenthesis.<div class=sourceCode id=cb39 data-tangle=functions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb39-1><a href=#cb39-1 aria-hidden=true tabindex=-1></a>square&#39; x <span class=ot>=</span> (<span class=op>^</span>) x <span class=dv>2</span></span>
<span id=cb39-2><a href=#cb39-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb39-3><a href=#cb39-3 aria-hidden=true tabindex=-1></a>square&#39;&#39; x <span class=ot>=</span> (<span class=op>^</span><span class=dv>2</span>) x</span></code></pre></div><p>We can remove <code class=verbatim>x</code> in the left and right
side! It's called η-reduction.<div class=sourceCode id=cb40 data-tangle=functions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb40-1><a href=#cb40-1 aria-hidden=true tabindex=-1></a>square&#39;&#39;&#39; <span class=ot>=</span> (<span class=op>^</span><span class=dv>2</span>)</span></code></pre></div><p>Note we can declare functions with <code class=verbatim>'</code> in
their name. Here:<blockquote><p><code class=verbatim>square</code> ⇔ <code class=verbatim>square'</code> ⇔ <code class=verbatim>square''</code>
⇔ <code class=verbatim>square'''</code></blockquote><p>Note for each prefix notation you can transform it to infix notation
with <code class=verbatim>`</code> like this:<pre class=example><code>foo x y ↔ x `foo` y
</code></pre><p><em>Tests</em><p>An implementation of the absolute function.<div class=sourceCode id=cb42 data-tangle=functions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb42-1><a href=#cb42-1 aria-hidden=true tabindex=-1></a><span class=ot>absolute ::</span> (<span class=dt>Ord</span> a, <span class=dt>Num</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a</span>
<span id=cb42-2><a href=#cb42-2 aria-hidden=true tabindex=-1></a>absolute x <span class=ot>=</span> <span class=kw>if</span> x <span class=op>&gt;=</span> <span class=dv>0</span> <span class=kw>then</span> x <span class=kw>else</span> <span class=op>-</span>x</span></code></pre></div><p>Note: the <code class=verbatim>if .. then .. else</code> Haskell
notation is more like the <code class=verbatim>¤?¤:¤</code> C
operator. You cannot forget the <code class=verbatim>else</code>.<p>Another equivalent version:<div class=sourceCode id=cb43 data-tangle=functions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb43-1><a href=#cb43-1 aria-hidden=true tabindex=-1></a>absolute&#39; x</span>
<span id=cb43-2><a href=#cb43-2 aria-hidden=true tabindex=-1></a>    <span class=op>|</span> x <span class=op>&gt;=</span> <span class=dv>0</span> <span class=ot>=</span> x</span>
<span id=cb43-3><a href=#cb43-3 aria-hidden=true tabindex=-1></a>    <span class=op>|</span> <span class=fu>otherwise</span> <span class=ot>=</span> <span class=op>-</span>x</span></code></pre></div><blockquote><p>Notation warning: indentation is <em>important</em> in Haskell. Like
in Python, bad indentation can break your code!</blockquote><div class=sourceCode id=cb44 data-tangle=functions.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb44-1><a href=#cb44-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb44-2><a href=#cb44-2 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> square <span class=dv>10</span></span>
<span id=cb44-3><a href=#cb44-3 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> square&#39; <span class=dv>10</span></span>
<span id=cb44-4><a href=#cb44-4 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> square&#39;&#39; <span class=dv>10</span></span>
<span id=cb44-5><a href=#cb44-5 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> square&#39;&#39;&#39; <span class=dv>10</span></span>
<span id=cb44-6><a href=#cb44-6 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> absolute <span class=dv>10</span></span>
<span id=cb44-7><a href=#cb44-7 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> absolute (<span class=op>-</span><span class=dv>10</span>)</span>
<span id=cb44-8><a href=#cb44-8 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> absolute&#39; <span class=dv>10</span></span>
<span id=cb44-9><a href=#cb44-9 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> <span class=op>$</span> absolute&#39; (<span class=op>-</span><span class=dv>10</span>)</span></code></pre></div><pre class=example><code>~/t/hsenv&gt; runghc functions.hs
100
100
100
100
10
10
10
10
</code></pre><h1 id=first-dive>First dive</h1><p>In this part, you will be introduced to functional style, types and
infinite structures manipulation.<h2 id=functional-style>Functional style</h2><figure><img src=./hr_giger_biomechanicallandscape_500.jpg.webp alt="Biomechanical Landscape by H.R. Giger"><figcaption aria-hidden=true>Biomechanical Landscape by H.R.
Giger</figcaption></figure><p>In this section, I will give a short example of the impressive
refactoring ability provided by Haskell. We will select a problem and
solve it in a standard imperative way. Then I will make the code evolve.
The end result will be both more elegant and easier to adapt.<p>Let's solve the following problem:<blockquote><p>Given a list of integers, return the sum of the even numbers in the
list.<p>example: <code class=verbatim>[1,2,3,4,5] ⇒ 2 + 4 ⇒ 6</code></blockquote><p>To show differences between functional and imperative approaches,
I'll start by providing an imperative solution (in javascript):<div class=sourceCode id=cb46><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id=cb46-1><a href=#cb46-1 aria-hidden=true tabindex=-1></a><span class=kw>function</span> <span class=fu>evenSum</span>(list) {</span>
<span id=cb46-2><a href=#cb46-2 aria-hidden=true tabindex=-1></a>    <span class=kw>var</span> result <span class=op>=</span> <span class=dv>0</span><span class=op>;</span></span>
<span id=cb46-3><a href=#cb46-3 aria-hidden=true tabindex=-1></a>    <span class=cf>for</span> (<span class=kw>var</span> i<span class=op>=</span><span class=dv>0</span><span class=op>;</span> i<span class=op>&lt;</span> list<span class=op>.</span><span class=at>length</span> <span class=op>;</span> i<span class=op>++</span>) {</span>
<span id=cb46-4><a href=#cb46-4 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> (list[i] <span class=op>%</span> <span class=dv>2</span> <span class=op>==</span><span class=dv>0</span>) {</span>
<span id=cb46-5><a href=#cb46-5 aria-hidden=true tabindex=-1></a>            result <span class=op>+=</span> list[i]<span class=op>;</span></span>
<span id=cb46-6><a href=#cb46-6 aria-hidden=true tabindex=-1></a>        }</span>
<span id=cb46-7><a href=#cb46-7 aria-hidden=true tabindex=-1></a>    }</span>
<span id=cb46-8><a href=#cb46-8 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> result<span class=op>;</span></span>
<span id=cb46-9><a href=#cb46-9 aria-hidden=true tabindex=-1></a>}</span></code></pre></div><p>In Haskell, by contrast, we don't have variables or a for loop. One
solution to achieve the same result without loops is to use
recursion.<blockquote><p><em>Remark</em>: Recursion is generally perceived as slow in
imperative languages. But this is generally not the case in functional
programming. Most of the time Haskell will handle recursive functions
efficiently.</blockquote><p>Here is a <code class=verbatim>C</code> version of the recursive
function. Note that for simplicity I assume the int list ends with the
first <code class=verbatim>0</code> value.<div class=sourceCode id=cb47 data-org-language=C><pre class="sourceCode c"><code class="sourceCode c"><span id=cb47-1><a href=#cb47-1 aria-hidden=true tabindex=-1></a><span class=dt>int</span> evenSum<span class=op>(</span><span class=dt>int</span> <span class=op>*</span>list<span class=op>)</span> <span class=op>{</span></span>
<span id=cb47-2><a href=#cb47-2 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> accumSum<span class=op>(</span><span class=dv>0</span><span class=op>,</span>list<span class=op>);</span></span>
<span id=cb47-3><a href=#cb47-3 aria-hidden=true tabindex=-1></a><span class=op>}</span></span>
<span id=cb47-4><a href=#cb47-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb47-5><a href=#cb47-5 aria-hidden=true tabindex=-1></a><span class=dt>int</span> accumSum<span class=op>(</span><span class=dt>int</span> n<span class=op>,</span> <span class=dt>int</span> <span class=op>*</span>list<span class=op>)</span> <span class=op>{</span></span>
<span id=cb47-6><a href=#cb47-6 aria-hidden=true tabindex=-1></a>    <span class=dt>int</span> x<span class=op>;</span></span>
<span id=cb47-7><a href=#cb47-7 aria-hidden=true tabindex=-1></a>    <span class=dt>int</span> <span class=op>*</span>xs<span class=op>;</span></span>
<span id=cb47-8><a href=#cb47-8 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=op>(*</span>list <span class=op>==</span> <span class=dv>0</span><span class=op>)</span> <span class=op>{</span> <span class=co>// if the list is empty</span></span>
<span id=cb47-9><a href=#cb47-9 aria-hidden=true tabindex=-1></a>        <span class=cf>return</span> n<span class=op>;</span></span>
<span id=cb47-10><a href=#cb47-10 aria-hidden=true tabindex=-1></a>    <span class=op>}</span> <span class=cf>else</span> <span class=op>{</span></span>
<span id=cb47-11><a href=#cb47-11 aria-hidden=true tabindex=-1></a>        x <span class=op>=</span> list<span class=op>[</span><span class=dv>0</span><span class=op>];</span> <span class=co>// let x be the first element of the list</span></span>
<span id=cb47-12><a href=#cb47-12 aria-hidden=true tabindex=-1></a>        xs <span class=op>=</span> list<span class=op>+</span><span class=dv>1</span><span class=op>;</span> <span class=co>// let xs be the list without x</span></span>
<span id=cb47-13><a href=#cb47-13 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> <span class=op>(</span> <span class=dv>0</span> <span class=op>==</span> <span class=op>(</span>x<span class=op>%</span><span class=dv>2</span><span class=op>)</span> <span class=op>)</span> <span class=op>{</span> <span class=co>// if x is even</span></span>
<span id=cb47-14><a href=#cb47-14 aria-hidden=true tabindex=-1></a>            <span class=cf>return</span> accumSum<span class=op>(</span>n<span class=op>+</span>x<span class=op>,</span> xs<span class=op>);</span></span>
<span id=cb47-15><a href=#cb47-15 aria-hidden=true tabindex=-1></a>        <span class=op>}</span> <span class=cf>else</span> <span class=op>{</span></span>
<span id=cb47-16><a href=#cb47-16 aria-hidden=true tabindex=-1></a>            <span class=cf>return</span> accumSum<span class=op>(</span>n<span class=op>,</span> xs<span class=op>);</span></span>
<span id=cb47-17><a href=#cb47-17 aria-hidden=true tabindex=-1></a>        <span class=op>}</span></span>
<span id=cb47-18><a href=#cb47-18 aria-hidden=true tabindex=-1></a>    <span class=op>}</span></span>
<span id=cb47-19><a href=#cb47-19 aria-hidden=true tabindex=-1></a><span class=op>}</span></span></code></pre></div><p>Keep this code in mind. We will translate it into Haskell. First,
however, I need to introduce three simple but useful functions we will
use:<div class=sourceCode id=cb48><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb48-1><a href=#cb48-1 aria-hidden=true tabindex=-1></a><span class=fu>even</span><span class=ot> ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span></span>
<span id=cb48-2><a href=#cb48-2 aria-hidden=true tabindex=-1></a><span class=fu>head</span><span class=ot> ::</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb48-3><a href=#cb48-3 aria-hidden=true tabindex=-1></a><span class=fu>tail</span><span class=ot> ::</span> [a] <span class=ot>-&gt;</span> [a]</span></code></pre></div><p><code class=verbatim>even</code> verifies if a number is even.<div class=sourceCode id=cb49><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb49-1><a href=#cb49-1 aria-hidden=true tabindex=-1></a><span class=fu>even</span><span class=ot> ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span></span>
<span id=cb49-2><a href=#cb49-2 aria-hidden=true tabindex=-1></a><span class=fu>even</span> <span class=dv>3</span>  ⇒ <span class=dt>False</span></span>
<span id=cb49-3><a href=#cb49-3 aria-hidden=true tabindex=-1></a><span class=fu>even</span> <span class=dv>2</span>  ⇒ <span class=dt>True</span></span></code></pre></div><p><code class=verbatim>head</code> returns the first element of a
list:<div class=sourceCode id=cb50><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb50-1><a href=#cb50-1 aria-hidden=true tabindex=-1></a><span class=fu>head</span><span class=ot> ::</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb50-2><a href=#cb50-2 aria-hidden=true tabindex=-1></a><span class=fu>head</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] ⇒ <span class=dv>1</span></span>
<span id=cb50-3><a href=#cb50-3 aria-hidden=true tabindex=-1></a><span class=fu>head</span> []      ⇒ <span class=dt>ERROR</span></span></code></pre></div><p><code class=verbatim>tail</code> returns all elements of a list,
except the first:<div class=sourceCode id=cb51><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb51-1><a href=#cb51-1 aria-hidden=true tabindex=-1></a><span class=fu>tail</span><span class=ot> ::</span> [a] <span class=ot>-&gt;</span> [a]</span>
<span id=cb51-2><a href=#cb51-2 aria-hidden=true tabindex=-1></a><span class=fu>tail</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] ⇒ [<span class=dv>2</span>,<span class=dv>3</span>]</span>
<span id=cb51-3><a href=#cb51-3 aria-hidden=true tabindex=-1></a><span class=fu>tail</span> [<span class=dv>3</span>]     ⇒ []</span>
<span id=cb51-4><a href=#cb51-4 aria-hidden=true tabindex=-1></a><span class=fu>tail</span> []      ⇒ <span class=dt>ERROR</span></span></code></pre></div><p>Note that for any non empty list <code class=verbatim>l</code>,
<code class=verbatim>l ⇔ (head l):(tail l)</code><p>The first Haskell solution. The function <code class=verbatim>evenSum</code> returns the sum of all even numbers in a
list:<div class=sourceCode id=cb52 data-tangle=evenSum_v1.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb52-1><a href=#cb52-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 1</span></span>
<span id=cb52-2><a href=#cb52-2 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> [<span class=dt>Integer</span>] <span class=ot>-&gt;</span> <span class=dt>Integer</span></span>
<span id=cb52-3><a href=#cb52-3 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> accumSum <span class=dv>0</span> l</span>
<span id=cb52-4><a href=#cb52-4 aria-hidden=true tabindex=-1></a>accumSum n l <span class=ot>=</span> <span class=kw>if</span> l <span class=op>==</span> []</span>
<span id=cb52-5><a href=#cb52-5 aria-hidden=true tabindex=-1></a>                  <span class=kw>then</span> n</span>
<span id=cb52-6><a href=#cb52-6 aria-hidden=true tabindex=-1></a>                  <span class=kw>else</span> <span class=kw>let</span> x <span class=ot>=</span> <span class=fu>head</span> l</span>
<span id=cb52-7><a href=#cb52-7 aria-hidden=true tabindex=-1></a>                           xs <span class=ot>=</span> <span class=fu>tail</span> l</span>
<span id=cb52-8><a href=#cb52-8 aria-hidden=true tabindex=-1></a>                       <span class=kw>in</span> <span class=kw>if</span> <span class=fu>even</span> x</span>
<span id=cb52-9><a href=#cb52-9 aria-hidden=true tabindex=-1></a>                              <span class=kw>then</span> accumSum (n<span class=op>+</span>x) xs</span>
<span id=cb52-10><a href=#cb52-10 aria-hidden=true tabindex=-1></a>                              <span class=kw>else</span> accumSum n xs</span></code></pre></div><p>To test a function you can use <code class=verbatim>ghci</code>:<pre class=example><code>~/t/hsenv&gt; ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude&gt; :l evenSum_v1.hs
[1 of 1] Compiling Main             ( evenSum_v1.hs, interpreted )
Ok, one module loaded.
*Main&gt; evenSum [1..5]
6
</code></pre><p>Here is an example of execution<a href=#fn2 class=footnote-ref id=fnref2 role=doc-noteref><sup>2</sup></a>:<pre class=example><code>*Main&gt; evenSum [1..5]
accumSum 0 [1,2,3,4,5]
1 is odd
accumSum 0 [2,3,4,5]
2 is even
accumSum (0+2) [3,4,5]
3 is odd
accumSum (0+2) [4,5]
2 is even
accumSum (0+2+4) [5]
5 is odd
accumSum (0+2+4) []
l == []
0+2+4
0+6
6
</code></pre><p>Coming from an imperative language all should seem right. In fact,
many things can be improved here. First, we can generalize the type.<div class=sourceCode id=cb55><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb55-1><a href=#cb55-1 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span></code></pre></div><p>Next, we can use sub functions using <code class=verbatim>where</code> or <code class=verbatim>let</code>. This
way our <code class=verbatim>accumSum</code> function will not pollute
the namespace of our module.<div class=sourceCode id=cb56 data-tangle=evenSum_v2.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb56-1><a href=#cb56-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 2</span></span>
<span id=cb56-2><a href=#cb56-2 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb56-3><a href=#cb56-3 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> accumSum <span class=dv>0</span> l</span>
<span id=cb56-4><a href=#cb56-4 aria-hidden=true tabindex=-1></a>    <span class=kw>where</span> accumSum n l <span class=ot>=</span></span>
<span id=cb56-5><a href=#cb56-5 aria-hidden=true tabindex=-1></a>            <span class=kw>if</span> l <span class=op>==</span> []</span>
<span id=cb56-6><a href=#cb56-6 aria-hidden=true tabindex=-1></a>                <span class=kw>then</span> n</span>
<span id=cb56-7><a href=#cb56-7 aria-hidden=true tabindex=-1></a>                <span class=kw>else</span> <span class=kw>let</span> x <span class=ot>=</span> <span class=fu>head</span> l</span>
<span id=cb56-8><a href=#cb56-8 aria-hidden=true tabindex=-1></a>                         xs <span class=ot>=</span> <span class=fu>tail</span> l</span>
<span id=cb56-9><a href=#cb56-9 aria-hidden=true tabindex=-1></a>                     <span class=kw>in</span> <span class=kw>if</span> <span class=fu>even</span> x</span>
<span id=cb56-10><a href=#cb56-10 aria-hidden=true tabindex=-1></a>                            <span class=kw>then</span> accumSum (n<span class=op>+</span>x) xs</span>
<span id=cb56-11><a href=#cb56-11 aria-hidden=true tabindex=-1></a>                            <span class=kw>else</span> accumSum n xs</span></code></pre></div><p>Next, we can use pattern matching.<div class=sourceCode id=cb57 data-tangle=evenSum_v3.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb57-1><a href=#cb57-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 3</span></span>
<span id=cb57-2><a href=#cb57-2 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> accumSum <span class=dv>0</span> l</span>
<span id=cb57-3><a href=#cb57-3 aria-hidden=true tabindex=-1></a>    <span class=kw>where</span></span>
<span id=cb57-4><a href=#cb57-4 aria-hidden=true tabindex=-1></a>        accumSum n [] <span class=ot>=</span> n</span>
<span id=cb57-5><a href=#cb57-5 aria-hidden=true tabindex=-1></a>        accumSum n (x<span class=op>:</span>xs) <span class=ot>=</span></span>
<span id=cb57-6><a href=#cb57-6 aria-hidden=true tabindex=-1></a>             <span class=kw>if</span> <span class=fu>even</span> x</span>
<span id=cb57-7><a href=#cb57-7 aria-hidden=true tabindex=-1></a>                <span class=kw>then</span> accumSum (n<span class=op>+</span>x) xs</span>
<span id=cb57-8><a href=#cb57-8 aria-hidden=true tabindex=-1></a>                <span class=kw>else</span> accumSum n xs</span></code></pre></div><p>What is pattern matching? Use values instead of general parameter
names<a href=#fn3 class=footnote-ref id=fnref3 role=doc-noteref><sup>3</sup></a>.<p>Instead of saying: <code class=verbatim>foo l = if l =</code> []
then &lt;x> else &lt;y>= you simply state:<div class=sourceCode id=cb58><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb58-1><a href=#cb58-1 aria-hidden=true tabindex=-1></a>foo [] <span class=ot>=</span>  <span class=op>&lt;</span>x<span class=op>&gt;</span></span>
<span id=cb58-2><a href=#cb58-2 aria-hidden=true tabindex=-1></a>foo l  <span class=ot>=</span>  <span class=op>&lt;</span>y<span class=op>&gt;</span></span></code></pre></div><p>But pattern matching goes even further. It is also able to inspect
the inner data of a complex value. We can replace<div class=sourceCode id=cb59><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb59-1><a href=#cb59-1 aria-hidden=true tabindex=-1></a>foo l <span class=ot>=</span>  <span class=kw>let</span> x  <span class=ot>=</span> <span class=fu>head</span> l</span>
<span id=cb59-2><a href=#cb59-2 aria-hidden=true tabindex=-1></a>             xs <span class=ot>=</span> <span class=fu>tail</span> l</span>
<span id=cb59-3><a href=#cb59-3 aria-hidden=true tabindex=-1></a>         <span class=kw>in</span> <span class=kw>if</span> <span class=fu>even</span> x</span>
<span id=cb59-4><a href=#cb59-4 aria-hidden=true tabindex=-1></a>             <span class=kw>then</span> foo (n<span class=op>+</span>x) xs</span>
<span id=cb59-5><a href=#cb59-5 aria-hidden=true tabindex=-1></a>             <span class=kw>else</span> foo n xs</span></code></pre></div><p>with<div class=sourceCode id=cb60><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb60-1><a href=#cb60-1 aria-hidden=true tabindex=-1></a>foo (x<span class=op>:</span>xs) <span class=ot>=</span> <span class=kw>if</span> <span class=fu>even</span> x</span>
<span id=cb60-2><a href=#cb60-2 aria-hidden=true tabindex=-1></a>                 <span class=kw>then</span> foo (n<span class=op>+</span>x) xs</span>
<span id=cb60-3><a href=#cb60-3 aria-hidden=true tabindex=-1></a>                 <span class=kw>else</span> foo n xs</span></code></pre></div><p>This is a very useful feature. It makes our code both terser and
easier to read.<p>In Haskell you can simplify function definitions by η-reducing them.
For example, instead of writing:<div class=sourceCode id=cb61><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb61-1><a href=#cb61-1 aria-hidden=true tabindex=-1></a>f x <span class=ot>=</span> (some expresion) x</span></code></pre></div><p>you can simply write<div class=sourceCode id=cb62><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb62-1><a href=#cb62-1 aria-hidden=true tabindex=-1></a>f <span class=ot>=</span> (some expression)</span></code></pre></div><p>We use this method to remove the <code class=verbatim>l</code>:<div class=sourceCode id=cb63 data-tangle=evenSum_v4.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb63-1><a href=#cb63-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 4</span></span>
<span id=cb63-2><a href=#cb63-2 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb63-3><a href=#cb63-3 aria-hidden=true tabindex=-1></a>evenSum <span class=ot>=</span> accumSum <span class=dv>0</span></span>
<span id=cb63-4><a href=#cb63-4 aria-hidden=true tabindex=-1></a>    <span class=kw>where</span></span>
<span id=cb63-5><a href=#cb63-5 aria-hidden=true tabindex=-1></a>        accumSum n [] <span class=ot>=</span> n</span>
<span id=cb63-6><a href=#cb63-6 aria-hidden=true tabindex=-1></a>        accumSum n (x<span class=op>:</span>xs) <span class=ot>=</span></span>
<span id=cb63-7><a href=#cb63-7 aria-hidden=true tabindex=-1></a>             <span class=kw>if</span> <span class=fu>even</span> x</span>
<span id=cb63-8><a href=#cb63-8 aria-hidden=true tabindex=-1></a>                <span class=kw>then</span> accumSum (n<span class=op>+</span>x) xs</span>
<span id=cb63-9><a href=#cb63-9 aria-hidden=true tabindex=-1></a>                <span class=kw>else</span> accumSum n xs</span></code></pre></div><h3 id=higher-order-functions>Higher Order Functions</h3><figure><img src=./escher_polygon.png.webp alt=Escher><figcaption aria-hidden=true>Escher</figcaption></figure><p>To make things even better we should use higher order functions. What
are these beasts? Higher order functions are functions taking functions
as parameters.<p>Here are some examples:<div class=sourceCode id=cb64><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb64-1><a href=#cb64-1 aria-hidden=true tabindex=-1></a><span class=fu>filter</span><span class=ot> ::</span> (a <span class=ot>-&gt;</span> <span class=dt>Bool</span>) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [a]</span>
<span id=cb64-2><a href=#cb64-2 aria-hidden=true tabindex=-1></a><span class=fu>map</span><span class=ot> ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> [a] <span class=ot>-&gt;</span> [b]</span>
<span id=cb64-3><a href=#cb64-3 aria-hidden=true tabindex=-1></a><span class=fu>foldl</span><span class=ot> ::</span> (a <span class=ot>-&gt;</span> b <span class=ot>-&gt;</span> a) <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> [b] <span class=ot>-&gt;</span> a</span></code></pre></div><p>Let's proceed by small steps.<div class=sourceCode id=cb65 data-tangle=evenSum_v5.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb65-1><a href=#cb65-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 5</span></span>
<span id=cb65-2><a href=#cb65-2 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> mysum <span class=dv>0</span> (<span class=fu>filter</span> <span class=fu>even</span> l)</span>
<span id=cb65-3><a href=#cb65-3 aria-hidden=true tabindex=-1></a>    <span class=kw>where</span></span>
<span id=cb65-4><a href=#cb65-4 aria-hidden=true tabindex=-1></a>      mysum n [] <span class=ot>=</span> n</span>
<span id=cb65-5><a href=#cb65-5 aria-hidden=true tabindex=-1></a>      mysum n (x<span class=op>:</span>xs) <span class=ot>=</span> mysum (n<span class=op>+</span>x) xs</span></code></pre></div><p>where<div class=sourceCode id=cb66><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb66-1><a href=#cb66-1 aria-hidden=true tabindex=-1></a><span class=fu>filter</span> <span class=fu>even</span> [<span class=dv>1</span><span class=op>..</span><span class=dv>10</span>] ⇔  [<span class=dv>2</span>,<span class=dv>4</span>,<span class=dv>6</span>,<span class=dv>8</span>,<span class=dv>10</span>]</span></code></pre></div><p>The function <code class=verbatim>filter</code> takes a function of
type (<code class=verbatim>a -> Bool</code>) and a list of type
<code class=verbatim>[a]</code>. It returns a list containing only
elements for which the function returned <code class=verbatim>True</code>.<p>Our next step is to use another technique to accomplish the same
thing as a loop. We will use the <code class=verbatim>foldl</code>
function to accumulate a value as we pass through the list. The function
<code class=verbatim>foldl</code> captures a general coding
pattern:<div class=sourceCode id=cb67><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb67-1><a href=#cb67-1 aria-hidden=true tabindex=-1></a>myfunc list <span class=ot>=</span> foo initialValue list</span>
<span id=cb67-2><a href=#cb67-2 aria-hidden=true tabindex=-1></a>foo accumulated []     <span class=ot>=</span> accumulated</span>
<span id=cb67-3><a href=#cb67-3 aria-hidden=true tabindex=-1></a>foo tmpValue    (x<span class=op>:</span>xs) <span class=ot>=</span> foo (bar tmpValue x) xs</span></code></pre></div><p>Which can be replaced by:<div class=sourceCode id=cb68><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb68-1><a href=#cb68-1 aria-hidden=true tabindex=-1></a>myfunc list <span class=ot>=</span> <span class=fu>foldl</span> bar initialValue list</span></code></pre></div><p>If you really want to know how the magic works, here is the
definition of <code class=verbatim>foldl</code>:<div class=sourceCode id=cb69><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb69-1><a href=#cb69-1 aria-hidden=true tabindex=-1></a><span class=fu>foldl</span> f z [] <span class=ot>=</span> z</span>
<span id=cb69-2><a href=#cb69-2 aria-hidden=true tabindex=-1></a><span class=fu>foldl</span> f z (x<span class=op>:</span>xs) <span class=ot>=</span> <span class=fu>foldl</span> f (f z x) xs</span></code></pre></div><div class=sourceCode id=cb70><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb70-1><a href=#cb70-1 aria-hidden=true tabindex=-1></a><span class=fu>foldl</span> f z [x1,<span class=op>...</span>xn]</span>
<span id=cb70-2><a href=#cb70-2 aria-hidden=true tabindex=-1></a>⇔  f (<span class=op>...</span> (f (f z x1) x2) <span class=op>...</span>) xn</span></code></pre></div><p>But as Haskell is lazy, it doesn't evaluate <code class=verbatim>(f z x)</code> and simply pushes it onto the stack.
This is why we generally use <code class=verbatim>foldl'</code>
instead of <code class=verbatim>foldl</code>; <code class=verbatim>foldl'</code> is a <em>strict</em> version of <code class=verbatim>foldl</code>. If you don't understand what lazy and
strict means, don't worry, just follow the code as if <code class=verbatim>foldl</code> and <code class=verbatim>foldl'</code>
were identical.<p>Now our new version of <code class=verbatim>evenSum</code>
becomes:<div class=sourceCode id=cb71 data-tangle=evenSum_v6.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb71-1><a href=#cb71-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 6</span></span>
<span id=cb71-2><a href=#cb71-2 aria-hidden=true tabindex=-1></a><span class=co>-- foldl&#39; isn&#39;t accessible by default</span></span>
<span id=cb71-3><a href=#cb71-3 aria-hidden=true tabindex=-1></a><span class=co>-- we need to import it from the module Data.List</span></span>
<span id=cb71-4><a href=#cb71-4 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.List</span></span>
<span id=cb71-5><a href=#cb71-5 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> foldl&#39; mysum <span class=dv>0</span> (<span class=fu>filter</span> <span class=fu>even</span> l)</span>
<span id=cb71-6><a href=#cb71-6 aria-hidden=true tabindex=-1></a>  <span class=kw>where</span> mysum acc value <span class=ot>=</span> acc <span class=op>+</span> value</span></code></pre></div><p>We can also simplify this by using directly a lambda notation. This
way we don't have to create the temporary name <code class=verbatim>mysum</code>.<div class=sourceCode id=cb72 data-tangle=evenSum_v7.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb72-1><a href=#cb72-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 7</span></span>
<span id=cb72-2><a href=#cb72-2 aria-hidden=true tabindex=-1></a><span class=co>-- Generally it is considered a good practice</span></span>
<span id=cb72-3><a href=#cb72-3 aria-hidden=true tabindex=-1></a><span class=co>-- to import only the necessary function(s)</span></span>
<span id=cb72-4><a href=#cb72-4 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.List</span> (foldl&#39;)</span>
<span id=cb72-5><a href=#cb72-5 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> foldl&#39; (\x y <span class=ot>-&gt;</span> x<span class=op>+</span>y) <span class=dv>0</span> (<span class=fu>filter</span> <span class=fu>even</span> l)</span></code></pre></div><p>And of course, we note that<div class=sourceCode id=cb73><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb73-1><a href=#cb73-1 aria-hidden=true tabindex=-1></a>(\x y <span class=ot>-&gt;</span> x<span class=op>+</span>y) ⇔ (<span class=op>+</span>)</span></code></pre></div><p>Finally<div class=sourceCode id=cb74 data-tangle=evenSum_v8.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb74-1><a href=#cb74-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 8</span></span>
<span id=cb74-2><a href=#cb74-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.List</span> (foldl&#39;)</span>
<span id=cb74-3><a href=#cb74-3 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb74-4><a href=#cb74-4 aria-hidden=true tabindex=-1></a>evenSum l <span class=ot>=</span> foldl&#39; (<span class=op>+</span>) <span class=dv>0</span> (<span class=fu>filter</span> <span class=fu>even</span> l)</span></code></pre></div><p><code class=verbatim>foldl'</code> isn't the easiest function to
grasp. If you are not used to it, you should study it a bit.<p>To help you understand what's going on here, let's look at a step by
step evaluation:<div class=sourceCode id=cb75><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb75-1><a href=#cb75-1 aria-hidden=true tabindex=-1></a>  evenSum [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>]</span>
<span id=cb75-2><a href=#cb75-2 aria-hidden=true tabindex=-1></a>⇒ foldl&#39; (<span class=op>+</span>) <span class=dv>0</span> (<span class=fu>filter</span> <span class=fu>even</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>])</span>
<span id=cb75-3><a href=#cb75-3 aria-hidden=true tabindex=-1></a>⇒ foldl&#39; (<span class=op>+</span>) <span class=dv>0</span> [<span class=dv>2</span>,<span class=dv>4</span>]</span>
<span id=cb75-4><a href=#cb75-4 aria-hidden=true tabindex=-1></a>⇒ foldl&#39; (<span class=op>+</span>) (<span class=dv>0</span><span class=op>+</span><span class=dv>2</span>) [<span class=dv>4</span>]</span>
<span id=cb75-5><a href=#cb75-5 aria-hidden=true tabindex=-1></a>⇒ foldl&#39; (<span class=op>+</span>) <span class=dv>2</span> [<span class=dv>4</span>]</span>
<span id=cb75-6><a href=#cb75-6 aria-hidden=true tabindex=-1></a>⇒ foldl&#39; (<span class=op>+</span>) (<span class=dv>2</span><span class=op>+</span><span class=dv>4</span>) []</span>
<span id=cb75-7><a href=#cb75-7 aria-hidden=true tabindex=-1></a>⇒ foldl&#39; (<span class=op>+</span>) <span class=dv>6</span> []</span>
<span id=cb75-8><a href=#cb75-8 aria-hidden=true tabindex=-1></a>⇒ <span class=dv>6</span></span></code></pre></div><p>Another useful higher order function is <code class=verbatim>(.)</code>. The <code class=verbatim>(.)</code>
function corresponds to mathematical composition.<div class=sourceCode id=cb76><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb76-1><a href=#cb76-1 aria-hidden=true tabindex=-1></a>(f <span class=op>.</span> g <span class=op>.</span> h) x ⇔  f ( g (h x))</span></code></pre></div><p>We can take advantage of this operator to η-reduce our function:<div class=sourceCode id=cb77 data-tangle=evenSum_v9.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb77-1><a href=#cb77-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 9</span></span>
<span id=cb77-2><a href=#cb77-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.List</span> (foldl&#39;)</span>
<span id=cb77-3><a href=#cb77-3 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb77-4><a href=#cb77-4 aria-hidden=true tabindex=-1></a>evenSum <span class=ot>=</span> (foldl&#39; (<span class=op>+</span>) <span class=dv>0</span>) <span class=op>.</span> (<span class=fu>filter</span> <span class=fu>even</span>)</span></code></pre></div><p>Also, we could rename some parts to make it clearer:<div class=sourceCode id=cb78 data-tangle=evenSum_v10.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb78-1><a href=#cb78-1 aria-hidden=true tabindex=-1></a><span class=co>-- Version 10</span></span>
<span id=cb78-2><a href=#cb78-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.List</span> (foldl&#39;)</span>
<span id=cb78-3><a href=#cb78-3 aria-hidden=true tabindex=-1></a><span class=ot>sum&#39; ::</span> (<span class=dt>Num</span> a) <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb78-4><a href=#cb78-4 aria-hidden=true tabindex=-1></a>sum&#39; <span class=ot>=</span> foldl&#39; (<span class=op>+</span>) <span class=dv>0</span></span>
<span id=cb78-5><a href=#cb78-5 aria-hidden=true tabindex=-1></a><span class=ot>evenSum ::</span> <span class=dt>Integral</span> a <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> a</span>
<span id=cb78-6><a href=#cb78-6 aria-hidden=true tabindex=-1></a>evenSum <span class=ot>=</span> sum&#39; <span class=op>.</span> (<span class=fu>filter</span> <span class=fu>even</span>)</span></code></pre></div><p>It is time to discuss the direction our code has moved as we
introduced more functional idioms. What did we gain by using higher
order functions?<p>At first, you might think the main difference is terseness. But in
fact, it has more to do with better thinking. Suppose we want to modify
our function slightly, for example, to get the sum of all even squares
of elements of the list.<pre class=example><code>[1,2,3,4] ▷ [1,4,9,16] ▷ [4,16] ▷ 20
</code></pre><p>Updating version 10 is extremely easy:<div class=sourceCode id=cb80><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb80-1><a href=#cb80-1 aria-hidden=true tabindex=-1></a>squareEvenSum <span class=ot>=</span> sum&#39; <span class=op>.</span> (<span class=fu>filter</span> <span class=fu>even</span>) <span class=op>.</span> (<span class=fu>map</span> (<span class=op>^</span><span class=dv>2</span>))</span>
<span id=cb80-2><a href=#cb80-2 aria-hidden=true tabindex=-1></a>squareEvenSum&#39; <span class=ot>=</span> evenSum <span class=op>.</span> (<span class=fu>map</span> (<span class=op>^</span><span class=dv>2</span>))</span></code></pre></div><p>We just had to add another "transformation function".<pre class=example><code>map (^2) [1,2,3,4] ⇔ [1,4,9,16]
</code></pre><p>The <code class=verbatim>map</code> function simply applies a
function to all the elements of a list.<p>We didn't have to modify anything <em>inside</em> the function
definition. This makes the code more modular. But in addition you can
think more mathematically about your functions. You can also use your
functions interchangeably with others, as needed. That is, you can
<em>compose</em>, map, fold, filter using your new function.<p>Modifying version 1 is left as an exercise to the reader ☺.<p>If you believe we have reached the end of generalization, then know
you are very wrong. For example, there is a way to not only use this
function on lists but on any recursive type. If you want to know how, I
suggest you to read this quite fun article: <a href=http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf>Functional
Programming with Bananas, Lenses, Envelopes and Barbed Wire by Meijer,
Fokkinga and Paterson</a>.<p>This example should show you how great pure functional programming
is. Unfortunately, using pure functional programming isn't well suited
to all usages. Or at least such a language hasn't been found yet.<p>One of the great powers of Haskell is the ability to create DSL
(Domain Specific Language) making it easy to change the programming
paradigm.<p>In fact, Haskell is also great when you want to write imperative
style programming. Understanding this was really hard for me to grasp
when first learning Haskell. A lot of effort tends to go into explaining
the superiority of the functional approach. Then when you start using an
imperative style with Haskell, it can be hard to understand when and how
to use it.<p>But before talking about this Haskell super-power, we must talk about
another essential aspect of Haskell: <em>Types</em>.<h2 id=types>Types</h2><figure><img src=./salvador-dali-the-madonna-of-port-lligat.jpg.webp alt="Dali, the madonna of port Lligat"><figcaption aria-hidden=true>Dali, the madonna of port
Lligat</figcaption></figure><blockquote><p><abbr title="too long; didn't read">tl;dr:</abbr><ul><li><code class=verbatim>type Name = AnotherType</code> is just an
alias and the compiler doesn't mark any difference between <code class=verbatim>Name</code> and <code class=verbatim>AnotherType</code>.<li><code class=verbatim>data Name = NameConstructor AnotherType</code> does
mark a difference.<li><code class=verbatim>data</code> can construct structures which
can be recursives.<li><code class=verbatim>deriving</code> is magic and creates
functions for you.</ul></blockquote><p>In Haskell, types are strong and static.<p>Why is this important? It will help you <em>greatly</em> to avoid
mistakes. In Haskell, most bugs are caught during the compilation of
your program. And the main reason is because of the type checking during
compilation. Type checking makes it easy to detect where you used the
wrong parameter at the wrong place, for example.<h3 id=type-inference>Type inference</h3><p>Static typing is generally essential for fast execution. But most
statically typed languages are bad at generalizing concepts. Haskell's
saving grace is that it can <em>infer</em> types.<p>Here is a simple example, the <code class=verbatim>square</code>
function in Haskell:<div class=sourceCode id=cb82><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb82-1><a href=#cb82-1 aria-hidden=true tabindex=-1></a>square x <span class=ot>=</span> x <span class=op>*</span> x</span></code></pre></div><p>This function can <code class=verbatim>square</code> any Numeral
type. You can provide <code class=verbatim>square</code> with an <code class=verbatim>Int</code>, an <code class=verbatim>Integer</code>, a
<code class=verbatim>Float</code> a <code class=verbatim>Fractional</code> and even <code class=verbatim>Complex</code>. Proof by example:<pre class=example><code>~/t/hsenv&gt; ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude&gt; let square x = x * x
Prelude&gt; square 2
4
Prelude&gt; square 2.1
4.41
Prelude&gt; :m Data.Complex
Prelude Data.Complex&gt; square (2 :+ 1)
3.0 :+ 4.0
</code></pre><p><code class=verbatim>x :+ y</code> is the notation for the complex
(x + iy).<p>Now compare with the amount of code necessary in C:<div class=sourceCode id=cb84 data-org-language=C><pre class="sourceCode c"><code class="sourceCode c"><span id=cb84-1><a href=#cb84-1 aria-hidden=true tabindex=-1></a><span class=dt>int</span>     int_square<span class=op>(</span><span class=dt>int</span> x<span class=op>)</span> <span class=op>{</span> <span class=cf>return</span> x<span class=op>*</span>x<span class=op>;</span> <span class=op>}</span></span>
<span id=cb84-2><a href=#cb84-2 aria-hidden=true tabindex=-1></a><span class=dt>float</span>   float_square<span class=op>(</span><span class=dt>float</span> x<span class=op>)</span> <span class=op>{</span><span class=cf>return</span> x<span class=op>*</span>x<span class=op>;</span> <span class=op>}</span></span>
<span id=cb84-3><a href=#cb84-3 aria-hidden=true tabindex=-1></a><span class=dt>complex</span> complex_square <span class=op>(</span><span class=dt>complex</span> z<span class=op>)</span> <span class=op>{</span></span>
<span id=cb84-4><a href=#cb84-4 aria-hidden=true tabindex=-1></a>    <span class=dt>complex</span> tmp<span class=op>;</span></span>
<span id=cb84-5><a href=#cb84-5 aria-hidden=true tabindex=-1></a>    tmp<span class=op>.</span>real <span class=op>=</span> z<span class=op>.</span>real <span class=op>*</span> z<span class=op>.</span>real <span class=op>-</span> z<span class=op>.</span>img <span class=op>*</span> z<span class=op>.</span>img<span class=op>;</span></span>
<span id=cb84-6><a href=#cb84-6 aria-hidden=true tabindex=-1></a>    tmp<span class=op>.</span>img <span class=op>=</span> <span class=dv>2</span> <span class=op>*</span> z<span class=op>.</span>img <span class=op>*</span> z<span class=op>.</span>real<span class=op>;</span></span>
<span id=cb84-7><a href=#cb84-7 aria-hidden=true tabindex=-1></a><span class=op>}</span></span>
<span id=cb84-8><a href=#cb84-8 aria-hidden=true tabindex=-1></a><span class=dt>complex</span> x<span class=op>,</span>y<span class=op>;</span></span>
<span id=cb84-9><a href=#cb84-9 aria-hidden=true tabindex=-1></a>y <span class=op>=</span> complex_square<span class=op>(</span>x<span class=op>);</span></span></code></pre></div><p>For each type, you need to write a new function. The only way to work
around this problem is to use some meta-programming trick, for example
using the pre-processor. In C++ there is a better way, C++
templates:<div class=sourceCode id=cb85><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb85-1><a href=#cb85-1 aria-hidden=true tabindex=-1></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb85-2><a href=#cb85-2 aria-hidden=true tabindex=-1></a><span class=pp>#include </span><span class=im>&lt;complex&gt;</span></span>
<span id=cb85-3><a href=#cb85-3 aria-hidden=true tabindex=-1></a><span class=kw>using</span> <span class=kw>namespace</span> std<span class=op>;</span></span>
<span id=cb85-4><a href=#cb85-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb85-5><a href=#cb85-5 aria-hidden=true tabindex=-1></a><span class=kw>template</span><span class=op>&lt;</span><span class=kw>typename</span> T<span class=op>&gt;</span></span>
<span id=cb85-6><a href=#cb85-6 aria-hidden=true tabindex=-1></a>T square<span class=op>(</span>T x<span class=op>)</span></span>
<span id=cb85-7><a href=#cb85-7 aria-hidden=true tabindex=-1></a><span class=op>{</span></span>
<span id=cb85-8><a href=#cb85-8 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> x<span class=op>*</span>x<span class=op>;</span></span>
<span id=cb85-9><a href=#cb85-9 aria-hidden=true tabindex=-1></a><span class=op>}</span></span>
<span id=cb85-10><a href=#cb85-10 aria-hidden=true tabindex=-1></a></span>
<span id=cb85-11><a href=#cb85-11 aria-hidden=true tabindex=-1></a><span class=dt>int</span> main<span class=op>()</span> <span class=op>{</span></span>
<span id=cb85-12><a href=#cb85-12 aria-hidden=true tabindex=-1></a>    <span class=co>// int</span></span>
<span id=cb85-13><a href=#cb85-13 aria-hidden=true tabindex=-1></a>    <span class=dt>int</span> sqr_of_five <span class=op>=</span> square<span class=op>(</span><span class=dv>5</span><span class=op>);</span></span>
<span id=cb85-14><a href=#cb85-14 aria-hidden=true tabindex=-1></a>    cout <span class=op>&lt;&lt;</span> sqr_of_five <span class=op>&lt;&lt;</span> endl<span class=op>;</span></span>
<span id=cb85-15><a href=#cb85-15 aria-hidden=true tabindex=-1></a>    <span class=co>// double</span></span>
<span id=cb85-16><a href=#cb85-16 aria-hidden=true tabindex=-1></a>    cout <span class=op>&lt;&lt;</span> <span class=op>(</span><span class=dt>double</span><span class=op>)</span>square<span class=op>(</span><span class=fl>5.3</span><span class=op>)</span> <span class=op>&lt;&lt;</span> endl<span class=op>;</span></span>
<span id=cb85-17><a href=#cb85-17 aria-hidden=true tabindex=-1></a>    <span class=co>// complex</span></span>
<span id=cb85-18><a href=#cb85-18 aria-hidden=true tabindex=-1></a>    cout <span class=op>&lt;&lt;</span> square<span class=op>(</span> complex<span class=op>&lt;</span><span class=dt>double</span><span class=op>&gt;(</span><span class=dv>5</span><span class=op>,</span><span class=dv>3</span><span class=op>)</span> <span class=op>)</span></span>
<span id=cb85-19><a href=#cb85-19 aria-hidden=true tabindex=-1></a>         <span class=op>&lt;&lt;</span> endl<span class=op>;</span></span>
<span id=cb85-20><a href=#cb85-20 aria-hidden=true tabindex=-1></a>    <span class=cf>return</span> <span class=dv>0</span><span class=op>;</span></span>
<span id=cb85-21><a href=#cb85-21 aria-hidden=true tabindex=-1></a><span class=op>}</span></span></code></pre></div><p>C++ does a far better job than C in this regard. But for more complex
functions the syntax can be hard to follow: see <a href=http://bartoszmilewski.com/2009/10/21/what-does-haskell-have-to-do-with-c/>this
article</a> for example.<p>In C++ you must declare that a function can work with different
types. In Haskell, the opposite is the case. The function will be as
general as possible by default.<p>Type inference gives Haskell the feeling of freedom that dynamically
typed languages provide. But unlike dynamically typed languages, most
errors are caught before run time. Generally, in Haskell:<blockquote><p>"if it compiles it certainly does what you intended"</blockquote><h3 id=type-construction>Type construction</h3><p>You can construct your own types. First, you can use aliases or type
synonyms.<div class=sourceCode id=cb86 data-tangle=type_constr_1.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb86-1><a href=#cb86-1 aria-hidden=true tabindex=-1></a><span class=kw>type</span> <span class=dt>Name</span>   <span class=ot>=</span> <span class=dt>String</span></span>
<span id=cb86-2><a href=#cb86-2 aria-hidden=true tabindex=-1></a><span class=kw>type</span> <span class=dt>Color</span>  <span class=ot>=</span> <span class=dt>String</span></span>
<span id=cb86-3><a href=#cb86-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb86-4><a href=#cb86-4 aria-hidden=true tabindex=-1></a><span class=ot>showInfos ::</span> <span class=dt>Name</span> <span class=ot>-&gt;</span>  <span class=dt>Color</span> <span class=ot>-&gt;</span> <span class=dt>String</span></span>
<span id=cb86-5><a href=#cb86-5 aria-hidden=true tabindex=-1></a>showInfos name color <span class=ot>=</span>  <span class=st>&quot;Name: &quot;</span> <span class=op>++</span> name</span>
<span id=cb86-6><a href=#cb86-6 aria-hidden=true tabindex=-1></a>                        <span class=op>++</span> <span class=st>&quot;, Color: &quot;</span> <span class=op>++</span> color</span>
<span id=cb86-7><a href=#cb86-7 aria-hidden=true tabindex=-1></a><span class=ot>name ::</span> <span class=dt>Name</span></span>
<span id=cb86-8><a href=#cb86-8 aria-hidden=true tabindex=-1></a>name <span class=ot>=</span> <span class=st>&quot;Robin&quot;</span></span>
<span id=cb86-9><a href=#cb86-9 aria-hidden=true tabindex=-1></a><span class=ot>color ::</span> <span class=dt>Color</span></span>
<span id=cb86-10><a href=#cb86-10 aria-hidden=true tabindex=-1></a>color <span class=ot>=</span> <span class=st>&quot;Blue&quot;</span></span>
<span id=cb86-11><a href=#cb86-11 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=op>$</span> showInfos name color</span></code></pre></div><p>But it doesn't protect you much. Try to swap the two parameter of
<code class=verbatim>showInfos</code> and run the program:<div class=sourceCode id=cb87><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb87-1><a href=#cb87-1 aria-hidden=true tabindex=-1></a><span class=fu>putStrLn</span> <span class=op>$</span> showInfos color name</span></code></pre></div><p>It will compile and execute. In fact you can replace Name, Color and
String everywhere. The compiler will treat them as completely
identical.<p>Another method is to create your own types using the keyword <code class=verbatim>data</code>.<div class=sourceCode id=cb88><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb88-1><a href=#cb88-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>Name</span>   <span class=ot>=</span> <span class=dt>NameConstr</span> <span class=dt>String</span></span>
<span id=cb88-2><a href=#cb88-2 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>Color</span>  <span class=ot>=</span> <span class=dt>ColorConstr</span> <span class=dt>String</span></span>
<span id=cb88-3><a href=#cb88-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb88-4><a href=#cb88-4 aria-hidden=true tabindex=-1></a><span class=ot>showInfos ::</span> <span class=dt>Name</span> <span class=ot>-&gt;</span>  <span class=dt>Color</span> <span class=ot>-&gt;</span> <span class=dt>String</span></span>
<span id=cb88-5><a href=#cb88-5 aria-hidden=true tabindex=-1></a>showInfos (<span class=dt>NameConstr</span> name) (<span class=dt>ColorConstr</span> color) <span class=ot>=</span></span>
<span id=cb88-6><a href=#cb88-6 aria-hidden=true tabindex=-1></a>      <span class=st>&quot;Name: &quot;</span> <span class=op>++</span> name <span class=op>++</span> <span class=st>&quot;, Color: &quot;</span> <span class=op>++</span> color</span>
<span id=cb88-7><a href=#cb88-7 aria-hidden=true tabindex=-1></a></span>
<span id=cb88-8><a href=#cb88-8 aria-hidden=true tabindex=-1></a>name  <span class=ot>=</span> <span class=dt>NameConstr</span> <span class=st>&quot;Robin&quot;</span></span>
<span id=cb88-9><a href=#cb88-9 aria-hidden=true tabindex=-1></a>color <span class=ot>=</span> <span class=dt>ColorConstr</span> <span class=st>&quot;Blue&quot;</span></span>
<span id=cb88-10><a href=#cb88-10 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=op>$</span> showInfos name color</span></code></pre></div><p>Now if you switch parameters of <code class=verbatim>showInfos</code>, the compiler complains! So this is a
potential mistake you will never make again and the only price is to be
a bit more verbose.<p>Also notice that constructors are functions:<div class=sourceCode id=cb89><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb89-1><a href=#cb89-1 aria-hidden=true tabindex=-1></a><span class=dt>NameConstr</span><span class=ot>  ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Name</span></span>
<span id=cb89-2><a href=#cb89-2 aria-hidden=true tabindex=-1></a><span class=dt>ColorConstr</span><span class=ot> ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Color</span></span></code></pre></div><p>The syntax of <code class=verbatim>data</code> is mainly:<div class=sourceCode id=cb90><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb90-1><a href=#cb90-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>TypeName</span> <span class=ot>=</span>   <span class=dt>ConstructorName</span>  [types]</span>
<span id=cb90-2><a href=#cb90-2 aria-hidden=true tabindex=-1></a>                <span class=op>|</span> <span class=dt>ConstructorName2</span> [types]</span>
<span id=cb90-3><a href=#cb90-3 aria-hidden=true tabindex=-1></a>                <span class=op>|</span> <span class=op>...</span></span></code></pre></div><p>Generally the usage is to use the same name for the DataTypeName and
DataTypeConstructor.<p>Example:<div class=sourceCode id=cb91><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb91-1><a href=#cb91-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>Complex</span> a <span class=ot>=</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>Complex</span> a a</span></code></pre></div><p>Also you can use the record syntax:<div class=sourceCode id=cb92><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb92-1><a href=#cb92-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>DataTypeName</span> <span class=ot>=</span> <span class=dt>DataConstructor</span> {</span>
<span id=cb92-2><a href=#cb92-2 aria-hidden=true tabindex=-1></a><span class=ot>                      field1 ::</span> [<span class=kw>type</span> <span class=kw>of</span> field1]</span>
<span id=cb92-3><a href=#cb92-3 aria-hidden=true tabindex=-1></a>                    ,<span class=ot> field2 ::</span> [<span class=kw>type</span> <span class=kw>of</span> field2]</span>
<span id=cb92-4><a href=#cb92-4 aria-hidden=true tabindex=-1></a>                    <span class=op>...</span></span>
<span id=cb92-5><a href=#cb92-5 aria-hidden=true tabindex=-1></a>                    ,<span class=ot> fieldn ::</span> [<span class=kw>type</span> <span class=kw>of</span> fieldn] }</span></code></pre></div><p>And many accessors are made for you. Furthermore you can use another
order when setting values.<p>Example:<div class=sourceCode id=cb93><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb93-1><a href=#cb93-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>Complex</span> a <span class=ot>=</span> <span class=dt>Num</span> a <span class=ot>=&gt;</span> <span class=dt>Complex</span> {<span class=ot> real ::</span> a,<span class=ot> img ::</span> a}</span>
<span id=cb93-2><a href=#cb93-2 aria-hidden=true tabindex=-1></a>c <span class=ot>=</span> <span class=dt>Complex</span> <span class=fl>1.0</span> <span class=fl>2.0</span></span>
<span id=cb93-3><a href=#cb93-3 aria-hidden=true tabindex=-1></a>z <span class=ot>=</span> <span class=dt>Complex</span> { real <span class=ot>=</span> <span class=dv>3</span>, img <span class=ot>=</span> <span class=dv>4</span> }</span>
<span id=cb93-4><a href=#cb93-4 aria-hidden=true tabindex=-1></a>real c ⇒ <span class=fl>1.0</span></span>
<span id=cb93-5><a href=#cb93-5 aria-hidden=true tabindex=-1></a>img z ⇒ <span class=dv>4</span></span></code></pre></div><h3 id=recursive-type>Recursive type</h3><p>You already encountered a recursive type: lists. You can re-create
lists, but with a more verbose syntax:<div class=sourceCode id=cb94><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb94-1><a href=#cb94-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>List</span> a <span class=ot>=</span> <span class=dt>Empty</span> <span class=op>|</span> <span class=dt>Cons</span> a (<span class=dt>List</span> a)</span></code></pre></div><p>If you really want to use an easier syntax you can use an infix name
for constructors.<div class=sourceCode id=cb95><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb95-1><a href=#cb95-1 aria-hidden=true tabindex=-1></a><span class=kw>infixr</span> <span class=dv>5</span> <span class=op>:::</span></span>
<span id=cb95-2><a href=#cb95-2 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>List</span> a <span class=ot>=</span> <span class=dt>Nil</span> <span class=op>|</span> a <span class=op>:::</span> (<span class=dt>List</span> a)</span></code></pre></div><p>The number after <code class=verbatim>infixr</code> gives the
precedence.<p>If you want to be able to print (<code class=verbatim>Show</code>),
read (<code class=verbatim>Read</code>), test equality (<code class=verbatim>Eq</code>) and compare (<code class=verbatim>Ord</code>) your new data structure you can tell
Haskell to derive the appropriate functions for you.<div class=sourceCode id=cb96 data-tangle=list.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb96-1><a href=#cb96-1 aria-hidden=true tabindex=-1></a><span class=kw>infixr</span> <span class=dv>5</span> <span class=op>:::</span></span>
<span id=cb96-2><a href=#cb96-2 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>List</span> a <span class=ot>=</span> <span class=dt>Nil</span> <span class=op>|</span> a <span class=op>:::</span> (<span class=dt>List</span> a)</span>
<span id=cb96-3><a href=#cb96-3 aria-hidden=true tabindex=-1></a>              <span class=kw>deriving</span> (<span class=dt>Show</span>,<span class=dt>Read</span>,<span class=dt>Eq</span>,<span class=dt>Ord</span>)</span></code></pre></div><p>When you add <code class=verbatim>deriving (Show)</code> to your
data declaration, Haskell creates a <code class=verbatim>show</code>
function for you. We'll see soon how you can use your own <code class=verbatim>show</code> function.<div class=sourceCode id=cb97 data-tangle=list.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb97-1><a href=#cb97-1 aria-hidden=true tabindex=-1></a>convertList [] <span class=ot>=</span> <span class=dt>Nil</span></span>
<span id=cb97-2><a href=#cb97-2 aria-hidden=true tabindex=-1></a>convertList (x<span class=op>:</span>xs) <span class=ot>=</span> x <span class=op>:::</span> convertList xs</span></code></pre></div><div class=sourceCode id=cb98 data-tangle=list.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb98-1><a href=#cb98-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb98-2><a href=#cb98-2 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> (<span class=dv>0</span> <span class=op>:::</span> <span class=dv>1</span> <span class=op>:::</span> <span class=dt>Nil</span>)</span>
<span id=cb98-3><a href=#cb98-3 aria-hidden=true tabindex=-1></a>      <span class=fu>print</span> (convertList [<span class=dv>0</span>,<span class=dv>1</span>])</span></code></pre></div><p>This prints:<pre class=example><code>0 ::: (1 ::: Nil)
0 ::: (1 ::: Nil)
</code></pre><h3 id=trees>Trees</h3><figure><img src=./magritte-l-arbre.jpg.webp alt="Magritte, l'Arbre"><figcaption aria-hidden=true>Magritte, l'Arbre</figcaption></figure><p>We'll just give another standard example: binary trees.<div class=sourceCode id=cb100 data-tangle=tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb100-1><a href=#cb100-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>BinTree</span> a <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb100-2><a href=#cb100-2 aria-hidden=true tabindex=-1></a>                 <span class=op>|</span> <span class=dt>Node</span> a (<span class=dt>BinTree</span> a) (<span class=dt>BinTree</span> a)</span>
<span id=cb100-3><a href=#cb100-3 aria-hidden=true tabindex=-1></a>                              <span class=kw>deriving</span> (<span class=dt>Show</span>)</span></code></pre></div><p>We will also create a function which turns a list into an ordered
binary tree.<div class=sourceCode id=cb101 data-tangle=tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb101-1><a href=#cb101-1 aria-hidden=true tabindex=-1></a><span class=ot>treeFromList ::</span> (<span class=dt>Ord</span> a) <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> <span class=dt>BinTree</span> a</span>
<span id=cb101-2><a href=#cb101-2 aria-hidden=true tabindex=-1></a>treeFromList [] <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb101-3><a href=#cb101-3 aria-hidden=true tabindex=-1></a>treeFromList (x<span class=op>:</span>xs) <span class=ot>=</span> <span class=dt>Node</span> x (treeFromList (<span class=fu>filter</span> (<span class=op>&lt;</span>x) xs))</span>
<span id=cb101-4><a href=#cb101-4 aria-hidden=true tabindex=-1></a>                             (treeFromList (<span class=fu>filter</span> (<span class=op>&gt;</span>x) xs))</span></code></pre></div><p>Look at how elegant this function is. In plain English:<ul><li><p>an empty list will be converted to an empty tree.<li><p>a list <code class=verbatim>(x:xs)</code> will be converted to
a tree where:<ul><li>The root is <code class=verbatim>x</code><li>Its left subtree is the tree created from members of the list <code class=verbatim>xs</code> which are strictly inferior to <code class=verbatim>x</code> and<li>the right subtree is the tree created from members of the list <code class=verbatim>xs</code> which are strictly superior to <code class=verbatim>x</code>.</ul></ul><div class=sourceCode id=cb102 data-tangle=tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb102-1><a href=#cb102-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> <span class=op>$</span> treeFromList [<span class=dv>7</span>,<span class=dv>2</span>,<span class=dv>4</span>,<span class=dv>8</span>]</span></code></pre></div><p>You should obtain the following:<pre class=example><code>Node 7 (Node 2 Empty (Node 4 Empty Empty)) (Node 8 Empty Empty)
</code></pre><p>This is an informative but quite unpleasant representation of our
tree.<p>I've added the <code class=verbatim>containers</code> package in
the <code class=verbatim>shell.nix</code> file, it is time to use this
library which contain functions to show trees and list of trees (forest)
named <code class=verbatim>drawTree</code> and <code class=verbatim>drawForest</code>.<div class=sourceCode id=cb104 data-tangle=pretty_tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb104-1><a href=#cb104-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span>           <span class=dt>Data.Tree</span> (<span class=dt>Tree</span>,<span class=dt>Forest</span>(..))</span>
<span id=cb104-2><a href=#cb104-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=kw>qualified</span> <span class=dt>Data.Tree</span> <span class=kw>as</span> <span class=dt>Tree</span></span>
<span id=cb104-3><a href=#cb104-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb104-4><a href=#cb104-4 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>BinTree</span> a <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb104-5><a href=#cb104-5 aria-hidden=true tabindex=-1></a>               <span class=op>|</span> <span class=dt>Node</span> a (<span class=dt>BinTree</span> a) (<span class=dt>BinTree</span> a)</span>
<span id=cb104-6><a href=#cb104-6 aria-hidden=true tabindex=-1></a>               <span class=kw>deriving</span> (<span class=dt>Eq</span>,<span class=dt>Ord</span>,<span class=dt>Show</span>)</span>
<span id=cb104-7><a href=#cb104-7 aria-hidden=true tabindex=-1></a></span>
<span id=cb104-8><a href=#cb104-8 aria-hidden=true tabindex=-1></a><span class=ot>treeFromList ::</span> (<span class=dt>Ord</span> a) <span class=ot>=&gt;</span> [a] <span class=ot>-&gt;</span> <span class=dt>BinTree</span> a</span>
<span id=cb104-9><a href=#cb104-9 aria-hidden=true tabindex=-1></a>treeFromList [] <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb104-10><a href=#cb104-10 aria-hidden=true tabindex=-1></a>treeFromList (x<span class=op>:</span>xs) <span class=ot>=</span> <span class=dt>Node</span> x (treeFromList (<span class=fu>filter</span> (<span class=op>&lt;</span>x) xs))</span>
<span id=cb104-11><a href=#cb104-11 aria-hidden=true tabindex=-1></a>                      (treeFromList (<span class=fu>filter</span> (<span class=op>&gt;</span>x) xs))</span>
<span id=cb104-12><a href=#cb104-12 aria-hidden=true tabindex=-1></a></span>
<span id=cb104-13><a href=#cb104-13 aria-hidden=true tabindex=-1></a><span class=co>-- | Function to transform our internal BinTree type to the</span></span>
<span id=cb104-14><a href=#cb104-14 aria-hidden=true tabindex=-1></a><span class=co>-- type of Tree declared in Data.Tree (from containers package)</span></span>
<span id=cb104-15><a href=#cb104-15 aria-hidden=true tabindex=-1></a><span class=co>-- so that the function Tree.drawForest can use</span></span>
<span id=cb104-16><a href=#cb104-16 aria-hidden=true tabindex=-1></a><span class=ot>binTreeToForestString ::</span> (<span class=dt>Show</span> a) <span class=ot>=&gt;</span> <span class=dt>BinTree</span> a <span class=ot>-&gt;</span> <span class=dt>Forest</span> <span class=dt>String</span></span>
<span id=cb104-17><a href=#cb104-17 aria-hidden=true tabindex=-1></a>binTreeToForestString <span class=dt>Empty</span> <span class=ot>=</span> []</span>
<span id=cb104-18><a href=#cb104-18 aria-hidden=true tabindex=-1></a>binTreeToForestString (<span class=dt>Node</span> x left right) <span class=ot>=</span></span>
<span id=cb104-19><a href=#cb104-19 aria-hidden=true tabindex=-1></a>  [<span class=dt>Tree.Node</span> (<span class=fu>show</span> x) ((binTreeToForestString left) <span class=op>++</span> (binTreeToForestString right))]</span>
<span id=cb104-20><a href=#cb104-20 aria-hidden=true tabindex=-1></a></span>
<span id=cb104-21><a href=#cb104-21 aria-hidden=true tabindex=-1></a><span class=co>-- | Function that given a BinTree print a representation of it in the console</span></span>
<span id=cb104-22><a href=#cb104-22 aria-hidden=true tabindex=-1></a><span class=ot>prettyPrintTree ::</span> (<span class=dt>Show</span> a) <span class=ot>=&gt;</span> <span class=dt>BinTree</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</span>
<span id=cb104-23><a href=#cb104-23 aria-hidden=true tabindex=-1></a>prettyPrintTree <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=op>.</span> Tree.drawForest <span class=op>.</span> binTreeToForestString</span>
<span id=cb104-24><a href=#cb104-24 aria-hidden=true tabindex=-1></a></span>
<span id=cb104-25><a href=#cb104-25 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb104-26><a href=#cb104-26 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Int binary tree:&quot;</span></span>
<span id=cb104-27><a href=#cb104-27 aria-hidden=true tabindex=-1></a>  prettyPrintTree <span class=op>$</span> treeFromList [<span class=dv>7</span>,<span class=dv>2</span>,<span class=dv>4</span>,<span class=dv>8</span>,<span class=dv>1</span>,<span class=dv>3</span>,<span class=dv>6</span>,<span class=dv>21</span>,<span class=dv>12</span>,<span class=dv>23</span>]</span>
<span id=cb104-28><a href=#cb104-28 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;\nNote we could also use another type\n&quot;</span></span>
<span id=cb104-29><a href=#cb104-29 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;String binary tree:&quot;</span></span>
<span id=cb104-30><a href=#cb104-30 aria-hidden=true tabindex=-1></a>  prettyPrintTree <span class=op>$</span></span>
<span id=cb104-31><a href=#cb104-31 aria-hidden=true tabindex=-1></a>    treeFromList [<span class=st>&quot;foo&quot;</span>,<span class=st>&quot;bar&quot;</span>,<span class=st>&quot;baz&quot;</span>,<span class=st>&quot;gor&quot;</span>,<span class=st>&quot;yog&quot;</span>]</span>
<span id=cb104-32><a href=#cb104-32 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;\nAs we can test equality and order trees, we can make tree of trees!\n&quot;</span></span>
<span id=cb104-33><a href=#cb104-33 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;\nBinary tree of Char binary trees:&quot;</span></span>
<span id=cb104-34><a href=#cb104-34 aria-hidden=true tabindex=-1></a>  prettyPrintTree (treeFromList</span>
<span id=cb104-35><a href=#cb104-35 aria-hidden=true tabindex=-1></a>                    (<span class=fu>map</span> treeFromList [<span class=st>&quot;foo&quot;</span>,<span class=st>&quot;bar&quot;</span>,<span class=st>&quot;zara&quot;</span>,<span class=st>&quot;baz&quot;</span>,<span class=st>&quot;foo&quot;</span>]))</span></code></pre></div><pre class=example><code>~/t/hsenv&gt; runghc pretty_tree.hs
Int binary tree:
7
|
+- 2
|  |
|  +- 1
|  |
|  `- 4
|     |
|     +- 3
|     |
|     `- 6
|
`- 8
   |
   `- 21
      |
      +- 12
      |
      `- 23

Note we could also use another type

String binary tree:
&quot;foo&quot;
|
+- &quot;bar&quot;
|  |
|  `- &quot;baz&quot;
|
`- &quot;gor&quot;
   |
   `- &quot;yog&quot;

As we can test equality and order trees, we can make tree of trees!

Binary tree of Char binary trees:
Node &#39;f&#39; Empty (Node &#39;o&#39; Empty Empty)
|
+- Node &#39;b&#39; (Node &#39;a&#39; Empty Empty) (Node &#39;r&#39; Empty Empty)
|  |
|  `- Node &#39;b&#39; (Node &#39;a&#39; Empty Empty) (Node &#39;z&#39; Empty Empty)
|
`- Node &#39;z&#39; (Node &#39;a&#39; Empty (Node &#39;r&#39; Empty Empty)) Empty
</code></pre><p>Notice how duplicate elements aren't inserted in trees. For exemple
the Char BinTree constructed from the list <code class=verbatim>foo</code> is just <code class=verbatim>f -> o</code>. When <code class=verbatim>o</code>
is inserted another time the second <code class=verbatim>o</code> is
not duplicated. But more importantly it works also for our own <code class=verbatim>BinTree</code> notice how the tree for <code class=verbatim>foo</code> is inserted only once. We have this for
(almost) free, because we have declared Tree to be an instance of <code class=verbatim>Eq</code>.<p>See how awesome this structure is: we can make trees containing not
only integers, strings and chars, but also other trees. And we can even
make a tree containing a tree of trees!<h3 id=more-advanced-types>More Advanced Types</h3><p>So far we have presented types that are close to types we can see in
most typed programming languages. But the real strength of Haskell is
its type system. So I will try to give you an idea about what makes the
Haskell type system more advanced than in most languages.<p>So as comparison, classical types/schemas, etc… are about products of
different sub-types:<div class=sourceCode id=cb106><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb106-1><a href=#cb106-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>ProductType</span> <span class=ot>=</span> <span class=dt>P</span> <span class=dt>Int</span> <span class=dt>String</span></span>
<span id=cb106-2><a href=#cb106-2 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>PersonRecord</span> <span class=ot>=</span> <span class=dt>Person</span> {<span class=ot> age ::</span> <span class=dt>Int</span>,<span class=ot> name ::</span> <span class=dt>String</span> }</span></code></pre></div><p>Haskell has also a notion of <code class=verbatim>sum types</code>
that I often lack a lot in other programming languages I use.<p>You can define your type as a sum:<div class=sourceCode id=cb107><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb107-1><a href=#cb107-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>Point</span> <span class=ot>=</span> <span class=dt>D1</span> <span class=dt>Int</span> <span class=op>|</span> <span class=dt>D2</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=op>|</span> <span class=dt>D3</span> <span class=dt>Int</span> <span class=dt>Int</span> <span class=dt>Int</span></span></code></pre></div><p>So far so good. Sum types are already a nice thing to have, in
particular within Haskell because now the compiler can warn you if you
miss a case. For example if you write:<div class=sourceCode id=cb108><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb108-1><a href=#cb108-1 aria-hidden=true tabindex=-1></a><span class=kw>case</span> point <span class=kw>of</span></span>
<span id=cb108-2><a href=#cb108-2 aria-hidden=true tabindex=-1></a>  <span class=dt>D1</span> x <span class=ot>-&gt;</span> <span class=op>...</span></span>
<span id=cb108-3><a href=#cb108-3 aria-hidden=true tabindex=-1></a>  <span class=dt>D2</span> x y <span class=ot>-&gt;</span> <span class=op>...</span></span></code></pre></div><p>If you compile with the <code class=verbatim>-Wall</code> flag (as
you should always do for serious development) then the compiler will
warn you that you are forgetting some possible value.<p>Those are still not really advanced types. Advanced type are higher
order types. Those are the one that help with making your code more
polymorphic.<p>We will start with example I alreday provided, lists:<div class=sourceCode id=cb109><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb109-1><a href=#cb109-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>MyList</span> a <span class=ot>=</span> <span class=dt>Cons</span> a (<span class=dt>MyList</span> a) <span class=op>|</span> <span class=dt>Nil</span></span></code></pre></div><p>As you can see <code class=verbatim>MyList</code> takes a type
parameter. So <code class=verbatim>MyList</code> is a higher order
type. Generally, the intuition behind type is that a type is a data
structure or a container. But in fact, Haskell types can be or can
contain functions. This is for example the case for <code class=verbatim>IO</code>. And this is why it can be confusing to read
the type of some functions. I will take as example <code class=verbatim>sequenceA</code>:<div class=sourceCode id=cb110><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb110-1><a href=#cb110-1 aria-hidden=true tabindex=-1></a><span class=fu>sequenceA</span><span class=ot> ::</span> <span class=dt>Applicative</span> f <span class=ot>=&gt;</span> t (f a) <span class=ot>-&gt;</span> f (t a)</span></code></pre></div><p>So if you read this, it can be quite difficult to grasp what is the
intended use of this function. A simple technique for example, is to try
to replace the higher order types (here <code class=verbatim>t</code>
and <code class=verbatim>f</code>) by a type you can have some
intuition about. For example consider <code class=verbatim>t</code> to
be the higher order type <code class=verbatim>Tree</code> and <code class=verbatim>f</code> to be the higher order type <code class=verbatim>[]</code> (list).<p>Now you can see that <code class=verbatim>sequenceA</code> sill
take a Tree of lists and will return a list of trees. For it to work
<code class=verbatim>[]</code> need to be part of the <code class=verbatim>Applicative</code> class type (which is the case). I
will not enter into the details about what <code class=verbatim>Applicative</code> type class is here. But just with
this, you should start to have a better intuition about what <code class=verbatim>sequenceA</code> is about.<h2 id=infinite-structures>Infinite Structures</h2><figure><img src=./escher_infinite_lizards.jpg.webp alt=Escher><figcaption aria-hidden=true>Escher</figcaption></figure><p>It is often said that Haskell is <em>lazy</em>.<p>In fact, if you are a bit pedantic, you should say that <a href=http://www.haskell.html/haskellwiki/Lazy_vs._non-strict>Haskell
is <em>non-strict</em></a>. Laziness is just a common implementation for
non-strict languages.<p>Then what does "not-strict" mean? From the Haskell wiki:<blockquote><p>Reduction (the mathematical term for evaluation) proceeds from the
outside in.<p>so if you have <code class=verbatim>(a+(b*c))</code> then you first
reduce <code class=verbatim>+</code> first, then you reduce the inner
<code class=verbatim>(b*c)</code></blockquote><p>For example in Haskell you can do:<div class=sourceCode id=cb111><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb111-1><a href=#cb111-1 aria-hidden=true tabindex=-1></a><span class=co>-- numbers = [1,2,..]</span></span>
<span id=cb111-2><a href=#cb111-2 aria-hidden=true tabindex=-1></a><span class=ot>numbers ::</span> [<span class=dt>Integer</span>]</span>
<span id=cb111-3><a href=#cb111-3 aria-hidden=true tabindex=-1></a>numbers <span class=ot>=</span> <span class=dv>0</span><span class=op>:</span><span class=fu>map</span> (<span class=dv>1</span><span class=op>+</span>) numbers</span>
<span id=cb111-4><a href=#cb111-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb111-5><a href=#cb111-5 aria-hidden=true tabindex=-1></a>take&#39; n [] <span class=ot>=</span> []</span>
<span id=cb111-6><a href=#cb111-6 aria-hidden=true tabindex=-1></a>take&#39; <span class=dv>0</span> l <span class=ot>=</span> []</span>
<span id=cb111-7><a href=#cb111-7 aria-hidden=true tabindex=-1></a>take&#39; n (x<span class=op>:</span>xs) <span class=ot>=</span> x<span class=op>:</span>take&#39; (n<span class=op>-</span><span class=dv>1</span>) xs</span>
<span id=cb111-8><a href=#cb111-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb111-9><a href=#cb111-9 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> <span class=op>$</span> take&#39; <span class=dv>10</span> numbers</span></code></pre></div><p>And it stops.<p>How?<p>Instead of trying to evaluate <code class=verbatim>numbers</code>
entirely, it evaluates elements only when needed.<p>Also, note in Haskell there is a notation for infinite lists<pre class=example><code>[1..]   ⇔ [1,2,3,4...]
[1,3..] ⇔ [1,3,5,7,9,11...]
</code></pre><p>and most functions will work with them. Also, there is a built-in
function <code class=verbatim>take</code> which is equivalent to our
<code class=verbatim>take'</code>.<h3 id=infinite-trees>Infinite Trees</h3><p>Suppose we don't mind having an ordered binary tree. Here is an
infinite binary tree:<div class=sourceCode id=cb113 data-tangle=infinite_tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb113-1><a href=#cb113-1 aria-hidden=true tabindex=-1></a>nullTree <span class=ot>=</span> <span class=dt>Node</span> <span class=dv>0</span> nullTree nullTree</span></code></pre></div><p>A complete binary tree where each node is equal to 0. Now I will
prove you can manipulate this object using the following function:<div class=sourceCode id=cb114 data-tangle=infinite_tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb114-1><a href=#cb114-1 aria-hidden=true tabindex=-1></a><span class=co>-- take all element of a BinTree</span></span>
<span id=cb114-2><a href=#cb114-2 aria-hidden=true tabindex=-1></a><span class=co>-- up to some depth</span></span>
<span id=cb114-3><a href=#cb114-3 aria-hidden=true tabindex=-1></a>treeTakeDepth _ <span class=dt>Empty</span> <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb114-4><a href=#cb114-4 aria-hidden=true tabindex=-1></a>treeTakeDepth <span class=dv>0</span> _     <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb114-5><a href=#cb114-5 aria-hidden=true tabindex=-1></a>treeTakeDepth n (<span class=dt>Node</span> x left right) <span class=ot>=</span> <span class=kw>let</span></span>
<span id=cb114-6><a href=#cb114-6 aria-hidden=true tabindex=-1></a>          nl <span class=ot>=</span> treeTakeDepth (n<span class=op>-</span><span class=dv>1</span>) left</span>
<span id=cb114-7><a href=#cb114-7 aria-hidden=true tabindex=-1></a>          nr <span class=ot>=</span> treeTakeDepth (n<span class=op>-</span><span class=dv>1</span>) right</span>
<span id=cb114-8><a href=#cb114-8 aria-hidden=true tabindex=-1></a>          <span class=kw>in</span></span>
<span id=cb114-9><a href=#cb114-9 aria-hidden=true tabindex=-1></a>              <span class=dt>Node</span> x nl nr</span></code></pre></div><p>See what occurs for this program:<div class=sourceCode id=cb115 data-tangle=infinite_tree.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb115-1><a href=#cb115-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> prettyPrintTree (treeTakeDepth <span class=dv>4</span> nullTree)</span></code></pre></div><p>This code compiles, runs and stops giving the following result:<pre class=example><code>[hs:hsenv]&gt; runghc infinite_tree.hs
0
|
+- 0
|  |
|  +- 0
|  |  |
|  |  +- 0
|  |  |
|  |  `- 0
|  |
|  `- 0
|     |
|     +- 0
|     |
|     `- 0
|
`- 0
   |
   +- 0
   |  |
   |  +- 0
   |  |
   |  `- 0
   |
   `- 0
      |
      +- 0
      |
      `- 0

</code></pre><p>Just to heat up your neurones a bit more, let's make a slightly more
interesting tree:<div class=sourceCode id=cb117 data-tangle=infinite_tree_2.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb117-1><a href=#cb117-1 aria-hidden=true tabindex=-1></a>iTree <span class=ot>=</span> <span class=dt>Node</span> <span class=dv>0</span> (dec iTree) (inc iTree)</span>
<span id=cb117-2><a href=#cb117-2 aria-hidden=true tabindex=-1></a>        <span class=kw>where</span></span>
<span id=cb117-3><a href=#cb117-3 aria-hidden=true tabindex=-1></a>           dec (<span class=dt>Node</span> x l r) <span class=ot>=</span> <span class=dt>Node</span> (x<span class=op>-</span><span class=dv>1</span>) (dec l) (dec r)</span>
<span id=cb117-4><a href=#cb117-4 aria-hidden=true tabindex=-1></a>           inc (<span class=dt>Node</span> x l r) <span class=ot>=</span> <span class=dt>Node</span> (x<span class=op>+</span><span class=dv>1</span>) (inc l) (inc r)</span></code></pre></div><p>Another way to create this tree is to use a higher order function.
This function should be similar to <code class=verbatim>map</code>,
but should work on <code class=verbatim>BinTree</code> instead of
list. Here is such a function:<div class=sourceCode id=cb118 data-tangle=infinite_tree_2.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb118-1><a href=#cb118-1 aria-hidden=true tabindex=-1></a><span class=co>-- apply a function to each node of Tree</span></span>
<span id=cb118-2><a href=#cb118-2 aria-hidden=true tabindex=-1></a><span class=ot>treeMap ::</span> (a <span class=ot>-&gt;</span> b) <span class=ot>-&gt;</span> <span class=dt>BinTree</span> a <span class=ot>-&gt;</span> <span class=dt>BinTree</span> b</span>
<span id=cb118-3><a href=#cb118-3 aria-hidden=true tabindex=-1></a>treeMap f <span class=dt>Empty</span> <span class=ot>=</span> <span class=dt>Empty</span></span>
<span id=cb118-4><a href=#cb118-4 aria-hidden=true tabindex=-1></a>treeMap f (<span class=dt>Node</span> x left right) <span class=ot>=</span> <span class=dt>Node</span> (f x)</span>
<span id=cb118-5><a href=#cb118-5 aria-hidden=true tabindex=-1></a>                                     (treeMap f left)</span>
<span id=cb118-6><a href=#cb118-6 aria-hidden=true tabindex=-1></a>                                     (treeMap f right)</span></code></pre></div><p><em>Hint</em>: I won't talk more about this here. If you are
interested in the generalization of <code class=verbatim>map</code> to
other data structures, search for functor and <code class=verbatim>fmap</code>.<p>Our definition is now:<div class=sourceCode id=cb119 data-tangle=infinite_tree_2.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb119-1><a href=#cb119-1 aria-hidden=true tabindex=-1></a><span class=ot>infTreeTwo ::</span> <span class=dt>BinTree</span> <span class=dt>Int</span></span>
<span id=cb119-2><a href=#cb119-2 aria-hidden=true tabindex=-1></a>infTreeTwo <span class=ot>=</span> <span class=dt>Node</span> <span class=dv>0</span> (treeMap (\x <span class=ot>-&gt;</span> x<span class=op>-</span><span class=dv>1</span>) infTreeTwo)</span>
<span id=cb119-3><a href=#cb119-3 aria-hidden=true tabindex=-1></a>                    (treeMap (\x <span class=ot>-&gt;</span> x<span class=op>+</span><span class=dv>1</span>) infTreeTwo)</span></code></pre></div><p>Look at the result for<div class=sourceCode id=cb120 data-tangle=infinite_tree_2.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb120-1><a href=#cb120-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> prettyPrintTree <span class=op>$</span> treeTakeDepth <span class=dv>4</span> infTreeTwo</span></code></pre></div><pre class=example><code>[hs:hsenv]&gt; runghc infinite_tree_2.hs
0
|
+- -1
|  |
|  +- -2
|  |  |
|  |  +- -3
|  |  |
|  |  `- -1
|  |
|  `- 0
|     |
|     +- -1
|     |
|     `- 1
|
`- 1
   |
   +- 0
   |  |
   |  +- -1
   |  |
   |  `- 1
   |
   `- 2
      |
      +- 1
      |
      `- 3
</code></pre><h3 id=fibonnacci-infinite-list>Fibonnacci infinite list</h3><p>The important things to remember. Haskell handle infinite structures
naturally mostly because it is not strict.<p>So you can write, infinite tree, but also, you can generate infinite
list like this common example:<div class=sourceCode id=cb122 data-tangle=fib_lazy.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb122-1><a href=#cb122-1 aria-hidden=true tabindex=-1></a><span class=ot>fib ::</span> [<span class=dt>Integer</span>]</span>
<span id=cb122-2><a href=#cb122-2 aria-hidden=true tabindex=-1></a>fib <span class=ot>=</span> <span class=dv>1</span><span class=op>:</span><span class=dv>1</span><span class=op>:</span><span class=fu>zipWith</span> (<span class=op>+</span>) fib (<span class=fu>tail</span> fib)</span>
<span id=cb122-3><a href=#cb122-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb122-4><a href=#cb122-4 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>traverse</span> <span class=fu>print</span> (<span class=fu>take</span> <span class=dv>20</span> (<span class=fu>drop</span> <span class=dv>200</span> fib))</span></code></pre></div><p>Many new details in this small code. Don't worry if you do not get
all details:<ul><li><code class=verbatim>fib</code> is a list of Integer, not a
function<li><code class=verbatim>drop n</code> remove n element of a list<li><code class=verbatim>take n</code> keep the first n elements of a
list<li><code class=verbatim>zipWith op [a1,a2,a3,...] [b1,b2,b3,...]</code> will
generate the list <code class=verbatim>[op a1 b1,op a2 b2,op a3 b3, .... ]</code><li><code class=verbatim>traverse</code> is like map but for
performing effects (in this case print)</ul><p>This progam print all fibonnacci numbers from 201 to 221
instantaneously. Because, <code class=verbatim>fib</code> is a list
that will be used as "cache" to compute each number even considering the
code looks a bit like a double recursion.<pre class=example><code>[hs:0010-Haskell-Now]&gt; time runghc fib_lazy.hs
453973694165307953197296969697410619233826
734544867157818093234908902110449296423351
1188518561323126046432205871807859915657177
1923063428480944139667114773918309212080528
3111581989804070186099320645726169127737705
5034645418285014325766435419644478339818233
8146227408089084511865756065370647467555938
13180872826374098837632191485015125807374171
21327100234463183349497947550385773274930109
34507973060837282187130139035400899082304280
55835073295300465536628086585786672357234389
90343046356137747723758225621187571439538669
146178119651438213260386312206974243796773058
236521166007575960984144537828161815236311727
382699285659014174244530850035136059033084785
619220451666590135228675387863297874269396512
1001919737325604309473206237898433933302481297
1621140188992194444701881625761731807571877809
2623059926317798754175087863660165740874359106
4244200115309993198876969489421897548446236915

real    0m1.000s
user    0m0.192s
sys 0m0.058s
</code></pre><p>Let's see how this work using <code class=verbatim>Debug.Trace</code>:<div class=sourceCode id=cb124 data-tangle=fib_lazy_trace.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb124-1><a href=#cb124-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Debug.Trace</span></span>
<span id=cb124-2><a href=#cb124-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb124-3><a href=#cb124-3 aria-hidden=true tabindex=-1></a><span class=co>-- like + but each time this is evaluated print a trace</span></span>
<span id=cb124-4><a href=#cb124-4 aria-hidden=true tabindex=-1></a>tracedPlus x y <span class=ot>=</span> trace (<span class=st>&quot;&gt; &quot;</span> <span class=op>++</span> <span class=fu>show</span> x <span class=op>++</span> <span class=st>&quot; + &quot;</span> <span class=op>++</span> <span class=fu>show</span> y) (x <span class=op>+</span> y)</span>
<span id=cb124-5><a href=#cb124-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb124-6><a href=#cb124-6 aria-hidden=true tabindex=-1></a><span class=ot>fib ::</span> [<span class=dt>Integer</span>]</span>
<span id=cb124-7><a href=#cb124-7 aria-hidden=true tabindex=-1></a>fib <span class=ot>=</span> <span class=dv>1</span><span class=op>:</span><span class=dv>1</span><span class=op>:</span><span class=fu>zipWith</span> tracedPlus fib (<span class=fu>tail</span> fib)</span>
<span id=cb124-8><a href=#cb124-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb124-9><a href=#cb124-9 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb124-10><a href=#cb124-10 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> (fib <span class=op>!!</span> <span class=dv>10</span>)</span>
<span id=cb124-11><a href=#cb124-11 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> (fib <span class=op>!!</span> <span class=dv>12</span>)</span></code></pre></div><pre class=example><code>[hs:hsenv]&gt; runghc fib_lazy_trace.hs
&gt; 1 + 1
&gt; 1 + 2
&gt; 2 + 3
&gt; 3 + 5
&gt; 5 + 8
&gt; 8 + 13
&gt; 13 + 21
&gt; 21 + 34
&gt; 34 + 55
89
&gt; 55 + 89
&gt; 89 + 144
233
</code></pre><p>Notice how, once computed, the list is kept in memory. This is why
when the second time we ask for the 12th element of fib we only perform
two more additions. This is both a blessing and a curse. A blessing if
you know when to use this as in this example. And a curse as if do not
take care about lazyness it will come back at you with memory leaks.<p>After a bit of experience, most Haskellers can avoid memory leaks
naturally.<h1 id=dive-into-the-impure>Dive into the impure</h1><p>Congratulations for getting so far!<p>You have been introduced to the functional style and how to deal with
<em>pure</em> code. Understand code that is only evaluated without
changing the state of the external world.<p>If you are like me, you should get the functional style. You should
also understand a bit more the advantages of laziness by default. But
you also don't really understand where to start in order to make a real
program. And in particular:<ul><li>How do you deal with effects?<li>Why is there a strange imperative-like notation for dealing with
IO?</ul><p>Be prepared, the answers might be complex. But they are all very
rewarding.<p>In this section you will first introduced about how to <em>use</em>
IO. That should not be that hard. Then, a harder section should explain
how IO works. And the last part will talk about how we can generalize
why we learned so far with IO to many different types.<h2 id=deal-with-io>Deal With IO</h2><figure><img src=./magritte_carte_blanche.jpg.webp alt="Magritte, Carte blanche"><figcaption aria-hidden=true>Magritte, Carte blanche</figcaption></figure><blockquote><p><abbr title="too long; didn't read">tl;dr:</abbr><p>A typical function doing <code class=verbatim>IO</code> looks a lot
like an imperative program:<div class=sourceCode id=cb126><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb126-1><a href=#cb126-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>IO</span> a</span>
<span id=cb126-2><a href=#cb126-2 aria-hidden=true tabindex=-1></a>f <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb126-3><a href=#cb126-3 aria-hidden=true tabindex=-1></a>  x <span class=ot>&lt;-</span> action1</span>
<span id=cb126-4><a href=#cb126-4 aria-hidden=true tabindex=-1></a>  action2 x</span>
<span id=cb126-5><a href=#cb126-5 aria-hidden=true tabindex=-1></a>  y <span class=ot>&lt;-</span> action3</span>
<span id=cb126-6><a href=#cb126-6 aria-hidden=true tabindex=-1></a>  action4 x y</span></code></pre></div><ul><li><p>To set a value to an object we use <code class=verbatim>&lt;-</code> .<li><p>The type of each line is <code class=verbatim>IO *</code>; in
this example:<div class=sourceCode id=cb127><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb127-1><a href=#cb127-1 aria-hidden=true tabindex=-1></a><span class=op>-</span><span class=ot> action1     ::</span> <span class=dt>IO</span> b</span>
<span id=cb127-2><a href=#cb127-2 aria-hidden=true tabindex=-1></a><span class=op>-</span><span class=ot> x           ::</span> b</span>
<span id=cb127-3><a href=#cb127-3 aria-hidden=true tabindex=-1></a><span class=op>-</span> action2<span class=ot> x   ::</span> <span class=dt>IO</span> ()</span>
<span id=cb127-4><a href=#cb127-4 aria-hidden=true tabindex=-1></a><span class=op>-</span><span class=ot> action3     ::</span> <span class=dt>IO</span> c</span>
<span id=cb127-5><a href=#cb127-5 aria-hidden=true tabindex=-1></a><span class=op>-</span><span class=ot> y           ::</span> c</span>
<span id=cb127-6><a href=#cb127-6 aria-hidden=true tabindex=-1></a><span class=op>-</span> action4 x<span class=ot> y ::</span> <span class=dt>IO</span> a</span></code></pre></div><li><p>Few objects have the type <code class=verbatim>IO a</code>,
this should help you choose. In particular you cannot use pure functions
directly here. To use pure functions you could do <code class=verbatim>action2 (purefunction x)</code> for example.</ul></blockquote><p>In this section, I will explain how to use IO, not how it works.
You'll see how Haskell separates the pure from the impure parts of the
program.<p>Don't stop because you're trying to understand the details of the
syntax. Answers will come in the next section.<p>What to achieve?<blockquote><p>Ask a user to enter a list of numbers. Print the sum of the
numbers.</blockquote><div class=sourceCode id=cb128 data-tangle=io_sum.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb128-1><a href=#cb128-1 aria-hidden=true tabindex=-1></a><span class=ot>toList ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> [<span class=dt>Integer</span>]</span>
<span id=cb128-2><a href=#cb128-2 aria-hidden=true tabindex=-1></a>toList input <span class=ot>=</span> <span class=fu>read</span> (<span class=st>&quot;[&quot;</span> <span class=op>++</span> input <span class=op>++</span> <span class=st>&quot;]&quot;</span>)</span>
<span id=cb128-3><a href=#cb128-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb128-4><a href=#cb128-4 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb128-5><a href=#cb128-5 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers (separated by comma):&quot;</span></span>
<span id=cb128-6><a href=#cb128-6 aria-hidden=true tabindex=-1></a>  input <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb128-7><a href=#cb128-7 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> <span class=fu>sum</span> (toList input)</span></code></pre></div><p>It should be straightforward to understand the behavior of this
program. Let's analyze the types in more detail.<div class=sourceCode id=cb129><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb129-1><a href=#cb129-1 aria-hidden=true tabindex=-1></a><span class=fu>putStrLn</span><span class=ot> ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</span>
<span id=cb129-2><a href=#cb129-2 aria-hidden=true tabindex=-1></a><span class=fu>getLine</span><span class=ot>  ::</span> <span class=dt>IO</span> <span class=dt>String</span></span>
<span id=cb129-3><a href=#cb129-3 aria-hidden=true tabindex=-1></a><span class=fu>print</span><span class=ot>    ::</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</span></code></pre></div><p>Or more interestingly, we note that each expression in the <code class=verbatim>do</code> block has a type of <code class=verbatim>IO a</code>.<div class=sourceCode id=cb130><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb130-1><a href=#cb130-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb130-2><a href=#cb130-2 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter ... &quot;</span><span class=ot> ::</span> <span class=dt>IO</span> ()</span>
<span id=cb130-3><a href=#cb130-3 aria-hidden=true tabindex=-1></a><span class=ot>  getLine               ::</span> <span class=dt>IO</span> <span class=dt>String</span></span>
<span id=cb130-4><a href=#cb130-4 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=dt>Something</span><span class=ot>       ::</span> <span class=dt>IO</span> ()</span></code></pre></div><p>We should also pay attention to the effect of the <code class=verbatim>&lt;-</code> symbol.<div class=sourceCode id=cb131><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb131-1><a href=#cb131-1 aria-hidden=true tabindex=-1></a><span class=kw>do</span></span>
<span id=cb131-2><a href=#cb131-2 aria-hidden=true tabindex=-1></a>  x <span class=ot>&lt;-</span> something</span></code></pre></div><p>If <code class=verbatim>something :: IO a</code> then <code class=verbatim>x :: a</code>.<p>Another important note about using <code class=verbatim>IO</code>:
all lines in a do block must be of one of the two forms:<div class=sourceCode id=cb132><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb132-1><a href=#cb132-1 aria-hidden=true tabindex=-1></a><span class=ot>action1 ::</span> <span class=dt>IO</span> a</span>
<span id=cb132-2><a href=#cb132-2 aria-hidden=true tabindex=-1></a>        <span class=co>-- in this case, generally a = ()</span></span></code></pre></div><p>or<div class=sourceCode id=cb133><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb133-1><a href=#cb133-1 aria-hidden=true tabindex=-1></a>value <span class=ot>&lt;-</span> action2    <span class=co>-- where</span></span>
<span id=cb133-2><a href=#cb133-2 aria-hidden=true tabindex=-1></a>                    <span class=co>-- action2 :: IO b</span></span>
<span id=cb133-3><a href=#cb133-3 aria-hidden=true tabindex=-1></a>                    <span class=co>-- value   :: b</span></span></code></pre></div><p>These two kinds of line will correspond to two different ways of
sequencing actions. The meaning of this sentence should be clearer by
the end of the next section.<p>Now let's see how this program behaves. For example, what happens if
the user enters something strange? Let's try:<pre class=example><code>[hs:hsenv]&gt; runghc io_sum.hs
Enter a list of numbers (separated by comma):
foo
Prelude.read: no parse
</code></pre><p>Argh! An evil error message and a crash! Our first improvement will
simply be to answer with a more friendly message.<p>In order to do this, we must detect that something went wrong. Here
is one way to do this: use the type <code class=verbatim>Maybe</code>.
This is a very common type in Haskell.<div class=sourceCode id=cb135 data-tangle=io_sum_safe.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb135-1><a href=#cb135-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.Maybe</span></span>
<span id=cb135-2><a href=#cb135-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Text.Read</span> (readMaybe)</span></code></pre></div><p>What is this thing? <code class=verbatim>Maybe</code> is a type
which takes one parameter. Its definition is:<div class=sourceCode id=cb136><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb136-1><a href=#cb136-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>Maybe</span> a <span class=ot>=</span> <span class=dt>Nothing</span> <span class=op>|</span> <span class=dt>Just</span> a</span></code></pre></div><p>This is a nice way to tell there was an error while trying to
create/compute a value. The <code class=verbatim>readMaybe</code>
function is a great example of this. This is a function similar to the
function <code class=verbatim>read</code><a href=#fn4 class=footnote-ref id=fnref4 role=doc-noteref><sup>4</sup></a>,
but if something goes wrong the returned value is <code class=verbatim>Nothing</code>. If the value is right, it returns <code class=verbatim>Just &lt;the value></code>.<p>Now to be a bit more readable, we define a function which goes like
this: If the string has the wrong format, it will return <code class=verbatim>Nothing</code>. Otherwise, for example for "1,2,3", it
will return <code class=verbatim>Just [1,2,3]</code>.<div class=sourceCode id=cb137 data-tangle=io_sum_safe.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb137-1><a href=#cb137-1 aria-hidden=true tabindex=-1></a><span class=ot>getListFromString ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> [<span class=dt>Integer</span>]</span>
<span id=cb137-2><a href=#cb137-2 aria-hidden=true tabindex=-1></a>getListFromString str <span class=ot>=</span> readMaybe <span class=op>$</span> <span class=st>&quot;[&quot;</span> <span class=op>++</span> str <span class=op>++</span> <span class=st>&quot;]&quot;</span></span></code></pre></div><p>We simply have to test the value in our main function.<div class=sourceCode id=cb138 data-tangle=io_sum_safe.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb138-1><a href=#cb138-1 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb138-2><a href=#cb138-2 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb138-3><a href=#cb138-3 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers (separated by comma):&quot;</span></span>
<span id=cb138-4><a href=#cb138-4 aria-hidden=true tabindex=-1></a>  input <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb138-5><a href=#cb138-5 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> maybeList <span class=ot>=</span> getListFromString input</span>
<span id=cb138-6><a href=#cb138-6 aria-hidden=true tabindex=-1></a>  <span class=kw>case</span> maybeList <span class=kw>of</span></span>
<span id=cb138-7><a href=#cb138-7 aria-hidden=true tabindex=-1></a>    <span class=dt>Just</span> l  <span class=ot>-&gt;</span> <span class=fu>print</span> (<span class=fu>sum</span> l)</span>
<span id=cb138-8><a href=#cb138-8 aria-hidden=true tabindex=-1></a>    <span class=dt>Nothing</span> <span class=ot>-&gt;</span> <span class=fu>putStrLn</span> <span class=st>&quot;Bad format. Good Bye.&quot;</span></span></code></pre></div><p>In case of error, we display a nice error message.<p>Note that the type of each expression in the main's <code class=verbatim>do</code> block remains of the form <code class=verbatim>IO a</code>.<p>One very important thing to note is the type of all the functions
defined so far. There is only one function which contains <code class=verbatim>IO</code> in its type: <code class=verbatim>main</code>. This means main is impure. But main uses
<code class=verbatim>getListFromString</code> which is pure. So it's
clear just by looking at declared types which functions are pure and
which are impure.<p>Why does purity matter? Among the many advantages, here are
three:<ul><li>It is far easier to think about pure code than impure code.<li>Purity protects you from all the hard-to-reproduce bugs that are due
to side effects.<li>You can evaluate pure functions in any order or in parallel without
risk.</ul><p>This is why you should generally put as most code as possible inside
pure functions.<p>Our next iteration will be to prompt the user again and again until
she enters a valid answer.<p>We keep the first part:<div class=sourceCode id=cb139 data-tangle=io_sum_ask.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb139-1><a href=#cb139-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.Maybe</span></span>
<span id=cb139-2><a href=#cb139-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Text.Read</span> (readMaybe)</span>
<span id=cb139-3><a href=#cb139-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb139-4><a href=#cb139-4 aria-hidden=true tabindex=-1></a><span class=ot>getListFromString ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> [<span class=dt>Integer</span>]</span>
<span id=cb139-5><a href=#cb139-5 aria-hidden=true tabindex=-1></a>getListFromString str <span class=ot>=</span> readMaybe <span class=op>$</span> <span class=st>&quot;[&quot;</span> <span class=op>++</span> str <span class=op>++</span> <span class=st>&quot;]&quot;</span></span></code></pre></div><p>Now we create a function which will ask the user for an list of
integers until the input is right.<div class=sourceCode id=cb140 data-tangle=io_sum_ask.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb140-1><a href=#cb140-1 aria-hidden=true tabindex=-1></a><span class=ot>askUser ::</span> <span class=dt>IO</span> [<span class=dt>Integer</span>]</span>
<span id=cb140-2><a href=#cb140-2 aria-hidden=true tabindex=-1></a>askUser <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb140-3><a href=#cb140-3 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers (separated by comma):&quot;</span></span>
<span id=cb140-4><a href=#cb140-4 aria-hidden=true tabindex=-1></a>  input <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb140-5><a href=#cb140-5 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> maybeList <span class=ot>=</span> getListFromString input</span>
<span id=cb140-6><a href=#cb140-6 aria-hidden=true tabindex=-1></a>  <span class=kw>case</span> maybeList <span class=kw>of</span></span>
<span id=cb140-7><a href=#cb140-7 aria-hidden=true tabindex=-1></a>      <span class=dt>Just</span> l  <span class=ot>-&gt;</span> <span class=fu>return</span> l</span>
<span id=cb140-8><a href=#cb140-8 aria-hidden=true tabindex=-1></a>      <span class=dt>Nothing</span> <span class=ot>-&gt;</span> askUser</span></code></pre></div><p>This function is of type <code class=verbatim>IO [Integer]</code>.
Such a type means that we retrieved a value of type <code class=verbatim>[Integer]</code> through some IO actions. Some people
might explain while waving their hands:<blockquote><p>«This is an <code class=verbatim>[Integer]</code> inside an <code class=verbatim>IO</code>.»</blockquote><p>If you want to understand the details behind all of this, you'll have
to read the next section. But really, if you just want to <em>use</em>
IO just practice a little and remember to think about the type.<p>Finally our main function is much simpler:<div class=sourceCode id=cb141 data-tangle=io_sum_ask.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb141-1><a href=#cb141-1 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb141-2><a href=#cb141-2 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb141-3><a href=#cb141-3 aria-hidden=true tabindex=-1></a>  list <span class=ot>&lt;-</span> askUser</span>
<span id=cb141-4><a href=#cb141-4 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> <span class=fu>sum</span> list</span></code></pre></div><p>We have finished with our introduction to <code class=verbatim>IO</code>. This was quite fast. Here are the main
things to remember:<ul><li>in the <code class=verbatim>do</code> block, each expression must
have the type <code class=verbatim>IO a</code>. You are then limited
with regard to the range of expressions available. For example, <code class=verbatim>getLine</code>, <code class=verbatim>print</code>,
<code class=verbatim>putStrLn</code>, etc…<li>Try to externalize the pure functions as much as possible.<li>the <code class=verbatim>IO a</code> type means: an IO
<em>action</em> which returns an element of type <code class=verbatim>a</code>. <code class=verbatim>IO</code> represents
actions; under the hood, <code class=verbatim>IO a</code> is the type
of a function. Read the next section if you are curious.</ul><p>If you practice a bit, you should be able to <em>use</em> <code class=verbatim>IO</code>.<blockquote><p><em>Exercises</em>:<ul><li>Make a program that sums all of its arguments. Hint: use the
function <code class=verbatim>getArgs</code>.</ul></blockquote><h2 id=io-trick-explained>IO trick explained</h2><figure><img src=./magritte_pipe.jpg.webp alt="Magritte, ceci n'est pas une pipe"><figcaption aria-hidden=true>Magritte, ceci n'est pas une
pipe</figcaption></figure><blockquote><p><abbr title="too long; didn't read">tl;dr:</abbr><p>To separate pure and impure parts, <code class=verbatim>main</code>
is defined as a function which modifies the state of the world.<pre class=example><code>main :: World -&gt; World
</code></pre><p>A function is guaranteed to have side effects only if it has this
type. But look at a typical main function:<div class=sourceCode id=cb143><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb143-1><a href=#cb143-1 aria-hidden=true tabindex=-1></a>main w0 <span class=ot>=</span></span>
<span id=cb143-2><a href=#cb143-2 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (v1,w1) <span class=ot>=</span> action1 w0 <span class=kw>in</span></span>
<span id=cb143-3><a href=#cb143-3 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (v2,w2) <span class=ot>=</span> action2 v1 w1 <span class=kw>in</span></span>
<span id=cb143-4><a href=#cb143-4 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (v3,w3) <span class=ot>=</span> action3 v2 w2 <span class=kw>in</span></span>
<span id=cb143-5><a href=#cb143-5 aria-hidden=true tabindex=-1></a>    action4 v3 w3</span></code></pre></div><p>We have a lot of temporary elements (here <code class=verbatim>w1</code>, <code class=verbatim>w2</code> and <code class=verbatim>w3</code>) which must be passed on to the next
action.<p>We create a function <code class=verbatim>bind</code> or
<code>(>>=)</code>. With <code class=verbatim>bind</code> we
don't need temporary names anymore.<div class=sourceCode id=cb144><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb144-1><a href=#cb144-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span></span>
<span id=cb144-2><a href=#cb144-2 aria-hidden=true tabindex=-1></a>  action1 <span class=op>&gt;&gt;=</span> action2 <span class=op>&gt;&gt;=</span> action3 <span class=op>&gt;&gt;=</span> action4</span></code></pre></div><p>Bonus: Haskell has syntactical sugar for us:<div class=sourceCode id=cb145><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb145-1><a href=#cb145-1 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb145-2><a href=#cb145-2 aria-hidden=true tabindex=-1></a>  v1 <span class=ot>&lt;-</span> action1</span>
<span id=cb145-3><a href=#cb145-3 aria-hidden=true tabindex=-1></a>  v2 <span class=ot>&lt;-</span> action2 v1</span>
<span id=cb145-4><a href=#cb145-4 aria-hidden=true tabindex=-1></a>  v3 <span class=ot>&lt;-</span> action3 v2</span>
<span id=cb145-5><a href=#cb145-5 aria-hidden=true tabindex=-1></a>  action4 v3</span></code></pre></div></blockquote><p>Why did we use this strange syntax, and what exactly is this <code class=verbatim>IO</code> type? It looks a bit like magic.<p>For now let's just forget all about the pure parts of our program,
and focus on the impure parts:<div class=sourceCode id=cb146><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb146-1><a href=#cb146-1 aria-hidden=true tabindex=-1></a><span class=ot>askUser ::</span> <span class=dt>IO</span> [<span class=dt>Integer</span>]</span>
<span id=cb146-2><a href=#cb146-2 aria-hidden=true tabindex=-1></a>askUser <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb146-3><a href=#cb146-3 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers (separated by commas):&quot;</span></span>
<span id=cb146-4><a href=#cb146-4 aria-hidden=true tabindex=-1></a>  input <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb146-5><a href=#cb146-5 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> maybeList <span class=ot>=</span> getListFromString input</span>
<span id=cb146-6><a href=#cb146-6 aria-hidden=true tabindex=-1></a>  <span class=kw>case</span> maybeList <span class=kw>of</span></span>
<span id=cb146-7><a href=#cb146-7 aria-hidden=true tabindex=-1></a>      <span class=dt>Just</span> l  <span class=ot>-&gt;</span> <span class=fu>return</span> l</span>
<span id=cb146-8><a href=#cb146-8 aria-hidden=true tabindex=-1></a>      <span class=dt>Nothing</span> <span class=ot>-&gt;</span> askUser</span>
<span id=cb146-9><a href=#cb146-9 aria-hidden=true tabindex=-1></a></span>
<span id=cb146-10><a href=#cb146-10 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb146-11><a href=#cb146-11 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb146-12><a href=#cb146-12 aria-hidden=true tabindex=-1></a>  list <span class=ot>&lt;-</span> askUser</span>
<span id=cb146-13><a href=#cb146-13 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> <span class=fu>sum</span> list</span></code></pre></div><p>First remark: this looks imperative. Haskell is powerful enough to
make impure code look imperative. For example, if you wish you could
create a <code class=verbatim>while</code> in Haskell. In fact, for
dealing with <code class=verbatim>IO</code>, an imperative style is
generally more appropriate.<p>But you should have noticed that the notation is a bit unusual. Here
is why, in detail.<p>In an impure language, the state of the world can be seen as a huge
hidden global variable. This hidden variable is accessible by all
functions of your language. For example, you can read and write a file
in any function. Whether a file exists or not is a difference in the
possible states that the world can take.<p>In Haskell the current state of the world is not hidden. Rather, it
is <em>explicitly</em> said that <code class=verbatim>main</code> is a
function that <em>potentially</em> changes the state of the world. Its
type is then something like:<div class=sourceCode id=cb147><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb147-1><a href=#cb147-1 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>World</span> <span class=ot>-&gt;</span> <span class=dt>World</span></span></code></pre></div><p>Not all functions may access this variable. Those which have access
to this variable are impure. Functions to which the world variable isn't
provided are pure<a href=#fn5 class=footnote-ref id=fnref5 role=doc-noteref><sup>5</sup></a>.<p>Haskell considers the state of the world as an input variable to
<code class=verbatim>main</code>. But the real type of main is closer
to this one<a href=#fn6 class=footnote-ref id=fnref6 role=doc-noteref><sup>6</sup></a>:<div class=sourceCode id=cb149><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb149-1><a href=#cb149-1 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>World</span> <span class=ot>-&gt;</span> ((),<span class=dt>World</span>)</span></code></pre></div><p>The <code class=verbatim>()</code> type is the unit type. Nothing
to see here.<p>Now let's rewrite our main function with this in mind:<div class=sourceCode id=cb150><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb150-1><a href=#cb150-1 aria-hidden=true tabindex=-1></a>main w0 <span class=ot>=</span></span>
<span id=cb150-2><a href=#cb150-2 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (list,w1) <span class=ot>=</span> askUser w0 <span class=kw>in</span></span>
<span id=cb150-3><a href=#cb150-3 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (x,w2) <span class=ot>=</span> <span class=fu>print</span> (<span class=fu>sum</span> list,w1) <span class=kw>in</span></span>
<span id=cb150-4><a href=#cb150-4 aria-hidden=true tabindex=-1></a>    x</span></code></pre></div><p>First, we note that all functions which have side effects must have
the type:<div class=sourceCode id=cb151><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb151-1><a href=#cb151-1 aria-hidden=true tabindex=-1></a><span class=dt>World</span> <span class=ot>-&gt;</span> (a,<span class=dt>World</span>)</span></code></pre></div><p>where <code class=verbatim>a</code> is the type of the result. For
example, a <code class=verbatim>getChar</code> function should have
the type <code class=verbatim>World -> (Char,
World)</code>.<p>Another thing to note is the trick to fix the order of evaluation. In
Haskell, in order to evaluate <code class=verbatim>f a b</code>, you
have many choices:<ul><li>first eval <code class=verbatim>a</code> then <code class=verbatim>b</code> then <code class=verbatim>f a b</code><li>first eval <code class=verbatim>b</code> then <code class=verbatim>a</code> then <code class=verbatim>f a b</code>.<li>eval <code class=verbatim>a</code> and <code class=verbatim>b</code> in parallel then <code class=verbatim>f a b</code></ul><p>This is true because we're working in a pure part of the
language.<p>Now, if you look at the main function, it is clear you must eval the
first line before the second one since to evaluate the second line you
have to get a parameter given by the evaluation of the first line.<p>This trick works like a charm. The compiler will at each step provide
a pointer to a new real world id. Under the hood, <code class=verbatim>print</code> will evaluate as:<ul><li>print something on the screen<li>modify the id of the world<li>evaluate as <code class=verbatim>((),new world id)</code>.</ul><p>Now, if you look at the style of the main function, it is clearly
awkward. Let's try to do the same to the <code class=verbatim>askUser</code> function:<div class=sourceCode id=cb152><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb152-1><a href=#cb152-1 aria-hidden=true tabindex=-1></a><span class=ot>askUser ::</span> <span class=dt>World</span> <span class=ot>-&gt;</span> ([<span class=dt>Integer</span>],<span class=dt>World</span>)</span></code></pre></div><p>Before:<div class=sourceCode id=cb153><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb153-1><a href=#cb153-1 aria-hidden=true tabindex=-1></a><span class=ot>askUser ::</span> <span class=dt>IO</span> [<span class=dt>Integer</span>]</span>
<span id=cb153-2><a href=#cb153-2 aria-hidden=true tabindex=-1></a>askUser <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb153-3><a href=#cb153-3 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers:&quot;</span></span>
<span id=cb153-4><a href=#cb153-4 aria-hidden=true tabindex=-1></a>  input <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb153-5><a href=#cb153-5 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> maybeList <span class=ot>=</span> getListFromString input <span class=kw>in</span></span>
<span id=cb153-6><a href=#cb153-6 aria-hidden=true tabindex=-1></a>      <span class=kw>case</span> maybeList <span class=kw>of</span></span>
<span id=cb153-7><a href=#cb153-7 aria-hidden=true tabindex=-1></a>          <span class=dt>Just</span> l  <span class=ot>-&gt;</span> <span class=fu>return</span> l</span>
<span id=cb153-8><a href=#cb153-8 aria-hidden=true tabindex=-1></a>          <span class=dt>Nothing</span> <span class=ot>-&gt;</span> askUser</span></code></pre></div><p>After:<div class=sourceCode id=cb154><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb154-1><a href=#cb154-1 aria-hidden=true tabindex=-1></a>askUser w0 <span class=ot>=</span></span>
<span id=cb154-2><a href=#cb154-2 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (_,w1)     <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers:&quot;</span> <span class=kw>in</span></span>
<span id=cb154-3><a href=#cb154-3 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (input,w2) <span class=ot>=</span> <span class=fu>getLine</span> w1 <span class=kw>in</span></span>
<span id=cb154-4><a href=#cb154-4 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (l,w3)     <span class=ot>=</span> <span class=kw>case</span> getListFromString input <span class=kw>of</span></span>
<span id=cb154-5><a href=#cb154-5 aria-hidden=true tabindex=-1></a>                      <span class=dt>Just</span> l   <span class=ot>-&gt;</span> (l,w2)</span>
<span id=cb154-6><a href=#cb154-6 aria-hidden=true tabindex=-1></a>                      <span class=dt>Nothing</span>  <span class=ot>-&gt;</span> askUser w2</span>
<span id=cb154-7><a href=#cb154-7 aria-hidden=true tabindex=-1></a>    <span class=kw>in</span></span>
<span id=cb154-8><a href=#cb154-8 aria-hidden=true tabindex=-1></a>        (l,w3)</span></code></pre></div><p>This is similar, but awkward. Look at all these temporary <code class=verbatim>w?</code> names.<p>The lesson is: naive IO implementation in Pure functional languages
is awkward!<p>Fortunately, there is a better way to handle this problem. We see a
pattern. Each line is of the form:<div class=sourceCode id=cb155><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb155-1><a href=#cb155-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (y,w&#39;) <span class=ot>=</span> action x w <span class=kw>in</span></span></code></pre></div><p>Even if for some lines the first <code class=verbatim>x</code>
argument isn't needed. The output type is a couple, <code class=verbatim>(answer, newWorldValue)</code>. Each function <code class=verbatim>f</code> must have a type similar to:<div class=sourceCode id=cb156><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb156-1><a href=#cb156-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>World</span> <span class=ot>-&gt;</span> (a,<span class=dt>World</span>)</span></code></pre></div><p>Not only this, but we can also note that we always follow the same
usage pattern:<div class=sourceCode id=cb157><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb157-1><a href=#cb157-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (y,w1) <span class=ot>=</span> action1 w0 <span class=kw>in</span></span>
<span id=cb157-2><a href=#cb157-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (z,w2) <span class=ot>=</span> action2 w1 <span class=kw>in</span></span>
<span id=cb157-3><a href=#cb157-3 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (t,w3) <span class=ot>=</span> action3 w2 <span class=kw>in</span></span>
<span id=cb157-4><a href=#cb157-4 aria-hidden=true tabindex=-1></a><span class=op>...</span></span></code></pre></div><p>Each action can take from 0 to n parameters. And in particular, each
action can take a parameter from the result of a line above.<p>For example, we could also have:<div class=sourceCode id=cb158><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb158-1><a href=#cb158-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (_,w1) <span class=ot>=</span> action1 x w0   <span class=kw>in</span></span>
<span id=cb158-2><a href=#cb158-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (z,w2) <span class=ot>=</span> action2 w1     <span class=kw>in</span></span>
<span id=cb158-3><a href=#cb158-3 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (_,w3) <span class=ot>=</span> action3 z w2 <span class=kw>in</span></span>
<span id=cb158-4><a href=#cb158-4 aria-hidden=true tabindex=-1></a><span class=op>...</span></span></code></pre></div><p>With, of course: <code class=verbatim>actionN w :: (World) -> (a,World)</code>.<blockquote><p><strong>IMPORTANT</strong>: there are only two important patterns to
consider:<div class=sourceCode id=cb159><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb159-1><a href=#cb159-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (x,w1) <span class=ot>=</span> action1 w0 <span class=kw>in</span></span>
<span id=cb159-2><a href=#cb159-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (y,w2) <span class=ot>=</span> action2 x w1 <span class=kw>in</span></span></code></pre></div><p>and<div class=sourceCode id=cb160><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb160-1><a href=#cb160-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (_,w1) <span class=ot>=</span> action1 w0 <span class=kw>in</span></span>
<span id=cb160-2><a href=#cb160-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (y,w2) <span class=ot>=</span> action2 w1 <span class=kw>in</span></span></code></pre></div></blockquote><figure><img src=./slave-market-with-the-disappearing-bust-of-voltaire.jpg.webp alt="Slave Market with the disappearing bust of Voltaire"><figcaption aria-hidden=true>Slave Market with the disappearing bust
of Voltaire</figcaption></figure><p>Now, we will do a magic trick. We will make the temporary world
symbols <em>disappear</em>. We will <code class=verbatim>bind</code>
the two lines. Let's define the <code class=verbatim>bind</code>
function. Its type is quite intimidating at first:<div class=sourceCode id=cb161><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb161-1><a href=#cb161-1 aria-hidden=true tabindex=-1></a><span class=ot>bind ::</span> (<span class=dt>World</span> <span class=ot>-&gt;</span> (a,<span class=dt>World</span>))</span>
<span id=cb161-2><a href=#cb161-2 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> (<span class=dt>World</span> <span class=ot>-&gt;</span> (b,<span class=dt>World</span>)))</span>
<span id=cb161-3><a href=#cb161-3 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> (<span class=dt>World</span> <span class=ot>-&gt;</span> (b,<span class=dt>World</span>))</span></code></pre></div><p>But remember that <code class=verbatim>(World -> (a,World))</code> is the type for an IO
action. Now let's rename it for clarity:<div class=sourceCode id=cb162><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb162-1><a href=#cb162-1 aria-hidden=true tabindex=-1></a><span class=kw>type</span> <span class=dt>IO</span> a <span class=ot>=</span> <span class=dt>World</span> <span class=ot>-&gt;</span> (a, <span class=dt>World</span>)</span></code></pre></div><p>Some examples of functions:<div class=sourceCode id=cb163><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb163-1><a href=#cb163-1 aria-hidden=true tabindex=-1></a><span class=fu>getLine</span><span class=ot> ::</span> <span class=dt>IO</span> <span class=dt>String</span></span>
<span id=cb163-2><a href=#cb163-2 aria-hidden=true tabindex=-1></a><span class=fu>print</span><span class=ot> ::</span> <span class=dt>Show</span> a <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</span></code></pre></div><p><code class=verbatim>getLine</code> is an IO action which takes
world as a parameter and returns a couple <code class=verbatim>(String, World)</code>. This can be summarized as:
<code class=verbatim>getLine</code> is of type <code class=verbatim>IO String</code>, which we also see as an IO action
which will return a String "embeded inside an IO".<p>The function <code class=verbatim>print</code> is also interesting.
It takes one argument which can be shown. In fact it takes two
arguments. The first is the value to print and the other is the state of
world. It then returns a couple of type <code class=verbatim>((), World)</code>. This means that it changes the
state of the world, but doesn't yield any more data.<p>This new <code class=verbatim>IO a</code> type helps us simplify
the type of <code class=verbatim>bind</code>:<div class=sourceCode id=cb164><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb164-1><a href=#cb164-1 aria-hidden=true tabindex=-1></a><span class=ot>bind ::</span> <span class=dt>IO</span> a</span>
<span id=cb164-2><a href=#cb164-2 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>IO</span> b)</span>
<span id=cb164-3><a href=#cb164-3 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> <span class=dt>IO</span> b</span></code></pre></div><p>It says that <code class=verbatim>bind</code> takes two IO actions
as parameters and returns another IO action.<p>Now, remember the <em>important</em> patterns. The first was:<div class=sourceCode id=cb165><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb165-1><a href=#cb165-1 aria-hidden=true tabindex=-1></a>pattern1 w0 <span class=ot>=</span></span>
<span id=cb165-2><a href=#cb165-2 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> (x,w1) <span class=ot>=</span> action1 w0 <span class=kw>in</span></span>
<span id=cb165-3><a href=#cb165-3 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> (y,w2) <span class=ot>=</span> action2 x w1 <span class=kw>in</span></span>
<span id=cb165-4><a href=#cb165-4 aria-hidden=true tabindex=-1></a>  (y,w2)</span></code></pre></div><p>Look at the types:<div class=sourceCode id=cb166><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb166-1><a href=#cb166-1 aria-hidden=true tabindex=-1></a><span class=ot>action1  ::</span> <span class=dt>IO</span> a</span>
<span id=cb166-2><a href=#cb166-2 aria-hidden=true tabindex=-1></a><span class=ot>action2  ::</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> b</span>
<span id=cb166-3><a href=#cb166-3 aria-hidden=true tabindex=-1></a><span class=ot>pattern1 ::</span> <span class=dt>IO</span> b</span></code></pre></div><p>Doesn't it seem familiar?<div class=sourceCode id=cb167><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb167-1><a href=#cb167-1 aria-hidden=true tabindex=-1></a>(bind action1 action2) w0 <span class=ot>=</span></span>
<span id=cb167-2><a href=#cb167-2 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> (x, w1) <span class=ot>=</span> action1 w0</span>
<span id=cb167-3><a href=#cb167-3 aria-hidden=true tabindex=-1></a>        (y, w2) <span class=ot>=</span> action2 x w1</span>
<span id=cb167-4><a href=#cb167-4 aria-hidden=true tabindex=-1></a>    <span class=kw>in</span>  (y, w2)</span></code></pre></div><p>The idea is to hide the World argument with this function. As an
example imagine if we wanted to simulate:<div class=sourceCode id=cb168><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb168-1><a href=#cb168-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (line1, w1) <span class=ot>=</span> <span class=fu>getLine</span> w0 <span class=kw>in</span></span>
<span id=cb168-2><a href=#cb168-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span> ((), w2) <span class=ot>=</span> <span class=fu>print</span> line1 <span class=kw>in</span></span>
<span id=cb168-3><a href=#cb168-3 aria-hidden=true tabindex=-1></a>((), w2)</span></code></pre></div><p>Now, using the <code class=verbatim>bind</code> function:<div class=sourceCode id=cb169><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb169-1><a href=#cb169-1 aria-hidden=true tabindex=-1></a>(res, w2) <span class=ot>=</span> (bind <span class=fu>getLine</span> <span class=fu>print</span>) w0</span></code></pre></div><p>As print is of type
<code>Show a => a -> (World -> ((), World))</code>, we know
<code>res = ()</code> (<code class=verbatim>unit</code> type). If you
didn't see what was magic here, let's try with three lines this
time.<div class=sourceCode id=cb170><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb170-1><a href=#cb170-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (line1,w1) <span class=ot>=</span> <span class=fu>getLine</span> w0 <span class=kw>in</span></span>
<span id=cb170-2><a href=#cb170-2 aria-hidden=true tabindex=-1></a><span class=kw>let</span> (line2,w2) <span class=ot>=</span> <span class=fu>getLine</span> w1 <span class=kw>in</span></span>
<span id=cb170-3><a href=#cb170-3 aria-hidden=true tabindex=-1></a><span class=kw>let</span> ((),w3) <span class=ot>=</span> <span class=fu>print</span> (line1 <span class=op>++</span> line2) <span class=kw>in</span></span>
<span id=cb170-4><a href=#cb170-4 aria-hidden=true tabindex=-1></a>((),w3)</span></code></pre></div><p>Which is equivalent to:<div class=sourceCode id=cb171><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb171-1><a href=#cb171-1 aria-hidden=true tabindex=-1></a>(res,w3) <span class=ot>=</span> (bind <span class=fu>getLine</span> (\line1 <span class=ot>-&gt;</span></span>
<span id=cb171-2><a href=#cb171-2 aria-hidden=true tabindex=-1></a>             (bind <span class=fu>getLine</span> (\line2 <span class=ot>-&gt;</span></span>
<span id=cb171-3><a href=#cb171-3 aria-hidden=true tabindex=-1></a>               <span class=fu>print</span> (line1 <span class=op>++</span> line2))))) w0</span></code></pre></div><p>Didn't you notice something? Yes, no temporary World variables are
used anywhere! This is <em>MA</em>. <em>GIC</em>.<p>We can use a better notation. Let's use <code>(>>=)</code>
instead of <code class=verbatim>bind</code>. <code>(>>=)</code>
is an infix function like <code>(+)</code>; reminder
<code>3 + 4 ⇔ (+) 3 4</code><div class=sourceCode id=cb172><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb172-1><a href=#cb172-1 aria-hidden=true tabindex=-1></a>(res,w3) <span class=ot>=</span> (<span class=fu>getLine</span> <span class=op>&gt;&gt;=</span></span>
<span id=cb172-2><a href=#cb172-2 aria-hidden=true tabindex=-1></a>           (\line1 <span class=ot>-&gt;</span> <span class=fu>getLine</span> <span class=op>&gt;&gt;=</span></span>
<span id=cb172-3><a href=#cb172-3 aria-hidden=true tabindex=-1></a>           (\line2 <span class=ot>-&gt;</span> <span class=fu>print</span> (line1 <span class=op>++</span> line2)))) w0</span></code></pre></div><p>Merry Christmas Everyone! Haskell has made syntactical sugar for
us:<div class=sourceCode id=cb173><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb173-1><a href=#cb173-1 aria-hidden=true tabindex=-1></a><span class=kw>do</span></span>
<span id=cb173-2><a href=#cb173-2 aria-hidden=true tabindex=-1></a>  x <span class=ot>&lt;-</span> action1</span>
<span id=cb173-3><a href=#cb173-3 aria-hidden=true tabindex=-1></a>  y <span class=ot>&lt;-</span> action2</span>
<span id=cb173-4><a href=#cb173-4 aria-hidden=true tabindex=-1></a>  z <span class=ot>&lt;-</span> action3</span>
<span id=cb173-5><a href=#cb173-5 aria-hidden=true tabindex=-1></a>  <span class=op>...</span></span></code></pre></div><p>Is replaced by:<div class=sourceCode id=cb174><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb174-1><a href=#cb174-1 aria-hidden=true tabindex=-1></a>action1 <span class=op>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span></span>
<span id=cb174-2><a href=#cb174-2 aria-hidden=true tabindex=-1></a>action2 <span class=op>&gt;&gt;=</span> (\y <span class=ot>-&gt;</span></span>
<span id=cb174-3><a href=#cb174-3 aria-hidden=true tabindex=-1></a>action3 <span class=op>&gt;&gt;=</span> (\z <span class=ot>-&gt;</span></span>
<span id=cb174-4><a href=#cb174-4 aria-hidden=true tabindex=-1></a><span class=op>...</span></span>
<span id=cb174-5><a href=#cb174-5 aria-hidden=true tabindex=-1></a>)))</span></code></pre></div><p>Note that you can use <code class=verbatim>x</code> in <code class=verbatim>action2</code> and <code class=verbatim>x</code> and
<code class=verbatim>y</code> in <code class=verbatim>action3</code>.<p>But what about the lines not using the <code>&lt;-</code>? Easy,
another function <code class=verbatim>blindBind</code>:<div class=sourceCode id=cb175><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb175-1><a href=#cb175-1 aria-hidden=true tabindex=-1></a><span class=ot>blindBind ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> b <span class=ot>-&gt;</span> <span class=dt>IO</span> b</span>
<span id=cb175-2><a href=#cb175-2 aria-hidden=true tabindex=-1></a>blindBind action1 action2 w0 <span class=ot>=</span></span>
<span id=cb175-3><a href=#cb175-3 aria-hidden=true tabindex=-1></a>    bind action (\_ <span class=ot>-&gt;</span> action2) w0</span></code></pre></div><p>I didn't simplify this definition for the purposes of clarity. Of
course, we can use a better notation: we'll use the <code class=verbatim>(>>)</code> operator.<p>And<div class=sourceCode id=cb176><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb176-1><a href=#cb176-1 aria-hidden=true tabindex=-1></a><span class=kw>do</span></span>
<span id=cb176-2><a href=#cb176-2 aria-hidden=true tabindex=-1></a>    action1</span>
<span id=cb176-3><a href=#cb176-3 aria-hidden=true tabindex=-1></a>    action2</span>
<span id=cb176-4><a href=#cb176-4 aria-hidden=true tabindex=-1></a>    action3</span></code></pre></div><p>Is transformed into<div class=sourceCode id=cb177><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb177-1><a href=#cb177-1 aria-hidden=true tabindex=-1></a>action1 <span class=op>&gt;&gt;</span></span>
<span id=cb177-2><a href=#cb177-2 aria-hidden=true tabindex=-1></a>action2 <span class=op>&gt;&gt;</span></span>
<span id=cb177-3><a href=#cb177-3 aria-hidden=true tabindex=-1></a>action3</span></code></pre></div><p>Also, another function is quite useful.<div class=sourceCode id=cb178><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb178-1><a href=#cb178-1 aria-hidden=true tabindex=-1></a><span class=ot>putInIO ::</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> a</span>
<span id=cb178-2><a href=#cb178-2 aria-hidden=true tabindex=-1></a>putInIO x <span class=ot>=</span> <span class=dt>IO</span> (\w <span class=ot>-&gt;</span> (x,w))</span></code></pre></div><p>This is the general way to put pure values inside the "IO context".
The general name for <code class=verbatim>putInIO</code> is <code class=verbatim>pure</code> but you also see very often <code class=verbatim>return</code>. Historically <code class=verbatim>pure</code> was called <code class=verbatim>return</code>. This is quite a bad name when you learn
Haskell. <code class=verbatim>return</code> is very different from
what you might be used to.<p>To finish, let's translate our example:<div class=sourceCode id=cb179><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb179-1><a href=#cb179-1 aria-hidden=true tabindex=-1></a><span class=ot>askUser ::</span> <span class=dt>IO</span> [<span class=dt>Integer</span>]</span>
<span id=cb179-2><a href=#cb179-2 aria-hidden=true tabindex=-1></a>askUser <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb179-3><a href=#cb179-3 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers (separated by commas):&quot;</span></span>
<span id=cb179-4><a href=#cb179-4 aria-hidden=true tabindex=-1></a>  input <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb179-5><a href=#cb179-5 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> maybeList <span class=ot>=</span> getListFromString input <span class=kw>in</span></span>
<span id=cb179-6><a href=#cb179-6 aria-hidden=true tabindex=-1></a>      <span class=kw>case</span> maybeList <span class=kw>of</span></span>
<span id=cb179-7><a href=#cb179-7 aria-hidden=true tabindex=-1></a>          <span class=dt>Just</span> l  <span class=ot>-&gt;</span> <span class=fu>return</span> l</span>
<span id=cb179-8><a href=#cb179-8 aria-hidden=true tabindex=-1></a>          <span class=dt>Nothing</span> <span class=ot>-&gt;</span> askUser</span>
<span id=cb179-9><a href=#cb179-9 aria-hidden=true tabindex=-1></a></span>
<span id=cb179-10><a href=#cb179-10 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb179-11><a href=#cb179-11 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb179-12><a href=#cb179-12 aria-hidden=true tabindex=-1></a>  list <span class=ot>&lt;-</span> askUser</span>
<span id=cb179-13><a href=#cb179-13 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> <span class=fu>sum</span> list</span></code></pre></div><p>Is translated into:<div class=sourceCode id=cb180 data-tangle=io_bind.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb180-1><a href=#cb180-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Data.Maybe</span></span>
<span id=cb180-2><a href=#cb180-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Text.Read</span> (readMaybe)</span>
<span id=cb180-3><a href=#cb180-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb180-4><a href=#cb180-4 aria-hidden=true tabindex=-1></a><span class=ot>getListFromString ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> <span class=dt>Maybe</span> [<span class=dt>Integer</span>]</span>
<span id=cb180-5><a href=#cb180-5 aria-hidden=true tabindex=-1></a>getListFromString str <span class=ot>=</span> readMaybe <span class=op>$</span> <span class=st>&quot;[&quot;</span> <span class=op>++</span> str <span class=op>++</span> <span class=st>&quot;]&quot;</span></span>
<span id=cb180-6><a href=#cb180-6 aria-hidden=true tabindex=-1></a><span class=ot>askUser ::</span> <span class=dt>IO</span> [<span class=dt>Integer</span>]</span>
<span id=cb180-7><a href=#cb180-7 aria-hidden=true tabindex=-1></a>askUser <span class=ot>=</span></span>
<span id=cb180-8><a href=#cb180-8 aria-hidden=true tabindex=-1></a>    <span class=fu>putStrLn</span> <span class=st>&quot;Enter a list of numbers (sep. by commas):&quot;</span> <span class=op>&gt;&gt;</span></span>
<span id=cb180-9><a href=#cb180-9 aria-hidden=true tabindex=-1></a>    <span class=fu>getLine</span> <span class=op>&gt;&gt;=</span> \input <span class=ot>-&gt;</span></span>
<span id=cb180-10><a href=#cb180-10 aria-hidden=true tabindex=-1></a>    <span class=kw>let</span> maybeList <span class=ot>=</span> getListFromString input <span class=kw>in</span></span>
<span id=cb180-11><a href=#cb180-11 aria-hidden=true tabindex=-1></a>      <span class=kw>case</span> maybeList <span class=kw>of</span></span>
<span id=cb180-12><a href=#cb180-12 aria-hidden=true tabindex=-1></a>        <span class=dt>Just</span> l <span class=ot>-&gt;</span> <span class=fu>return</span> l</span>
<span id=cb180-13><a href=#cb180-13 aria-hidden=true tabindex=-1></a>        <span class=dt>Nothing</span> <span class=ot>-&gt;</span> askUser</span>
<span id=cb180-14><a href=#cb180-14 aria-hidden=true tabindex=-1></a></span>
<span id=cb180-15><a href=#cb180-15 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb180-16><a href=#cb180-16 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> askUser <span class=op>&gt;&gt;=</span></span>
<span id=cb180-17><a href=#cb180-17 aria-hidden=true tabindex=-1></a>  \list <span class=ot>-&gt;</span> <span class=fu>print</span> <span class=op>$</span> <span class=fu>sum</span> list</span></code></pre></div><p>You can compile this code to verify that it works.<p>Imagine what it would look like without the <code class=verbatim>(>>)</code> and <code class=verbatim>(>></code>)=.<h2 id=monads>Monads</h2><p>Now the secret can be revealed: <code class=verbatim>IO</code> is a
<em>monad</em>. Being a monad means you have access to some syntactical
sugar with the <code class=verbatim>do</code> notation. But mainly,
you have access to a coding pattern which will ease the flow of your
code.<blockquote><p><strong>Important remarks</strong>:<ul><li>Monad are not necessarily about effects! There are a lot of
<em>pure</em> monads.<li>Monad are more about sequencing</ul></blockquote><p>In Haskell, <code class=verbatim>Monad</code> is a type class. To
be an instance of this type class, you must provide the functions
<code>(>>=)</code> and <code>return</code>. The function
<code>(>>)</code> is derived from <code>(>>=)</code>. Here
is how the type class <code class=verbatim>Monad</code> is declared
(from <a href=https://hackage.haskell.html/package/base-4.12.0.0/docs/src/GHC.Base.html#Monad>hackage
GHC.Base</a>):<div class=sourceCode id=cb181><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb181-1><a href=#cb181-1 aria-hidden=true tabindex=-1></a><span class=kw>class</span> <span class=dt>Applicative</span> m <span class=ot>=&gt;</span> <span class=dt>Monad</span> m <span class=kw>where</span></span>
<span id=cb181-2><a href=#cb181-2 aria-hidden=true tabindex=-1></a>    <span class=co>-- | Sequentially compose two actions, passing any value produced</span></span>
<span id=cb181-3><a href=#cb181-3 aria-hidden=true tabindex=-1></a>    <span class=co>-- by the first as an argument to the second.</span></span>
<span id=cb181-4><a href=#cb181-4 aria-hidden=true tabindex=-1></a><span class=ot>    (&gt;&gt;=)       ::</span> <span class=kw>forall</span> a b<span class=op>.</span> m a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> m b) <span class=ot>-&gt;</span> m b</span>
<span id=cb181-5><a href=#cb181-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb181-6><a href=#cb181-6 aria-hidden=true tabindex=-1></a>    <span class=co>-- | Sequentially compose two actions, discarding any value produced</span></span>
<span id=cb181-7><a href=#cb181-7 aria-hidden=true tabindex=-1></a>    <span class=co>-- by the first, like sequencing operators (such as the semicolon)</span></span>
<span id=cb181-8><a href=#cb181-8 aria-hidden=true tabindex=-1></a>    <span class=co>-- in imperative languages.</span></span>
<span id=cb181-9><a href=#cb181-9 aria-hidden=true tabindex=-1></a><span class=ot>    (&gt;&gt;)        ::</span> <span class=kw>forall</span> a b<span class=op>.</span> m a <span class=ot>-&gt;</span> m b <span class=ot>-&gt;</span> m b</span>
<span id=cb181-10><a href=#cb181-10 aria-hidden=true tabindex=-1></a>    m <span class=op>&gt;&gt;</span> k <span class=ot>=</span> m <span class=op>&gt;&gt;=</span> \_ <span class=ot>-&gt;</span> k <span class=co>-- See Note [Recursive bindings for Applicative/Monad]</span></span>
<span id=cb181-11><a href=#cb181-11 aria-hidden=true tabindex=-1></a>    <span class=ot>{-# INLINE (&gt;&gt;) #-}</span></span>
<span id=cb181-12><a href=#cb181-12 aria-hidden=true tabindex=-1></a></span>
<span id=cb181-13><a href=#cb181-13 aria-hidden=true tabindex=-1></a>    <span class=co>-- | Inject a value into the monadic type.</span></span>
<span id=cb181-14><a href=#cb181-14 aria-hidden=true tabindex=-1></a><span class=ot>    return      ::</span> a <span class=ot>-&gt;</span> m a</span>
<span id=cb181-15><a href=#cb181-15 aria-hidden=true tabindex=-1></a>    <span class=fu>return</span>      <span class=ot>=</span> <span class=fu>pure</span></span>
<span id=cb181-16><a href=#cb181-16 aria-hidden=true tabindex=-1></a></span>
<span id=cb181-17><a href=#cb181-17 aria-hidden=true tabindex=-1></a>    <span class=co>-- | Fail with a message.  This operation is not part of the</span></span>
<span id=cb181-18><a href=#cb181-18 aria-hidden=true tabindex=-1></a>    <span class=co>-- mathematical definition of a monad, but is invoked on pattern-match</span></span>
<span id=cb181-19><a href=#cb181-19 aria-hidden=true tabindex=-1></a>    <span class=co>-- failure in a @do@ expression.</span></span>
<span id=cb181-20><a href=#cb181-20 aria-hidden=true tabindex=-1></a>    <span class=co>--</span></span>
<span id=cb181-21><a href=#cb181-21 aria-hidden=true tabindex=-1></a>    <span class=co>-- As part of the MonadFail proposal (MFP), this function is moved</span></span>
<span id=cb181-22><a href=#cb181-22 aria-hidden=true tabindex=-1></a>    <span class=co>-- to its own class &#39;MonadFail&#39; (see &quot;Control.Monad.Fail&quot; for more</span></span>
<span id=cb181-23><a href=#cb181-23 aria-hidden=true tabindex=-1></a>    <span class=co>-- details). The definition here will be removed in a future</span></span>
<span id=cb181-24><a href=#cb181-24 aria-hidden=true tabindex=-1></a>    <span class=co>-- release.</span></span>
<span id=cb181-25><a href=#cb181-25 aria-hidden=true tabindex=-1></a><span class=ot>    fail        ::</span> <span class=dt>String</span> <span class=ot>-&gt;</span> m a</span>
<span id=cb181-26><a href=#cb181-26 aria-hidden=true tabindex=-1></a>    <span class=fu>fail</span> s      <span class=ot>=</span> errorWithoutStackTrace s</span></code></pre></div><blockquote><p>Remarks:<ul><li><p>the keyword <code class=verbatim>class</code> is not your
friend. A Haskell class is <em>not</em> a class of the kind you will
find in object-oriented programming. A Haskell class has a lot of
similarities with Java interfaces. A better word would have been <code class=verbatim>typeclass</code>, since that means a set of types. For
a type to belong to a class, all functions of the class must be provided
for this type.<li><p>In this particular example of type class, the type <code class=verbatim>m</code> must be a type that takes an argument. For
example <code class=verbatim>IO a</code>, but also <code class=verbatim>Maybe a</code>, <code class=verbatim>[a]</code>,
etc…<li><p>To be a useful monad, your function must obey some rules. If your
construction does not obey these rules strange things might happens:<div class=sourceCode id=cb182><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb182-1><a href=#cb182-1 aria-hidden=true tabindex=-1></a><span class=fu>return</span> a <span class=op>&gt;&gt;=</span> k  <span class=op>==</span>  k a</span>
<span id=cb182-2><a href=#cb182-2 aria-hidden=true tabindex=-1></a>m <span class=op>&gt;&gt;=</span> <span class=fu>return</span>  <span class=op>==</span>  m</span>
<span id=cb182-3><a href=#cb182-3 aria-hidden=true tabindex=-1></a>m <span class=op>&gt;&gt;=</span> (\x <span class=ot>-&gt;</span> k x <span class=op>&gt;&gt;=</span> h)  <span class=op>==</span>  (m <span class=op>&gt;&gt;=</span> k) <span class=op>&gt;&gt;=</span> h</span></code></pre></div><li><p>Furthermore the <code class=verbatim>Monad</code> and <code class=verbatim>Applicative</code> operations should relate as
follow:<div class=sourceCode id=cb183><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb183-1><a href=#cb183-1 aria-hidden=true tabindex=-1></a><span class=fu>pure</span> <span class=ot>=</span> <span class=fu>return</span></span>
<span id=cb183-2><a href=#cb183-2 aria-hidden=true tabindex=-1></a>(<span class=op>&lt;*&gt;</span>) <span class=ot>=</span> ap</span></code></pre></div><p>The above laws imply:<div class=sourceCode id=cb184><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb184-1><a href=#cb184-1 aria-hidden=true tabindex=-1></a><span class=fu>fmap</span> f xs <span class=ot>=</span> xs <span class=op>&gt;&gt;=</span> <span class=fu>return</span> <span class=op>.</span> f</span>
<span id=cb184-2><a href=#cb184-2 aria-hidden=true tabindex=-1></a>(<span class=op>&gt;&gt;</span>) <span class=ot>=</span> (<span class=op>*&gt;</span>)</span></code></pre></div></ul></blockquote><h3 id=monad-intuition>Monad Intuition</h3><p>I explained how to use the IO Monad. In the previous chapter I
explained how it works behind the scene. Notice there is a huge
difference between be a client of the Monad API and be an architect of
the Monad API but also have an intuition about what is really a
Monad.<p>So to try to give you an intuition, just remember a Monad is a
construction that has to do with <em>composition</em> into higher order
type constructors (types with a parameter). So if we consider
<code>(&lt;=&lt;)</code> and <code>(>=>)</code> (Kleisli arrow
composition) which are defined (simplified for the purpose of this
article) as<div class=sourceCode id=cb185><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb185-1><a href=#cb185-1 aria-hidden=true tabindex=-1></a>f <span class=op>&gt;=&gt;</span> g <span class=ot>=</span> \x <span class=ot>-&gt;</span> f x <span class=op>&gt;&gt;=</span> g</span>
<span id=cb185-2><a href=#cb185-2 aria-hidden=true tabindex=-1></a>g <span class=op>&lt;=&lt;</span> f <span class=ot>=</span> f <span class=op>&gt;=&gt;</span> g</span></code></pre></div><p>Those operation constructed with the bind operator
<code>(>>=)</code> are a generalisation of <code>(.)</code> and
<code>(>>>)</code> where <code>f >>> g = g . f</code>.
If you can look at the type this become visible, simply compare:<div class=sourceCode id=cb186><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb186-1><a href=#cb186-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> a <span class=ot>-&gt;</span> b</span>
<span id=cb186-2><a href=#cb186-2 aria-hidden=true tabindex=-1></a><span class=ot>g ::</span> b <span class=ot>-&gt;</span> c</span>
<span id=cb186-3><a href=#cb186-3 aria-hidden=true tabindex=-1></a>g <span class=op>.</span><span class=ot> f ::</span> a <span class=ot>-&gt;</span> c</span>
<span id=cb186-4><a href=#cb186-4 aria-hidden=true tabindex=-1></a>f <span class=op>&gt;&gt;&gt;</span><span class=ot> g ::</span> a <span class=ot>-&gt;</span> c</span></code></pre></div><p>with<div class=sourceCode id=cb187><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb187-1><a href=#cb187-1 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> a <span class=ot>-&gt;</span> m b</span>
<span id=cb187-2><a href=#cb187-2 aria-hidden=true tabindex=-1></a><span class=ot>g ::</span> b <span class=ot>-&gt;</span> m c</span>
<span id=cb187-3><a href=#cb187-3 aria-hidden=true tabindex=-1></a>g <span class=op>&lt;=&lt;</span><span class=ot> f ::</span> a <span class=ot>-&gt;</span> m c</span>
<span id=cb187-4><a href=#cb187-4 aria-hidden=true tabindex=-1></a>f <span class=op>&gt;=&gt;</span><span class=ot> g ::</span> a <span class=ot>-&gt;</span> m c</span></code></pre></div><p>As I said, this is a generalisation of the composition operation to
functions that returns types within a higher order type constructor.<p>To give you better example, consider:<ul><li><p><code>m = []</code>; <code>[]</code> is a higher order type
constructor as it takes a type parameter, the <em>kind</em> of this type
is <code>* -> *</code>. So if values have types, types have
<em>kinds</em>. You can see them in <code class=verbatim>ghci</code>:<pre class=example><code>[hs:hsenv]&gt; ghci
GHCi, version 8.6.5: http://www.haskell.org/ghc/  :? for help
Prelude&gt; :kind Int
Int :: *
Prelude&gt; :kind []
[] :: * -&gt; *
</code></pre><p>We see that the kind of <code class=verbatim>Int</code> is <code class=verbatim>*</code> so, it is a monotype, but the kind of <code class=verbatim>[]</code> is <code class=verbatim>* -> *</code> so
it takes one type parameter.<li><p><code>a</code>, <code>b</code> to be <code>Int</code> and
<code>c</code> to be <code>String</code><li><p><code>f n = [n, n+1]</code><li><p><code>g n = [show n,">"++show (n+1)]</code></ul><p>So<div class=sourceCode id=cb189><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb189-1><a href=#cb189-1 aria-hidden=true tabindex=-1></a>f <span class=dv>2</span> <span class=ot>=</span> [<span class=dv>2</span>,<span class=dv>3</span>]</span>
<span id=cb189-2><a href=#cb189-2 aria-hidden=true tabindex=-1></a>g <span class=dv>2</span> <span class=ot>=</span> [<span class=st>&quot;2&quot;</span>,<span class=st>&quot;&gt;3&quot;</span>]</span>
<span id=cb189-3><a href=#cb189-3 aria-hidden=true tabindex=-1></a>g <span class=dv>3</span> <span class=ot>=</span> [<span class=st>&quot;3&quot;</span>,<span class=st>&quot;&gt;4&quot;</span>]</span></code></pre></div><p>One would expect to <em>combine</em> <code>f</code> and
<code>g</code> such that
<code>(combine f g) 0 ⇒ ["2",">3","3",">4"]</code>. Unfortunately
<code>(.)</code> will not work directly and this would be cumbersome to
write. But thanks to the Monad abstraction we can write:<div class=sourceCode id=cb190><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb190-1><a href=#cb190-1 aria-hidden=true tabindex=-1></a>(f <span class=op>&gt;=&gt;</span> g) <span class=dv>2</span> ⇒ [<span class=st>&quot;2&quot;</span>,<span class=st>&quot;&gt;3&quot;</span>,<span class=st>&quot;3&quot;</span>,<span class=st>&quot;&gt;4&quot;</span>]</span></code></pre></div><div class=sourceCode id=cb191 data-tangle=monad_composition.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb191-1><a href=#cb191-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Control.Monad</span> ((&gt;=&gt;))</span>
<span id=cb191-2><a href=#cb191-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb191-3><a href=#cb191-3 aria-hidden=true tabindex=-1></a><span class=ot>f ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> [<span class=dt>Int</span>]</span>
<span id=cb191-4><a href=#cb191-4 aria-hidden=true tabindex=-1></a>f n <span class=ot>=</span> [n, n<span class=op>+</span><span class=dv>1</span>]</span>
<span id=cb191-5><a href=#cb191-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb191-6><a href=#cb191-6 aria-hidden=true tabindex=-1></a><span class=ot>g ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> [<span class=dt>String</span>]</span>
<span id=cb191-7><a href=#cb191-7 aria-hidden=true tabindex=-1></a>g n <span class=ot>=</span> [<span class=fu>show</span> n,<span class=st>&quot;&gt;&quot;</span><span class=op>++</span><span class=fu>show</span> (n<span class=op>+</span><span class=dv>1</span>)]</span>
<span id=cb191-8><a href=#cb191-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb191-9><a href=#cb191-9 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=fu>print</span> <span class=op>$</span> (f <span class=op>&gt;=&gt;</span> g) <span class=dv>2</span></span></code></pre></div><p>The next chapters are simply about providing some examples of useful
Monads.<h3 id=maybe-is-a-monad>Maybe is a monad</h3><p>There are a lot of different types that are instances of <code class=verbatim>Monad</code>. One of the easiest to describe is <code class=verbatim>Maybe</code>. If you have a sequence of <code class=verbatim>Maybe</code> values, you can use monads to manipulate
them. It is particularly useful to remove very deep <code class=verbatim>if..then..else..</code> constructions.<p>Imagine a complex bank operation. You are eligible to gain about 700€
only if you can afford to follow a list of operations without your
balance dipping below zero.<div class=sourceCode id=cb192 data-tangle=maybe_monad_1.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb192-1><a href=#cb192-1 aria-hidden=true tabindex=-1></a>deposit  value account <span class=ot>=</span> account <span class=op>+</span> value</span>
<span id=cb192-2><a href=#cb192-2 aria-hidden=true tabindex=-1></a>withdraw value account <span class=ot>=</span> account <span class=op>-</span> value</span>
<span id=cb192-3><a href=#cb192-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb192-4><a href=#cb192-4 aria-hidden=true tabindex=-1></a><span class=ot>eligible ::</span> (<span class=dt>Num</span> a,<span class=dt>Ord</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Bool</span></span>
<span id=cb192-5><a href=#cb192-5 aria-hidden=true tabindex=-1></a>eligible account <span class=ot>=</span></span>
<span id=cb192-6><a href=#cb192-6 aria-hidden=true tabindex=-1></a>  <span class=kw>let</span> account1 <span class=ot>=</span> deposit <span class=dv>100</span> account <span class=kw>in</span></span>
<span id=cb192-7><a href=#cb192-7 aria-hidden=true tabindex=-1></a>    <span class=kw>if</span> (account1 <span class=op>&lt;</span> <span class=dv>0</span>)</span>
<span id=cb192-8><a href=#cb192-8 aria-hidden=true tabindex=-1></a>    <span class=kw>then</span> <span class=dt>False</span></span>
<span id=cb192-9><a href=#cb192-9 aria-hidden=true tabindex=-1></a>    <span class=kw>else</span></span>
<span id=cb192-10><a href=#cb192-10 aria-hidden=true tabindex=-1></a>      <span class=kw>let</span> account2 <span class=ot>=</span> withdraw <span class=dv>200</span> account1 <span class=kw>in</span></span>
<span id=cb192-11><a href=#cb192-11 aria-hidden=true tabindex=-1></a>      <span class=kw>if</span> (account2 <span class=op>&lt;</span> <span class=dv>0</span>)</span>
<span id=cb192-12><a href=#cb192-12 aria-hidden=true tabindex=-1></a>      <span class=kw>then</span> <span class=dt>False</span></span>
<span id=cb192-13><a href=#cb192-13 aria-hidden=true tabindex=-1></a>      <span class=kw>else</span></span>
<span id=cb192-14><a href=#cb192-14 aria-hidden=true tabindex=-1></a>        <span class=kw>let</span> account3 <span class=ot>=</span> deposit <span class=dv>100</span> account2 <span class=kw>in</span></span>
<span id=cb192-15><a href=#cb192-15 aria-hidden=true tabindex=-1></a>        <span class=kw>if</span> (account3 <span class=op>&lt;</span> <span class=dv>0</span>)</span>
<span id=cb192-16><a href=#cb192-16 aria-hidden=true tabindex=-1></a>        <span class=kw>then</span> <span class=dt>False</span></span>
<span id=cb192-17><a href=#cb192-17 aria-hidden=true tabindex=-1></a>        <span class=kw>else</span></span>
<span id=cb192-18><a href=#cb192-18 aria-hidden=true tabindex=-1></a>          <span class=kw>let</span> account4 <span class=ot>=</span> withdraw <span class=dv>300</span> account3 <span class=kw>in</span></span>
<span id=cb192-19><a href=#cb192-19 aria-hidden=true tabindex=-1></a>          <span class=kw>if</span> (account4 <span class=op>&lt;</span> <span class=dv>0</span>)</span>
<span id=cb192-20><a href=#cb192-20 aria-hidden=true tabindex=-1></a>          <span class=kw>then</span> <span class=dt>False</span></span>
<span id=cb192-21><a href=#cb192-21 aria-hidden=true tabindex=-1></a>          <span class=kw>else</span></span>
<span id=cb192-22><a href=#cb192-22 aria-hidden=true tabindex=-1></a>            <span class=kw>let</span> account5 <span class=ot>=</span> deposit <span class=dv>1000</span> account4 <span class=kw>in</span></span>
<span id=cb192-23><a href=#cb192-23 aria-hidden=true tabindex=-1></a>            <span class=kw>if</span> (account5 <span class=op>&lt;</span> <span class=dv>0</span>)</span>
<span id=cb192-24><a href=#cb192-24 aria-hidden=true tabindex=-1></a>            <span class=kw>then</span> <span class=dt>False</span></span>
<span id=cb192-25><a href=#cb192-25 aria-hidden=true tabindex=-1></a>            <span class=kw>else</span></span>
<span id=cb192-26><a href=#cb192-26 aria-hidden=true tabindex=-1></a>              <span class=dt>True</span></span>
<span id=cb192-27><a href=#cb192-27 aria-hidden=true tabindex=-1></a></span>
<span id=cb192-28><a href=#cb192-28 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb192-29><a href=#cb192-29 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> eligible <span class=dv>300</span> <span class=co>-- True</span></span>
<span id=cb192-30><a href=#cb192-30 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> eligible <span class=dv>299</span> <span class=co>-- False</span></span></code></pre></div><p>Now, let's make it better using Maybe and the fact that it is a
Monad.<div class=sourceCode id=cb193 data-tangle=maybe_monad_2.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb193-1><a href=#cb193-1 aria-hidden=true tabindex=-1></a><span class=ot>deposit ::</span> (<span class=dt>Num</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a</span>
<span id=cb193-2><a href=#cb193-2 aria-hidden=true tabindex=-1></a>deposit value account <span class=ot>=</span> <span class=dt>Just</span> (account <span class=op>+</span> value)</span>
<span id=cb193-3><a href=#cb193-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb193-4><a href=#cb193-4 aria-hidden=true tabindex=-1></a><span class=ot>withdraw ::</span> (<span class=dt>Num</span> a,<span class=dt>Ord</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a</span>
<span id=cb193-5><a href=#cb193-5 aria-hidden=true tabindex=-1></a>withdraw value account <span class=ot>=</span> <span class=kw>if</span> (account <span class=op>&lt;</span> value)</span>
<span id=cb193-6><a href=#cb193-6 aria-hidden=true tabindex=-1></a>                         <span class=kw>then</span> <span class=dt>Nothing</span></span>
<span id=cb193-7><a href=#cb193-7 aria-hidden=true tabindex=-1></a>                         <span class=kw>else</span> <span class=dt>Just</span> (account <span class=op>-</span> value)</span>
<span id=cb193-8><a href=#cb193-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb193-9><a href=#cb193-9 aria-hidden=true tabindex=-1></a><span class=ot>eligible ::</span> (<span class=dt>Num</span> a, <span class=dt>Ord</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Bool</span></span>
<span id=cb193-10><a href=#cb193-10 aria-hidden=true tabindex=-1></a>eligible account <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb193-11><a href=#cb193-11 aria-hidden=true tabindex=-1></a>  account1 <span class=ot>&lt;-</span> deposit <span class=dv>100</span> account</span>
<span id=cb193-12><a href=#cb193-12 aria-hidden=true tabindex=-1></a>  account2 <span class=ot>&lt;-</span> withdraw <span class=dv>200</span> account1</span>
<span id=cb193-13><a href=#cb193-13 aria-hidden=true tabindex=-1></a>  account3 <span class=ot>&lt;-</span> deposit <span class=dv>100</span> account2</span>
<span id=cb193-14><a href=#cb193-14 aria-hidden=true tabindex=-1></a>  account4 <span class=ot>&lt;-</span> withdraw <span class=dv>300</span> account3</span>
<span id=cb193-15><a href=#cb193-15 aria-hidden=true tabindex=-1></a>  account5 <span class=ot>&lt;-</span> deposit <span class=dv>1000</span> account4</span>
<span id=cb193-16><a href=#cb193-16 aria-hidden=true tabindex=-1></a>  <span class=dt>Just</span> <span class=dt>True</span></span>
<span id=cb193-17><a href=#cb193-17 aria-hidden=true tabindex=-1></a></span>
<span id=cb193-18><a href=#cb193-18 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb193-19><a href=#cb193-19 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> eligible <span class=dv>300</span> <span class=co>-- Just True</span></span>
<span id=cb193-20><a href=#cb193-20 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> eligible <span class=dv>299</span> <span class=co>-- Nothing</span></span></code></pre></div><p>Not bad, but we can make it even better:<div class=sourceCode id=cb194 data-tangle=maybe_monad_3.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb194-1><a href=#cb194-1 aria-hidden=true tabindex=-1></a><span class=ot>deposit ::</span> (<span class=dt>Num</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a</span>
<span id=cb194-2><a href=#cb194-2 aria-hidden=true tabindex=-1></a>deposit value account <span class=ot>=</span> <span class=dt>Just</span> (account <span class=op>+</span> value)</span>
<span id=cb194-3><a href=#cb194-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb194-4><a href=#cb194-4 aria-hidden=true tabindex=-1></a><span class=ot>withdraw ::</span> (<span class=dt>Num</span> a,<span class=dt>Ord</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> a</span>
<span id=cb194-5><a href=#cb194-5 aria-hidden=true tabindex=-1></a>withdraw value account <span class=ot>=</span> <span class=kw>if</span> (account <span class=op>&lt;</span> value) </span>
<span id=cb194-6><a href=#cb194-6 aria-hidden=true tabindex=-1></a>                         <span class=kw>then</span> <span class=dt>Nothing</span> </span>
<span id=cb194-7><a href=#cb194-7 aria-hidden=true tabindex=-1></a>                         <span class=kw>else</span> <span class=dt>Just</span> (account <span class=op>-</span> value)</span>
<span id=cb194-8><a href=#cb194-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb194-9><a href=#cb194-9 aria-hidden=true tabindex=-1></a><span class=ot>eligible ::</span> (<span class=dt>Num</span> a, <span class=dt>Ord</span> a) <span class=ot>=&gt;</span> a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> <span class=dt>Bool</span></span>
<span id=cb194-10><a href=#cb194-10 aria-hidden=true tabindex=-1></a>eligible account <span class=ot>=</span></span>
<span id=cb194-11><a href=#cb194-11 aria-hidden=true tabindex=-1></a>  deposit <span class=dv>100</span> account <span class=op>&gt;&gt;=</span></span>
<span id=cb194-12><a href=#cb194-12 aria-hidden=true tabindex=-1></a>  withdraw <span class=dv>200</span> <span class=op>&gt;&gt;=</span></span>
<span id=cb194-13><a href=#cb194-13 aria-hidden=true tabindex=-1></a>  deposit <span class=dv>100</span>  <span class=op>&gt;&gt;=</span></span>
<span id=cb194-14><a href=#cb194-14 aria-hidden=true tabindex=-1></a>  withdraw <span class=dv>300</span> <span class=op>&gt;&gt;=</span></span>
<span id=cb194-15><a href=#cb194-15 aria-hidden=true tabindex=-1></a>  deposit <span class=dv>1000</span> <span class=op>&gt;&gt;</span></span>
<span id=cb194-16><a href=#cb194-16 aria-hidden=true tabindex=-1></a>  <span class=fu>return</span> <span class=dt>True</span></span>
<span id=cb194-17><a href=#cb194-17 aria-hidden=true tabindex=-1></a></span>
<span id=cb194-18><a href=#cb194-18 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb194-19><a href=#cb194-19 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> eligible <span class=dv>300</span> <span class=co>-- Just True</span></span>
<span id=cb194-20><a href=#cb194-20 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> <span class=op>$</span> eligible <span class=dv>299</span> <span class=co>-- Nothing</span></span></code></pre></div><p>We have proven that Monads are a good way to make our code more
elegant. Note this idea of code organization, in particular for <code class=verbatim>Maybe</code> can be used in most imperative languages.
In fact, this is the kind of construction we make naturally.<blockquote><p>An important remark:<p>The first element in the sequence being evaluated to <code class=verbatim>Nothing</code> will stop the complete evaluation. This
means you don't execute all lines. You get this for free, thanks to
laziness.</blockquote><p>You could also replay these example with the definition of
<code>(>>=)</code> for <code class=verbatim>Maybe</code> in
mind:<div class=sourceCode id=cb195><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb195-1><a href=#cb195-1 aria-hidden=true tabindex=-1></a><span class=kw>instance</span> <span class=dt>Monad</span> <span class=dt>Maybe</span> <span class=kw>where</span></span>
<span id=cb195-2><a href=#cb195-2 aria-hidden=true tabindex=-1></a><span class=ot>    (&gt;&gt;=) ::</span> <span class=dt>Maybe</span> a <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>Maybe</span> b) <span class=ot>-&gt;</span> <span class=dt>Maybe</span> b</span>
<span id=cb195-3><a href=#cb195-3 aria-hidden=true tabindex=-1></a>    <span class=dt>Nothing</span>  <span class=op>&gt;&gt;=</span> _  <span class=ot>=</span> <span class=dt>Nothing</span></span>
<span id=cb195-4><a href=#cb195-4 aria-hidden=true tabindex=-1></a>    (<span class=dt>Just</span> x) <span class=op>&gt;&gt;=</span> f  <span class=ot>=</span> f x</span>
<span id=cb195-5><a href=#cb195-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb195-6><a href=#cb195-6 aria-hidden=true tabindex=-1></a>    <span class=fu>return</span> x <span class=ot>=</span> <span class=dt>Just</span> x</span></code></pre></div><p>The <code class=verbatim>Maybe</code> monad proved to be useful
while being a very simple example. We saw the utility of the <code class=verbatim>IO</code> monad. But now for a cooler example,
lists.<h3 id=the-list-monad>The list monad</h3><figure><img src=./golconde.jpg.webp alt="Golconde de Magritte"><figcaption aria-hidden=true>Golconde de Magritte</figcaption></figure><p>The list monad helps us to simulate non-deterministic computations.
Here we go:<div class=sourceCode id=cb196 data-tangle=list_monad.hs><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb196-1><a href=#cb196-1 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Control.Monad</span> (guard)</span>
<span id=cb196-2><a href=#cb196-2 aria-hidden=true tabindex=-1></a></span>
<span id=cb196-3><a href=#cb196-3 aria-hidden=true tabindex=-1></a>allCases <span class=ot>=</span> [<span class=dv>1</span><span class=op>..</span><span class=dv>10</span>]</span>
<span id=cb196-4><a href=#cb196-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb196-5><a href=#cb196-5 aria-hidden=true tabindex=-1></a><span class=ot>resolve ::</span> [(<span class=dt>Int</span>,<span class=dt>Int</span>,<span class=dt>Int</span>)]</span>
<span id=cb196-6><a href=#cb196-6 aria-hidden=true tabindex=-1></a>resolve <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb196-7><a href=#cb196-7 aria-hidden=true tabindex=-1></a>              x <span class=ot>&lt;-</span> allCases</span>
<span id=cb196-8><a href=#cb196-8 aria-hidden=true tabindex=-1></a>              y <span class=ot>&lt;-</span> allCases</span>
<span id=cb196-9><a href=#cb196-9 aria-hidden=true tabindex=-1></a>              z <span class=ot>&lt;-</span> allCases</span>
<span id=cb196-10><a href=#cb196-10 aria-hidden=true tabindex=-1></a>              guard <span class=op>$</span> <span class=dv>4</span><span class=op>*</span>x <span class=op>+</span> <span class=dv>2</span><span class=op>*</span>y <span class=op>&lt;</span> z</span>
<span id=cb196-11><a href=#cb196-11 aria-hidden=true tabindex=-1></a>              <span class=fu>return</span> (x,y,z)</span>
<span id=cb196-12><a href=#cb196-12 aria-hidden=true tabindex=-1></a></span>
<span id=cb196-13><a href=#cb196-13 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb196-14><a href=#cb196-14 aria-hidden=true tabindex=-1></a>  <span class=fu>print</span> resolve</span></code></pre></div><p>MA. GIC. :<pre class=example><code>[(1,1,7),(1,1,8),(1,1,9),(1,1,10),(1,2,9),(1,2,10)]
</code></pre><p>For the list monad, there is also this syntactic sugar (à la
Python):<div class=sourceCode id=cb198><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb198-1><a href=#cb198-1 aria-hidden=true tabindex=-1></a><span class=fu>print</span> <span class=op>$</span> [ (x,y,z) <span class=op>|</span> x <span class=ot>&lt;-</span> allCases,</span>
<span id=cb198-2><a href=#cb198-2 aria-hidden=true tabindex=-1></a>                    y <span class=ot>&lt;-</span> allCases,</span>
<span id=cb198-3><a href=#cb198-3 aria-hidden=true tabindex=-1></a>                    z <span class=ot>&lt;-</span> allCases,</span>
<span id=cb198-4><a href=#cb198-4 aria-hidden=true tabindex=-1></a>                    <span class=dv>4</span><span class=op>*</span>x <span class=op>+</span> <span class=dv>2</span><span class=op>*</span>y <span class=op>&lt;</span> z ]</span></code></pre></div><p>I won't list all the monads, since there are many of them. Using
monads simplifies the manipulation of several notions in pure languages.
In particular, monads are very useful for:<ul><li>IO,<li>non-deterministic computation,<li>generating pseudo random numbers,<li>keeping configuration state,<li>writing state,<li>…</ul><p>If you have followed me until here, then you've done it! You know
monads<a href=#fn7 class=footnote-ref id=fnref7 role=doc-noteref><sup>7</sup></a>!<h1 id=start-swimming>Start swimming</h1><p>If you come this far, you can really congratulate yourself. This is
already what I would personnaly call a tremendous achievement.<p>This chapter will focus on how to build applications with Haskell.
How to use libraries inside your project.<p>Note application development is easier to introduce than library
development. Mostly because dependency management will be a lot
easier.<p>I first intended to provide a lot more informations about how to
create a project and provide a few project examples. But it occurs this
is harder than I first expected. So I will just provide the introduction
about how to create a starting point with many pointers for other
possible options.<h2 id=start-a-new-project>Start a new project</h2><p>There are multiple starting options to create a new project. The most
common one is certainly to use <code class=verbatim>cabal-install</code>. Another popular option is to use
<code class=verbatim>stack</code>. <code class=verbatim>stack</code>
adds a layer on top of <code class=verbatim>cabal-install</code> and
uses fixed set of libraries known to compile together. Another method is
to <code class=verbatim>nix</code> to handle the dependencies and use
<code class=verbatim>cabal-install</code> for the rest. That final
choice is often considered as the most complex and difficult for
beginners. Still this is the one I find the most elegant. This is the
method I will use in this article.<p>Still, you shall not be intimidated. Look:<ul><li>To create a new project the steps will be:<ol><li>run <code class=verbatim>nix-shell</code> (to have <code class=verbatim>cabal</code> executable in your PATH)<li>run <code class=verbatim>cabal install -i</code> and answer a few
questions<li>copy a few <code class=verbatim>.nix</code> files in your project
directory<li>run another <code class=verbatim>nix-shell</code> in your new
directory this time to enter in the local dev env of your new
project.</ol><li>To add a new library:<ol><li>Just add it in the <code class=verbatim>.cabal</code> file, and
enter again in your <code class=verbatim>nix-shell</code>.</ol></ul><p>I will just walk you through all the steps in detail. And mostly I
will tell you not to take care about most warning messages. For our
end-goal, those are mostly noise. I am aware of the level of complexity
that it looks like at first. But really most of the apparent complexity
is due to poor naming convention and not to any fundenmental core
difficulty.<h3 id=bootstrap-a-project-template-files>Bootstrap a project template
files</h3><ol><li>put the <a href=shell.nix>shell.nix</a> file in some
directory<li>start <code class=verbatim>nix-shell --pure</code><li>in the nix shell create a new directory and then<li><code class=verbatim>cabal init -i</code><li>You should use the default value for most questions except:<ol><li>Should I generate a simple project with sensible defaults? [default:
y] n<li>the package should build "Library AND Executable" (choice 3)<li>Cabal specification 2.4 (choice 4)<li>Application directory choose <code class=verbatim>app</code>
(choice 3)<li>Library directory choose <code class=verbatim>lib</code> (choice
3)<li>Add informative comments, choose yes.</ol></ol><p>Here is a full interaction:<pre><code>~/dev/hsenv&gt; nix-shell

[hs:hsenv]&gt; mkdir my-app

[hs:hsenv]&gt; cd my-app/

[hs:my-app]&gt; cabal init -i
Warning: The package list for &#39;hackage.haskell.org&#39; does not exist. Run &#39;cabal
update&#39; to download it.
Should I generate a simple project with sensible defaults? [default: y] n
What does the package build:
   1) Executable
   2) Library
   3) Library and Executable
Your choice? 3
What is the main module of the executable:
 * 1) Main.hs (does not yet exist, but will be created)
   2) Main.lhs (does not yet exist, but will be created)
   3) Other (specify)
Your choice? [default: Main.hs (does not yet exist, but will be created)]
Please choose version of the Cabal specification to use:
 * 1) 1.10   (legacy)
   2) 2.0    (+ support for Backpack, internal sub-libs, &#39;^&gt;=&#39; operator)
   3) 2.2    (+ support for &#39;common&#39;, &#39;elif&#39;, redundant commas, SPDX)
   4) 2.4    (+ support for &#39;**&#39; globbing)
Your choice? [default: 1.10   (legacy)] 4
Package name? [default: my-app]
Package version? [default: 0.1.0.0]
Please choose a license:
   1) GPL-2.0-only
   2) GPL-3.0-only
   3) LGPL-2.1-only
   4) LGPL-3.0-only
   5) AGPL-3.0-only
   6) BSD-2-Clause
 * 7) BSD-3-Clause
   8) MIT
   9) ISC
  10) MPL-2.0
  11) Apache-2.0
  12) LicenseRef-PublicDomain
  13) NONE
  14) Other (specify)
Your choice? [default: BSD-3-Clause]
Author name? [default: Yann Esposito (Yogsototh)]
Maintainer email? [default: yann.esposito@gmail.com]
Project homepage URL?
Project synopsis?
Project category:
 * 1) (none)
   2) Codec
   3) Concurrency
   4) Control
   5) Data
   6) Database
   7) Development
   8) Distribution
   9) Game
  10) Graphics
  11) Language
  12) Math
  13) Network
  14) Sound
  15) System
  16) Testing
  17) Text
  18) Web
  19) Other (specify)
Your choice? [default: (none)]
Application (Main.hs) directory:
 * 1) (none)
   2) src-exe
   3) app
   4) Other (specify)
Your choice? [default: (none)] 3
Library source directory:
 * 1) (none)
   2) src
   3) lib
   4) src-lib
   5) Other (specify)
Your choice? [default: (none)] 2
Should I generate a test suite for the library? [default: y]
Test directory:
 * 1) test
   2) Other (specify)
Your choice? [default: test]
What base language is the package written in:
 * 1) Haskell2010
   2) Haskell98
   3) Other (specify)
Your choice? [default: Haskell2010]
Add informative comments to each field in the cabal file (y/n)? [default: n] y

Guessing dependencies...

Generating LICENSE...
Generating Setup.hs...
Generating CHANGELOG.md...
Generating src/MyLib.hs...
Generating app/Main.hs...
Generating test/MyLibTest.hs...
Generating my-app.cabal...

Warning: no synopsis given. You should edit the .cabal file and add one.
You may want to edit the .cabal file and add a Description field.

[hs:my-app]&gt;
</code></pre><div class=notes><p>Please ignore the following warning:<pre class=example><code>Warning: The package list for &#39;hackage.haskell.org&#39; does not exist. Run &#39;cabal
update&#39; to download it.
</code></pre><p>Nix should take care of handling Haskell libraries not <code class=verbatim>cabal-install</code>. No need to run <code class=verbatim>cabal update</code>.</div><p>After this step you should end up with the following set of
files:<pre class=example><code>[hs:my-app]&gt; tree
.
├── CHANGELOG.md
├── LICENSE
├── Setup.hs
├── app
│   └── Main.hs
├── src
│   └── MyLib.hs
├── my-app.cabal
└── test
    └── MyLibTest.hs

3 directories, 7 files
</code></pre><h3 id=create-a-few-nix-files>Create a few nix files</h3><div class=notes><p>The goal of this tutorial is not to make you learn <code class=verbatim>nix</code> because it is a bit complex, but to explain
you a bit, <code class=verbatim>nix</code> use a a <em>configuration
language</em> and not just a <em>configuration format</em>. So to
configure your <code class=verbatim>nix</code> environment you endup
writing a <em>nix expression</em> in this <em>nix language</em>. And
thus you can call the content of one nix-file in another one for
example, or use variables.</div><p>The first file to create is the one that will pin the versions of all
your packages and libraries:<div class=sourceCode id=cb202 data-tangle=my-app/nixpkgs.nix data-mkdirp=t><pre class="sourceCode nix"><code class="sourceCode nix"><span id=cb202-1><a href=#cb202-1 aria-hidden=true tabindex=-1></a><span class=bu>import</span> <span class=op>(</span><span class=bu>fetchTarball</span> <span class=va>https</span><span class=op>://</span><span class=ss>github.com/NixOS/nixpkgs/archive/19.09.tar.gz</span><span class=op>)</span> <span class=op>{}</span></span></code></pre></div><p>The second file is the <code class=verbatim>default.nix</code>
file:<div class=sourceCode id=cb203 data-tangle=my-app/default.nix data-mkdirp=t><pre class="sourceCode nix"><code class="sourceCode nix"><span id=cb203-1><a href=#cb203-1 aria-hidden=true tabindex=-1></a><span class=op>{</span> <span class=va>nixpkgs</span> <span class=op>?</span> <span class=bu>import</span> <span class=ss>./nixpkgs.nix</span></span>
<span id=cb203-2><a href=#cb203-2 aria-hidden=true tabindex=-1></a><span class=op>,</span> <span class=va>compiler</span> <span class=op>?</span> <span class=st>&quot;default&quot;</span></span>
<span id=cb203-3><a href=#cb203-3 aria-hidden=true tabindex=-1></a><span class=op>,</span> <span class=va>doBenchmark</span> <span class=op>?</span> <span class=cn>false</span> <span class=op>}</span>:</span>
<span id=cb203-4><a href=#cb203-4 aria-hidden=true tabindex=-1></a><span class=kw>let</span></span>
<span id=cb203-5><a href=#cb203-5 aria-hidden=true tabindex=-1></a>  <span class=va>inherit</span> (<span class=va>nixpkgs</span>) <span class=va>pkgs</span>;</span>
<span id=cb203-6><a href=#cb203-6 aria-hidden=true tabindex=-1></a>  <span class=va>name</span> <span class=op>=</span> <span class=st>&quot;my-app&quot;</span><span class=op>;</span></span>
<span id=cb203-7><a href=#cb203-7 aria-hidden=true tabindex=-1></a>  <span class=va>haskellPackages</span> <span class=op>=</span> pkgs.haskellPackages<span class=op>;</span></span>
<span id=cb203-8><a href=#cb203-8 aria-hidden=true tabindex=-1></a>  <span class=va>variant</span> <span class=op>=</span> <span class=kw>if</span> doBenchmark</span>
<span id=cb203-9><a href=#cb203-9 aria-hidden=true tabindex=-1></a>            <span class=kw>then</span> pkgs.haskell.lib.doBenchmark</span>
<span id=cb203-10><a href=#cb203-10 aria-hidden=true tabindex=-1></a>            <span class=kw>else</span> pkgs.lib.id<span class=op>;</span></span>
<span id=cb203-11><a href=#cb203-11 aria-hidden=true tabindex=-1></a>  <span class=va>drv</span> <span class=op>=</span> haskellPackages.callCabal2nix name <span class=ss>./.</span> <span class=op>{};</span></span>
<span id=cb203-12><a href=#cb203-12 aria-hidden=true tabindex=-1></a><span class=kw>in</span></span>
<span id=cb203-13><a href=#cb203-13 aria-hidden=true tabindex=-1></a><span class=op>{</span></span>
<span id=cb203-14><a href=#cb203-14 aria-hidden=true tabindex=-1></a>  <span class=va>my_project</span> <span class=op>=</span> drv<span class=op>;</span></span>
<span id=cb203-15><a href=#cb203-15 aria-hidden=true tabindex=-1></a>  <span class=va>shell</span> <span class=op>=</span> haskellPackages.shellFor <span class=op>{</span></span>
<span id=cb203-16><a href=#cb203-16 aria-hidden=true tabindex=-1></a>    <span class=co># generate hoogle doc</span></span>
<span id=cb203-17><a href=#cb203-17 aria-hidden=true tabindex=-1></a>    <span class=va>withHoogle</span> <span class=op>=</span> <span class=cn>true</span><span class=op>;</span></span>
<span id=cb203-18><a href=#cb203-18 aria-hidden=true tabindex=-1></a>    <span class=va>packages</span> <span class=op>=</span> <span class=va>p</span><span class=op>:</span> <span class=op>[</span>drv<span class=op>];</span></span>
<span id=cb203-19><a href=#cb203-19 aria-hidden=true tabindex=-1></a>    <span class=co># packages dependencies (by default haskellPackages)</span></span>
<span id=cb203-20><a href=#cb203-20 aria-hidden=true tabindex=-1></a>    <span class=va>buildInputs</span> <span class=op>=</span> <span class=kw>with</span> haskellPackages<span class=op>;</span></span>
<span id=cb203-21><a href=#cb203-21 aria-hidden=true tabindex=-1></a>      <span class=op>[</span> hlint</span>
<span id=cb203-22><a href=#cb203-22 aria-hidden=true tabindex=-1></a>        ghcid</span>
<span id=cb203-23><a href=#cb203-23 aria-hidden=true tabindex=-1></a>        cabal-install</span>
<span id=cb203-24><a href=#cb203-24 aria-hidden=true tabindex=-1></a>        cabal2nix</span>
<span id=cb203-25><a href=#cb203-25 aria-hidden=true tabindex=-1></a>        hindent</span>
<span id=cb203-26><a href=#cb203-26 aria-hidden=true tabindex=-1></a>        <span class=co># # if you want to add some system lib like ncurses</span></span>
<span id=cb203-27><a href=#cb203-27 aria-hidden=true tabindex=-1></a>        <span class=co># # you could by writing it like:</span></span>
<span id=cb203-28><a href=#cb203-28 aria-hidden=true tabindex=-1></a>        <span class=co># pkgs.ncurses</span></span>
<span id=cb203-29><a href=#cb203-29 aria-hidden=true tabindex=-1></a>      <span class=op>];</span></span>
<span id=cb203-30><a href=#cb203-30 aria-hidden=true tabindex=-1></a>    <span class=co># nice prompt for the nix-shell</span></span>
<span id=cb203-31><a href=#cb203-31 aria-hidden=true tabindex=-1></a>    <span class=va>shellHook</span> <span class=op>=</span> <span class=st>&#39;&#39;</span></span>
<span id=cb203-32><a href=#cb203-32 aria-hidden=true tabindex=-1></a><span class=st>     export PS1=&quot;\n\[[</span><span class=sc>${</span>name<span class=sc>}</span><span class=st>:\033[1;32m\]\W\[\033[0m\]]&gt; &quot;</span></span>
<span id=cb203-33><a href=#cb203-33 aria-hidden=true tabindex=-1></a><span class=st>  &#39;&#39;</span><span class=op>;</span></span>
<span id=cb203-34><a href=#cb203-34 aria-hidden=true tabindex=-1></a>  <span class=op>};</span></span>
<span id=cb203-35><a href=#cb203-35 aria-hidden=true tabindex=-1></a><span class=op>}</span></span></code></pre></div><p>It uses the <code class=verbatim>nixpkgs.nix</code> file. But also
you can configure it to enable/disable benchmarks while building your
application. I do not expect you to understand what is really going on
here, but a short explanation is this file take cares of:<ol><li>use the pinned version of nixpkgs and should provide a working set
of haskell libraries.<li>read you <code class=verbatim>.cabal</code> file and find the set
of libraries you depends on so <code class=verbatim>nix</code> will be
able to download them.<li>download a few useful packages for Haskell development, in
particular <code class=verbatim>hlint</code>, <code class=verbatim>ghcid</code>, <code class=verbatim>cabal-install</code>, <code class=verbatim>cabal2nix</code> and <code class=verbatim>hindent</code>. I will talk about those tools
later.<li>take care of handling the <code class=verbatim>nix-shell</code>
prompt so you should see the name of your project.</ol><p>The only things you should manipulate for a new fresh project should
be the <code class=verbatim>name</code> and perhaps the <code class=verbatim>buildInputs</code> list to add a few more libraries
that could be either Haskell libraries or any library <code class=verbatim>nix</code> know about (for example <code class=verbatim>ncurses</code>, in that case you should write it <code class=verbatim>pkgs.ncurses</code>).<p>The two last file simply use the <code class=verbatim>default.nix</code> file:<p>The <code class=verbatim>shell.nix</code> file:<div class=sourceCode id=cb204 data-tangle=my-app/shell.nix data-mkdirp=t><pre class="sourceCode nix"><code class="sourceCode nix"><span id=cb204-1><a href=#cb204-1 aria-hidden=true tabindex=-1></a><span class=op>(</span><span class=bu>import</span> <span class=ss>./.</span> <span class=op>{})</span>.shell</span></code></pre></div><p>And <code class=verbatim>release.nix</code>:<div class=sourceCode id=cb205 data-tangle=my-app/release.nix data-mkdirp=t><pre class="sourceCode nix"><code class="sourceCode nix"><span id=cb205-1><a href=#cb205-1 aria-hidden=true tabindex=-1></a><span class=kw>let</span></span>
<span id=cb205-2><a href=#cb205-2 aria-hidden=true tabindex=-1></a>  <span class=va>def</span> <span class=op>=</span> <span class=bu>import</span> <span class=ss>./.</span> <span class=op>{};</span></span>
<span id=cb205-3><a href=#cb205-3 aria-hidden=true tabindex=-1></a><span class=kw>in</span></span>
<span id=cb205-4><a href=#cb205-4 aria-hidden=true tabindex=-1></a> <span class=op>{</span> <span class=va>my_project</span> <span class=op>=</span> def.my_project<span class=op>;</span> <span class=op>}</span></span></code></pre></div><p>So download those files as well as this <code class=verbatim>.gitignore</code> file:<pre class=gitignore data-tangle=my-app/.gitignore data-mkdirp=t><code>dist-newstyle/
result
</code></pre><h3 id=checking-your-environment>Checking your environment</h3><p>Now you should see those files in your project:<pre class=example><code>[hs:my-app]&gt; tree
.
├── CHANGELOG.md
├── LICENSE
├── Setup.hs
├── app
│   └── Main.hs
├── default.nix
├── src
│   └── MyLib.hs
├── my-app.cabal
├── nixpkgs.nix
├── release.nix
├── shell.nix
└── test
    └── MyLibTest.hs

3 directories, 11 files
</code></pre><p>You shall now enter <code class=verbatim>nix-shell</code> again,
but in your <code class=verbatim>my-app</code> directory this
time.<pre class=example><code>[hs:my-app]&gt; nix-shell
warning: Nix search path entry &#39;/nix/var/nix/profiles/per-user/root/channels&#39; does not exist, ignoring
building &#39;/nix/store/j3hi4wm9996wfga61arc2917klfgspwr-cabal2nix-my-app.drv&#39;...
installing
warning: Nix search path entry &#39;/nix/var/nix/profiles/per-user/root/channels/nixpkgs&#39; does not exist, ignoring
warning: file &#39;nixpkgs&#39; was not found in the Nix search path (add it using $NIX_PATH or -I), at (string):1:9; will use bash from your environment

[my-app:my-app]&gt; which ghcid
/nix/store/ckps9wgbmpckxdvs42p6sqz64dfqiv35-ghcid-0.7.5-bin/bin/ghcid

[my-app:my-app]&gt; cabal run my-app
Build profile: -w ghc-8.6.5 -O1
In order, the following will be built (use -v for more details):
 - my-app-0.1.0.0 (src) (first run)
 - my-app-0.1.0.0 (exe:my-app) (first run)
Configuring library for my-app-0.1.0.0..
Preprocessing library for my-app-0.1.0.0..
Building library for my-app-0.1.0.0..
[1 of 1] Compiling MyLib            ( src/MyLib.hs, /Users/y/hsenv/my-app/dist-newstyle/build/x86_64-osx/ghc-8.6.5/my-app-0.1.0.0/build/MyLib.o )
Configuring executable &#39;my-app&#39; for my-app-0.1.0.0..
Preprocessing executable &#39;my-app&#39; for my-app-0.1.0.0..
Building executable &#39;my-app&#39; for my-app-0.1.0.0..
[1 of 1] Compiling Main             ( app/Main.hs, /Users/y/hsenv/my-app/dist-newstyle/build/x86_64-osx/ghc-8.6.5/my-app-0.1.0.0/x/my-app/build/my-app/my-app-tmp/Main.o )
Linking /Users/y/hs-env/my-app/dist-newstyle/build/x86_64-osx/ghc-8.6.5/my-app-0.1.0.0/x/my-app/build/my-app/my-app ...
Hello, Haskell!
someFunc
</code></pre><p>Great! It works! Try to run it again:<pre class=example><code>[my-app:my-app]&gt; cabal run my-app
Up to date
Hello, Haskell!
someFunc
</code></pre><p>This time, the compilation is not done again. <code class=verbatim>cabal</code> is smart enough not to repeat the
compilation again.<div class=notes><p>You could also use <code class=verbatim>nix-build</code> to compile
your app. I think this is nice to do for releases. But for development,
you should use <code class=verbatim>cabal</code>.</div><h3 id=add-a-library>Add a library</h3><div class=notes><p><abbr title="too long; didn't read">tl;dr:</abbr> do not be afraid
by the lenght of this section in fact, this is straightforward. I just
take a lot of time to go through all intermediate steps.<ol><li>add the library in the <code class=verbatim>build-depends</code>
inside your <code class=verbatim>.cabal</code> file.<li>restart <code class=verbatim>nix-shell</code> to download the new
dependencies.</ol></div><p>If you open the <code class=verbatim>my-app.cabal</code> file in an
editor you should see a <code class=verbatim>library</code> section
and and <code class=verbatim>executable my-app</code> section. In
particular for each section you can see a <code class=verbatim>build-depends</code> sub-section as this one:<pre class=cabal><code>...
library
  ...
  build-depends:       base ^&gt;=4.12.0.0
  ...
executable my-app
  ...
  build-depends:       base ^&gt;=4.12.0.0, my-app
  ...
</code></pre><div class=notes><p>The <code class=verbatim>^>=4.12.0.0</code> means that it should
use the latest non breaking version of the haskell package <code class=verbatim>base</code>. The author of the <code class=verbatim>base</code> package are responsible not to break the
API for minor releases. Haskell libs uses a 4 number versionning quite
similar to the semantic versionning scheme with just another minor
number for non visible changes. I will not argue much, but mainly,
semantic versionning and Haskell versionning are just a "right to break
things to your users".<p>I don't want to talk a lot more about this, but, it would be nice if
more people would watch this talk<a href=#fn8 class=footnote-ref id=fnref8 role=doc-noteref><sup>8</sup></a> related to
versionning.<p>If you want to know more about Haskell versionning convention: <a href=https://pvp.haskell.html>https://pvp.haskell.org</a></div><p>Add the <code class=verbatim>protolude</code> lib in the library
build-depends like this:<pre class=cabal><code>...
library
  ...
  build-depends:       base ^&gt;=4.12.0.0,
                       protolude
  ...
executable my-app
  ...
  build-depends:       base ^&gt;=4.12.0.0, my-app
  ...
</code></pre><div class=notes><p>I did not include a version constraint here. This is ok if you do not
deploy your library publicly. This would be absolutely awful if you
deploy your library publicly. So while developing a private app nobody
can see except you, nothing is wrong with this. But I would encourage
you to write those version bounds. It is sane to do that, but be warned
that your lib might rot if you want it to be part of a working set of
libs. So you might be pinged time to time to update some bounds or to
adap your code to the breaking change of a lib you are using. Do not
think too much about this. This is generally quite trivial work to do to
maintain your lib into a working lib set.</div><p>Now that you have added <code class=verbatim>protolude</code>
modify slightly the code of your app to use it. Change the code inside
<code class=verbatim>src/MyLib.hs</code>:<div class=sourceCode id=cb212 data-tangle=my-app/src/MyLib.hs data-mkdirp=t><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb212-1><a href=#cb212-1 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE NoImplicitPrelude #-}</span></span>
<span id=cb212-2><a href=#cb212-2 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id=cb212-3><a href=#cb212-3 aria-hidden=true tabindex=-1></a><span class=kw>module</span> <span class=dt>MyLib</span> (someFunc) <span class=kw>where</span></span>
<span id=cb212-4><a href=#cb212-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb212-5><a href=#cb212-5 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Protolude</span></span>
<span id=cb212-6><a href=#cb212-6 aria-hidden=true tabindex=-1></a></span>
<span id=cb212-7><a href=#cb212-7 aria-hidden=true tabindex=-1></a><span class=ot>someFunc ::</span> <span class=dt>IO</span> ()</span>
<span id=cb212-8><a href=#cb212-8 aria-hidden=true tabindex=-1></a>someFunc <span class=ot>=</span> putText <span class=st>&quot;someFunc&quot;</span></span></code></pre></div><p>Please do not try to search right now about what this change is
doing. It should work mostly as before. The goal here is just to check
that you can use another library easily.<p>So now you should get out of the <code class=verbatim>nix-shell</code> because <code class=verbatim>nix</code> dependencies changed. Generally just type
<code class=verbatim>^D</code> (<code class=verbatim>Ctrl-d</code>)
then launch <code class=verbatim>nix-shell --pure</code>.<pre class=example><code>[my-app:my-app]&gt; cabal build
Warning: The package list for &#39;hackage.haskell.org&#39; does not exist. Run &#39;cabal
update&#39; to download it.
Resolving dependencies...
cabal: Could not resolve dependencies:
[__0] trying: my-app-0.1.0.0 (user goal)
[__1] unknown package: protolude (dependency of my-app)
[__1] fail (backjumping, conflict set: my-app, protolude)
After searching the rest of the dependency tree exhaustively, these were the
goals I&#39;ve had most trouble fulfilling: my-app, protolude


[my-app:my-app]&gt; exit

[hs:my-app]&gt; nix-shell
warning: Nix search path entry &#39;/nix/var/nix/profiles/per-user/root/channels&#39; does not exist, ignoring
building &#39;/nix/store/sr4838rnmzn30j3qc5ray4i2n6n0p8pq-cabal2nix-my-app.drv&#39;...
installing

[my-app:my-app]&gt; cabal build
Build profile: -w ghc-8.6.5 -O1
In order, the following will be built (use -v for more details):
 - my-app-0.1.0.0 (lib) (file src/MyLib.hs changed)
 - my-app-0.1.0.0 (exe:my-app) (configuration changed)
Preprocessing library for my-app-0.1.0.0..
Building library for my-app-0.1.0.0..
[1 of 1] Compiling MyLib            ( src/MyLib.hs, .../my-app/dist-newstyle/build/x86_64-osx/ghc-8.6.5/my-app-0.1.0.0/build/MyLib.o )
Configuring executable &#39;my-app&#39; for my-app-0.1.0.0..
Preprocessing executable &#39;my-app&#39; for my-app-0.1.0.0..
Building executable &#39;my-app&#39; for my-app-0.1.0.0..
[1 of 1] Compiling Main             ( app/Main.hs, .../my-app/dist-newstyle/build/x86_64-osx/ghc-8.6.5/my-app-0.1.0.0/x/my-app/build/my-app/my-app-tmp/Main.o ) [MyLib changed]
Linking .../my-app/dist-newstyle/build/x86_64-osx/ghc-8.6.5/my-app-0.1.0.0/x/my-app/build/my-app/my-app ...

[my-app:my-app]&gt; cabal run my-app
Up to date
Hello, Haskell!
someFunc
</code></pre><p>Yes!<h3 id=better-defaults>Better defaults</h3><p>Some of the default values in the cabal file are not the best for a
professional and serious application development unfortunately. First,
let create a new block called <code class=verbatim>common professional-properties</code> that will help us
not repeat ourselve much and show more warning during compilation.<pre class=cabal><code>common professional-properties
  default-language: Haskell2010
  build-depends:
    base ^&gt;=4.12.0.0
  ghc-options:
    -Wall
    -Wcompat
    -Wincomplete-uni-patterns
    -Wredundant-constraints
    -Wnoncanonical-monad-instances
    -- -Werror
    -- -O2
</code></pre><p>This should then be used with import in all other sections (<code class=verbatim>library</code>, <code class=verbatim>executable</code> and <code class=verbatim>test</code>). Also add the <code class=verbatim>ghc-options</code> to enable the use of all core by
default. This might not always be a good idea. But I think this is
generally a better default for most modern application.<pre class=cabal><code>library
  import: professional-properties
  build-depends: protolude
  ...

executable my-app
  import: professional-properties
  ghc-options:
    -- enable parallelism
    -threaded
    &quot;-with-rtsopts=-N&quot;
  ...

test-suite my-app-test
  import: professional-properties
  ...
</code></pre><p>You can download the final cabal file: <a href=my-app/my-app.cabal>my-app.cabal</a><h1 id=conclusion>Conclusion</h1><p>This was a re-written fast Haskell tutorial. I will certainly
complete this with more advanced tutorial explaining how to write a few
Haskell projects.<p>Thanks for reading it.<h1 id=thanks>Thanks</h1><p>Thanks to <a href=http://reddit.com/r/haskell><code class=verbatim>/r/haskell</code></a> and <a href=http://reddit.com/r/programming><code class=verbatim>/r/programming</code></a>. Your comment were most than
welcome.<p>Particularly, I want to thank <a href=https://github.com/Emm>Emm</a> a thousand times for the time he
spent on correcting my English. Thank you man.<section id=footnotes class="footnotes footnotes-end-of-document" role=doc-endnotes><hr><ol><li id=fn1><p>Even if most recent languages try to hide them, they are
present.<a href=#fnref1 class=footnote-back role=doc-backlink>↩︎</a><li id=fn2><p>I know I'm cheating. But I will talk about
non-strictness later.<a href=#fnref2 class=footnote-back role=doc-backlink>↩︎</a><li id=fn3><p>For the brave, a more complete explanation of pattern
matching can be found <a href=http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/patterns.html>here</a>.<a href=#fnref3 class=footnote-back role=doc-backlink>↩︎</a><li id=fn4><p>Which is itself very similar to the javascript <code class=verbatim>eval</code> function, that is applied to a string
containing JSON.<a href=#fnref4 class=footnote-back role=doc-backlink>↩︎</a><li id=fn5><p>There are some <em>unsafe</em> exceptions to this rule.
But you shouldn't see such use in a real application except maybe for
debugging purposes.<a href=#fnref5 class=footnote-back role=doc-backlink>↩︎</a><li id=fn6><p>For the curious ones, the real type looks like <code class=verbatim>data IO a = IO {unIO :: State# RealWorld -> (# State# RealWorld, a #)}</code>.
All the <code class=verbatim>#</code> has to do with optimisation. I
swapped the fields in my example. But this is the basic idea. As of
today, the definition of <code class=verbatim>IO</code> is no more
visible into <code class=verbatim>base</code>. We have the following
explanation in <a href=http://hackage.haskell.html/package/base-4.12.0.0/docs/src/GHC.IO.html><code class=verbatim>GHC.IO.hs</code></a>:<blockquote><pre><code>The IO Monad is just an instance of the ST monad, where the state is
the real world.  We use the exception mechanism (in GHC.Exception) to
implement IO exceptions.

NOTE: The IO representation is deeply wired in to various parts of the
system.  The following list may or may not be exhaustive:

Compiler  - types of various primitives in PrimOp.hs

RTS       - forceIO (StgStartup.cmm)
          - catchzh_fast, (un)?blockAsyncExceptionszh_fast, raisezh_fast
            (Exception.cmm)
          - raiseAsync (RaiseAsync.c)

Prelude   - GHC.IO.hs, and several other places including
            GHC.Exception.hs.

Libraries - parts of hslibs/lang.

--SDM
</code></pre></blockquote><a href=#fnref6 class=footnote-back role=doc-backlink>↩︎</a><li id=fn7><p>Well, you'll certainly need to practice a bit to get
used to them and to understand when you can use them and create your
own. But you already made a big step in this direction.<a href=#fnref7 class=footnote-back role=doc-backlink>↩︎</a><li id=fn8><p><a href="https://www.youtube.com/watch?v=oyLBGkS5ICk">Spec-ulation Keynote
- Rich Hickey</a><a href=#fnref8 class=footnote-back role=doc-backlink>↩︎</a></ol></section></article></main><footer id=postamble class=status><div class=content><nav role=navigation><a href=/index.html>Home</a> |
<a href=/slides.html>Slides</a> |
<a href=/about-me.html>About</a>
<span class=details>(<a href=https://git.esy.fun/yogsototh>code</a>
<a href=https://espial.esy.fun/u:yogsototh>bookmarks</a>
<a href=https://espial.esy.fun/u:yogsototh/notes>notes</a>)</span> |
<a href=#logo>↑ Top ↑</a></nav></div></footer>