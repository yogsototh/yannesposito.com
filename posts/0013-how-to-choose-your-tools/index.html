<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How to choose your tools</title><meta name=author content="Yann Esposito"><meta name=description content="Modern tools tend to disappear. An app on the web will change, and could break for the worst. Quite often it is worth investing into tools with steep learning curve."><meta name=keywords content="emacs softwares"><link rel=stylesheet href=/css/y.css><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=icon href=/favicon.ico><meta name=theme-color media="(prefers-color-scheme: light)" content="#d84100"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#2E3440"><div class=main><div id=logo><a href=/><svg width="5em" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" stroke="#a3aec2" stroke-width="1" fill="#2e3440"/><circle cx="32" cy="32" r="12" stroke="#800" stroke-width="1" fill="#c20"/><circle cx="32" cy="32" r="5" stroke-width="1" stroke="#f60" fill="#fa0"/><ellipse cx="32" cy="14" rx="14" ry="8" stroke-width="0" fill="#fff"/></svg></a></div><div id=preamble class=status><div class=content><h1>How to choose your tools</h1><div class=meta><span class=yyydate>[2020-05-09 Sat]</span> on
<a href=https://her.esy.fun><span class=author>Yann Esposito</span>'s blog</a></div><div class=abstract>Modern tools tend to disappear. An app on the web will change, and could break for the worst. Quite often it is worth investing into tools with steep learning curve.</div></div></div><div id=content><p>This week I didn't take a look at HN to grab some news. And this week-end, in the morning I read those:<ul><li><a href="https://news.ycombinator.com/item?id=23102430">Zoom acquires keybase</a><li><a href="https://news.ycombinator.com/item?id=23107123">Making Emacs popular again</a><li><a href="https://news.ycombinator.com/item?id=23092904">Github Codespace</a></ul><figure><img src=Welcome-to-Halsingland.jpg.webp title="Welcome to Halsingland" alt="Midsommar Welcome" alt="Welcome to Halsingland"><figcaption aria-hidden=true>Welcome to Halsingland</figcaption></figure><p>Similar articles have existed for years on different products. What is their common point? <em>Software tooling and their potential change and disappearance</em>.<p>Across the years, too many times I saw tools disappear. By tools I mean applications, web applications, web sites. I think we can also include programming languages, control versioning tools, building tools, package manager, etc…<p>The story can be quite different. Sometimes the disappearance of a tool is positive, because I found a better one (from cvs to svn to git). But, too often, the tool simply disappears or worse downgrade its quality. I think we can find different names for those softwares:<ul><li><em>bloatware</em>: remember digg, stumbleupon, windows?<li><em>downgradeware</em>: Swagger-UI v3 (v2 is neat), reddit new redesign (looks better, but slow)<li><em>payware</em>: Useful free service ask for money now. Or cost a lot more.<li><em>crapware</em>: Stop to works, quality degrate unless you pay: Twitter streaming API?<li><em>dieware</em>: Remember Friendfeed, Google Reader™, etc…<li>etc…</ul><p>This is often quite frustrating because you lose a lot of your investment with that tool.<p>Regarding Github Codespace; the integration of VSCode™ inside GitHub™ can be even worse. This is what I would call a <em>trapware</em>.<div class=notes><p><em>trapware</em>: A software that is intended to put you inside a closed ecosystem. By slowly but surely add features that while looking great for the user at first sight will prevent interoperability with other tools.</div><p>Furthermore, the fact that Microsoft is involved give this story a taste of <a href=https://en.wikipedia.html/wiki/Embrace,_extend,_and_extinguish>Embrace, Extend and Extinguish</a>.<p>My real concern is that it could become a <em>work framework</em>. This could impose the full tooling on a lot of developers without giving them the freedom of choice.<p>For a startup CTO/CEO this GitHub™ Codespace™ could offer the following advantages:<ul><li><em>security</em>: impossible or very hard to steal the source code by a single dev.<li><em>homogeneity</em>: all dev must use the same development environment. Thus the integration of new dev is faster.<li><em>cheaper</em>: don't need to pay for a full featured, fast machine to each new developer. A less performant machine able to display an electron app will do the trick.<li><em>stats</em>: you can observe the throughput of your developers. How many commits a day, how many lines of code, etc… How much bugs involved which part of the code and thus which dev to blame? How much time the dev is typing, moving its mouse, how much copy/paste is involved, etc…</ul><p>For the single developers and open source developers this offer:<ul><li><em>homogeneity</em>: if I learn how to work in this environment, I'll be easier to recruit and I'll know how to work fast.<li><em>lower barrier to entry</em>: for an opensource repository, it will become much easier for anyone to propose a PR to fix some issue. No need to local clone the project, no need to download all the dependencies to test it locally, etc…</ul><p>But the price to pay is hidden.<figure><img src=midsommar-cry.jpg.webp alt="Midsommar Sorrow" alt="Midsommar Sorrow"><figcaption aria-hidden=true>Midsommar Sorrow</figcaption></figure><ol><li>First, you are now, not able to choose your local working environment on your machine.<li>GitHub™ can still change so much to become one of the previously mentionned <code>/.*ware/</code> you don't want to be involved with. They could forces you to pay a lot more, remove features, redesign to a bloatware, make it harder to interop with other platforms (prefer Azure to AWS etc…).<li>If everything involve machines in the cloud via the browser and via authorized plugins only. A lot of tools, features will never be allowed in this new ecosystem.<li>Surveillance on meaningless or wrong metrics about your work. Instead of being evaluated on the feature you shipped or on other higher level metrics. It will be very tempting for your bosses to find flaws in your working habits. We are already living in a world were surveillance, metrics and stats are too easy to grab about a person. And anyone involved know this is all bullshit. Human are very good to play those kind of games. So people really working hard for the best will certainly perform badly compared to other people that simply trick the system.</ol><p>So as good as Codespace can be, I think this warning is good to keep that in mind. Don't put yourself in a trap.<p>The <a href="https://news.ycombinator.com/item?id=23102430">Zoom acquires keybase</a> is just another story of a dying product. Apparently the keybase team will probably stop maintaining keybase. The idea behind keybase was pretty nice. And they filled a gap in the current open source world.<p>The last article I mentionned was <a href="https://news.ycombinator.com/item?id=23107123">Making Emacs popular again</a>. The first comment in HN was about how VSCode is easy to start with as compared to Emacs that need a lot more time to configure correctly for your needs. Yes, VSCode certainly just work and is easy to use. But Emacs is another beast. VSCode can become bad very fast, you don't control how it will evolve. The fact that this is a succesful Microsoft product does not garanty it will keep its currently quality. Emacs on the other hand is 44 year old and was designed so that it adapts to you. You are the one using libs and customizing it.<p>The argument to chose VSCode instead of Emacs look similar to me to the debate "Frameworks vs Libraries". Frameworks are easier to start with, but soon you find corner cases were you start to fight against them.<p>A Library on the other hand, is just a bunch of helpers you can use. And if you need another functionality, just make it using the libraries. But you have a lot more work to do yourself.<p>The common pattern I see during choice decision is often reducible to:<ol><li>Easy now, but less extensible and harder in the long run.<li>Harder now, but more extensible and easier in the long run.</ol><p>As a conclustion I would state that when you need to choose between different tools. Take the time to think about the investment costs. Sometime, the bit of pain in the begining is worth it. In particular if you are going to use this tool every days for many hours during the following years. If on the other hand you don't plan to use that tool much. Going with the easy option is certainly the best choice.<p>I consider Emacs to be of the 2nd option when compared to VSCode. Harder to start, but with a lot more control and potential power that you will probably never be able to get with most modern IDE/Editor. Also choosing a Free Software<a href=#fn1 class=footnote-ref id=fnref1 role=doc-noteref><sup>1</sup></a> gives you a lot more control about its future.<h2 id=post-conclusion>Post-conclusion – Emacs is awesome</h2><figure><img src=./midsommar-joy.jpg.webp alt="Midsommar Joy" alt="Midsommar Joy"><figcaption aria-hidden=true>Midsommar Joy</figcaption></figure><p>To go beyond my opinion, I'd like to share my experience with editors and emacs.<p>When I started to be serious about coding, I was taught to use vi, not vim, vi. I only knew a few survival vi commands: <code class=verbatim>i</code>, <code class=verbatim>a</code>, <code class=verbatim>dd</code> and <code class=verbatim>cw</code>. A few years later I started to use IDEs and I was thrilled. A few years forward I started to work for a company that forced me to use their shitty computers. Quite soon, I started to have wrist issues. Thus I decided to use vim again but be serious about it this time. And I saw the benefits only after a few weeks. They were tremendous. No more wrist pain. And an incredible edition power at the tip of my fingers<a href=#fn2 class=footnote-ref id=fnref2 role=doc-noteref><sup>2</sup></a>.<p>Then, I started a new job where we decided to code in Clojure. Of course Clojure being a LISP and emacs using also a LISP as script language, it sound natural to try Emacs even though I loved Vim. I started by installing spacemacs. At that time I didn't want to invest much time in learning Emacs. I just wanted to learn the tricks that will make Emacs more valuable to my work. It did after just a few days or maybe weeks. I used Emacs superficially for years. This was already quite efficient, at least as much as vim.<p>Recently I dug deeper. I heard much praise about org-mode and I became curious. I discovered why it is so great. Basic org-mode is already quite valuable. But if you dig, it starts to be awesome. Unfortunately this is a bit hard to describe how org-mode is great without really digging a bit.<p>You can think of org-mode as an extremely versatile todo-list and note taker with agenda and time tracking integration. You are in deep control of your workflow. But mainly here are a few example of usages that are really worth it:<ul><li>note taker<li>documentation; this is a far better than markdown<li>interactive document; run code inside the doc, keep track of the results<li>export to HMTL/PDF<li>time tracking<li>reminders</ul><p>Recently there is also org-roam that is a step further to make orgmode a nice place to keep track of all your knowledge in one place. You can take a look at this <a href="https://www.youtube.com/watch?v=Lg61ocfxk3c">great video</a> by Matt Williams.<p>Emacs changed my workflow by making me more productive. It improved not only my coding workflow, but my full work environment. I started with the editor, a few plugins, and slowly, I integrated more aspect of my day to day tasks in emacs. Emacs is designed to adapt to your own needs. As such it is a lot easier to automate a lot of small tasks.<p>I really love Emacs and if you want to joyfully join the Emacs users here are my advices:<p>Start by using either <a href=https://www.spacemacs.html>spacemacs</a> or <a href=https://github.com/hlissner/doom-emacs>doom-emacs</a>. It will take a few weeks to absorb vim keybindings. Slowly you'll start to learn how to configure it for your needs.<p>I really advise you to take a look at org-mode. Mastering it could change your carrier. Im my opinion <a href=https://orgmode.html>org-mode</a> alone is a good reason enough to use emacs. But there are a lot more to discover.<p>However, if you are used to tools from startups, with nice UI/UX. Almost no configuration cost. Be aware that digging in Free Softwares is a lot different. Instead of having a big bundle with everything prepared to work you you will need to take the time to configure each part of a big system separately.<p>Howevery I'm deeply convinced the investment is really worth it.<section class=footnotes role=doc-endnotes><hr><ol><li id=fn1 role=doc-endnote><p>note I said <em>free software</em> and not <em>open source</em>; c.f <a href=https://www.gnu.html/philosophy/open-source-misses-the-point.en.html>Why Open Source misses the point of Free Software</a><a href=#fnref1 class=footnote-back role=doc-backlink>↩︎</a><li id=fn2 role=doc-endnote><p><a href=http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/>Lear Vim Progressively</a> is an old "popular" blog post of mine.<a href=#fnref2 class=footnote-back role=doc-backlink>↩︎</a></ol></section></div><div id=postamble class=status><div class=content><nav><a href=/index.html>Home</a> |
<a href=/slides.html>Slides</a> |
<a href=/about-me.html>About</a>
<span class=details>(<a href=https://gitea.esy.fun/yogsototh>code</a>
<a href=https://espial.esy.fun/u:yogsototh>bookmarks</a>
<a href=https://espial.esy.fun/u:yogsototh/notes>notes</a>)</span> |
<a href=#logo>↑ Top ↑</a></nav></div></div></div>