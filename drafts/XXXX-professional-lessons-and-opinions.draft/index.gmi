# Professional Lessons and Opinions
author:  Yann Esposito
email:  yann@esposito.host
=> /files/publickey.txt gpg
date:  [2019-07-04]
keywords:  programming blog org-mode
description:  Different divagations about my experiences in the professional world of Software Developer
  ______
How to choose a programming language/paradigm to write with.
* programming is about making the program do what you want it to do.
* not much told, lot harder, and not as natural/intuitive; a program should not
  do something you do not want it to do.
* programming paradigms, functional is superior because it better fit all
  real-life scenarios.
* in Machine Learning, Kolmogorov complexity. Object Oriented is worse than
  Functional programming to represent naturally many real life problems.
What did I learned? Is it a set of specific knowledge or can we discover great
common principles?
* restart from zero, tabula rasa, what is programming?
  ______
I could talk to much about that.
But a few short written down lessons.
If you want to reach productivity and not necessarily enlightenment.
You have to stop learning and use what you know well.
And do not try to use things you don't know.
In particular, most programming languages/IDE/workflow/utils/tools have basic
and advanced features.
If your want to produce and deliver in time. Your best bet is to limit yourselves to
a minimal set of features that give you enough power of combination instead of
looking for a super generic strong solution.
Clojure for example has:
* functions
* higher-level functions
* destructuring
* defmethods
* protocols
* macros
* atoms, agents, core.async
* Java FFI
In fact, writing a fully working app you only need, basic data structure (edn) and functions.
That's it.
I was part of a team that created an advanced full featured app using only those.
No magic, just taking care of the state and not writing spaghetti code.
# How I choose
  - Functional programming is superior to imperative and object oriented
    languages
# Programming Languages Quality/Fun
* C, too low level, no higher level function, pb with portability
* Ruby, slow, concets not clean enough
* Python, C-like script, pretty efficient, but quite easy to write bad code, often slow
* Java, cumbersome, lot of boilerplate, not that bad, but bad underneath
  philosophy (try to make programming scalable by multiple user, replace coder by gears,
  in practice it is often wrong)
## Not suitable for production/ toy language
* logo
* basic
## Superior languages
Rust supersede: C, pascal, go
Clojure/Haskell supersede: Ada, C++, Eiffel, Ruby, Python
## Best choice of language depending of usage
* do something fast and dirty: zsh, perl for program shorter than 200 lines.
* very complex big software: Haskell, Clojure, Purescript, Clojurescript
* low level fast, fine grained memory control: Rust
#  LocalWords:  tabula rasa

=> /index.gmi Home
=> /gem-atom.xml Feed
=> /slides.gmi Slides
=> /about-me.gmi About

=> https://gitea.esy.fun code
=> https://espial.esy.fun/u:yogsototh bookmarks
=> https://espial.esy.fun/u:yogsototh/notes notes
