<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How I use nix</title><meta name=author content="Yann Esposito"><meta name=description content="In this article I explain how I use nix. As a brew replacement, as home environment manager, to have reproductible dev environment."><meta name=keywords content="nix programming"><link rel=stylesheet href=/css/y.css><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=icon href=/favicon.ico><div id=labels><div class=ai><span id=logo><a href=/><svg width="5em" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" stroke="var(--b2)" stroke-width="2" fill="var(--b03)"/><circle cx="32" cy="32" r="12" stroke="var(--r)" stroke-width="2" fill="var(--o)"/><circle cx="32" cy="32" r="6" stroke-width="0" fill="var(--y)"/><ellipse cx="32" cy="14" rx="14" ry="8" stroke-width="0" fill="var(--b3)"/></svg></a></span></div></div><div class=ca><div id=preamble class=an><div class=ai><h1>How I use nix</h1><div class=by><span class=yyydate>[2020-06-14 Sun]</span> on
<a href=https://her.esy.fun><span class=az>Yann Esposito</span>'s blog</a></div><div class=z>In this article I explain how I use nix. As a brew replacement, as home environment manager, to have reproductible dev environment.</div></div></div><div id=content><p>Have you ever written a small script and you update your system and this stop working? Have you copied your tool/script to another machine it doesn't work because some dependency is missing? Have you tried to sync your dotfiles to another env and there are a few details not working? Some missing dependency? If the answer is yes, then <a href=https://nixos.org/nix>nix</a> can help.<h2 id=scripts>Scripts</h2><p>Suppose you want to write a portable script. For example, the script I use to minify my CSS. Here it is:<pre class=bd><code>#!/usr/bin/env nix-shell
#!nix-shell --pure
#!nix-shell -i bash
#!nix-shell -I nixpkgs=&quot;https://github.com/NixOS/nixpkgs/archive/19.09.tar.gz&quot;
#!nix-shell -p bash minify

minify &quot;$1&quot; &gt; &quot;$2&quot;
</code></pre><p>So let's analyze each line of the header block:<dl><dt><code>#!/usr/bin/env nix-shell</code><dd>basic, use <code>nix-shell</code> to run the script.<dt><code>#!nix-shell --pure</code><dd>only use dependencies installed in this nix shell environment. A bit as if the PATH environment variable was emptied.<dt><code>#!nix-shell -i bash</code><dd>tell <code>nix-shell</code> to run <code>bash</code><dt><code>#!nix-shell -I nixpkgs="https://github.com/NixOS/nixpkgs/archive/19.09.tar.gz"</code><dd>pin the nixpkgs using this archive.<dt><code>#!nix-shell -p bash minify</code><dd>install <code>bash</code> and <code>minify</code> in the nix shell.</dl><p>Now if the script is run on a machine with <code>nix</code> installed you can be pretty sure it will work as expected. Even if I update my OS and I forget about this script for a few years. As long as I can install nix on the new system and I could download the tar file the script will be run the same way as the day I wrote it.<p><strong><strong>Remark</strong></strong>: You can use any shell (like <code>fish</code>, <code>zsh</code>) but also other languages <code>python</code>, <code>haskell</code>, etc…<h2 id=temporary-working-env>Temporary working env</h2><p>Quite often, I need to do something, and run a specific command that need me to install a very specific command. And I'm pretty sure I will not use this tool ever again.<p>For those cases, what I do, is generally run my command directly with a fresh <code>nix-shell</code>.<pre class=bd><code>&gt; nix-shell -p httpie
[nix-shell:~]$ ... here I can use httpie ...
</code></pre><p>If I don't use <code>httpie</code> for a while it will be garbage collected eventually.<h2 id=home-manager>Home Manager</h2><p>A few years ago I used <code>brew</code> to install the tools I need. With <code>nix</code> you can install a new tool with <code>nix-env -i</code> instead of <code>brew install</code>. Still recently I prefer to use <a href=https://github.com/rycee/home-manager>home-manager</a>.<p>The main advantage is that it is even more reproductible and can easily be shared accross different machines.<p>Mainly when I need a new binary I add it in a description list in the file <code>~/.config/nixpkgs/home.nix</code>. It looks like this:<div class=m id=cb3><pre class="m nix"><code class="m bash"><span id=cb3-1><a href=#cb3-1 aria-hidden=true></a><span class=ex>home.packages</span> = with pkgs<span class=kw>;</span><span class=bu> [</span></span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true></a>  <span class=co># emacs</span></span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true></a>  emacsMacport</span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true></a>  imagemagick</span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true></a>  gnupg</span>
<span id=cb3-6><a href=#cb3-6 aria-hidden=true></a>  <span class=co># shell</span></span>
<span id=cb3-7><a href=#cb3-7 aria-hidden=true></a>  direnv</span>
<span id=cb3-8><a href=#cb3-8 aria-hidden=true></a>  ...</span>
<span id=cb3-9><a href=#cb3-9 aria-hidden=true></a><span class=bu>]</span>;</span></code></pre></div><p>then I simply run <code>home-manager switch</code> and I've got all those tools in my env.<h3 id=pinning-the-packages>Pinning the packages</h3><div class=m id=cb4><pre class="m nix"><code class="m bash"><span id=cb4-1><a href=#cb4-1 aria-hidden=true></a><span class=kw>{</span> <span class=ex>config</span>, pkgs, ... <span class=kw>}</span>:</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true></a><span class=bu>let</span></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true></a>  <span class=co># ...</span></span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true></a>  <span class=ex>pkgs</span> = import (fetchGit {</span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true></a>    <span class=ex>name</span> = <span class=st>&quot;nixpkgs20&quot;</span><span class=kw>;</span></span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true></a>    <span class=ex>url</span> = <span class=st>&quot;https://github.com/NixOS/nixpkgs&quot;</span><span class=kw>;</span></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true></a>    <span class=co># obtained via</span></span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true></a>    <span class=co># git ls-remote https://github.com/NixOS/nixpkgs nixpkgs-20.03-darwin</span></span>
<span id=cb4-9><a href=#cb4-9 aria-hidden=true></a>    <span class=ex>ref</span> = <span class=st>&quot;refs/heads/nixpkgs-20.03-darwin&quot;</span><span class=kw>;</span></span>
<span id=cb4-10><a href=#cb4-10 aria-hidden=true></a>    <span class=fu>rev</span> = <span class=st>&quot;58f884cd3d89f47672e649c6edfb2382d4afff6a&quot;</span><span class=kw>;</span></span>
<span id=cb4-11><a href=#cb4-11 aria-hidden=true></a>  }) {};</span>
<span id=cb4-12><a href=#cb4-12 aria-hidden=true></a>  <span class=co># ...</span></span>
<span id=cb4-13><a href=#cb4-13 aria-hidden=true></a><span class=kw>in</span> <span class=kw>{</span></span>
<span id=cb4-14><a href=#cb4-14 aria-hidden=true></a>  <span class=co># ...</span></span>
<span id=cb4-15><a href=#cb4-15 aria-hidden=true></a><span class=kw>}</span></span></code></pre></div><h3 id=specific-tools>Specific tools</h3><p>There are a few noticiable artifacts here:<p>The first one is <code>weechat</code> is a very specify build of weechat with the plugin I need. For that I created a new directory <code>weechat-with-weeslack</code> containing a <code>default.nix</code>:<div class=m id=cb5><pre class="m nix"><code class="m bash"><span id=cb5-1><a href=#cb5-1 aria-hidden=true></a><span class=kw>{</span> <span class=ex>pkgs</span>, ...<span class=kw>}</span>:</span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true></a><span class=ex>pkgs.weechat.override</span> {</span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true></a>  <span class=ex>configure</span> = { availablePlugins, ... }: <span class=kw>{</span></span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true></a>    <span class=co># plugins = with availablePlugins; [ python perl guile ];</span></span>
<span id=cb5-5><a href=#cb5-5 aria-hidden=true></a>    <span class=ex>scripts</span> = with pkgs.weechatScripts<span class=kw>;</span><span class=bu> [</span> wee-slack<span class=bu> ]</span>;</span>
<span id=cb5-6><a href=#cb5-6 aria-hidden=true></a>  <span class=kw>}</span>;</span>
<span id=cb5-7><a href=#cb5-7 aria-hidden=true></a>}</span></code></pre></div><p>And in my <code>home.nix</code> I use:<div class=m id=cb6><pre class="m nix"><code class="m bash"><span id=cb6-1><a href=#cb6-1 aria-hidden=true></a><span class=ex>weechat-with-weeslack</span> = import ./weechat-with-weeslack {</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true></a>  <span class=ex>inherit</span> pkgs<span class=kw>;</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true></a>};</span></code></pre></div><p>Even if this looks cryptic. The important detail is just that there exists a way to say to nix I'd like to use weechat (an IRC client) with the wee-slack client (which uses python). And nix handle the rest for me without any conflict.<h3 id=another-nice-tool-is--sws->Another nice tool is <code>sws</code></h3><p>I use macOS so even though I'm using a darwin focused nixpkgs sometimes a few package can be broken and can't be installed.<p>That occurred with <a href=https://hackage.haskell.org/package/sws><code>sws</code></a> during the upgrade to 20.03 on darwin. This is a simple tool that need haskell to be compiled locally and installed. Here is how I could install it:<div class=m id=cb7><pre class="m nix"><code class="m bash"><span id=cb7-1><a href=#cb7-1 aria-hidden=true></a><span class=bu>let</span></span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true></a>  <span class=ex>...</span></span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true></a>  <span class=ex>rel19</span> = import (fetchGit {</span>
<span id=cb7-4><a href=#cb7-4 aria-hidden=true></a>    <span class=ex>name</span> = <span class=st>&quot;nixpkgs19&quot;</span><span class=kw>;</span></span>
<span id=cb7-5><a href=#cb7-5 aria-hidden=true></a>    <span class=ex>url</span> = <span class=st>&quot;https://github.com/NixOS/nixpkgs&quot;</span><span class=kw>;</span></span>
<span id=cb7-6><a href=#cb7-6 aria-hidden=true></a>    <span class=ex>ref</span> = <span class=st>&quot;refs/heads/nixpkgs-19.09-darwin&quot;</span><span class=kw>;</span></span>
<span id=cb7-7><a href=#cb7-7 aria-hidden=true></a>    <span class=fu>rev</span> = <span class=st>&quot;2f9bafaca90acd010cccd0e79e5f27aa7537957e&quot;</span><span class=kw>;</span></span>
<span id=cb7-8><a href=#cb7-8 aria-hidden=true></a>  }) {};</span>
<span id=cb7-9><a href=#cb7-9 aria-hidden=true></a>  <span class=ex>haskellDeps</span> = ps: with ps<span class=kw>;</span><span class=bu> [</span></span>
<span id=cb7-10><a href=#cb7-10 aria-hidden=true></a>    base</span>
<span id=cb7-11><a href=#cb7-11 aria-hidden=true></a>    protolude</span>
<span id=cb7-12><a href=#cb7-12 aria-hidden=true></a>    tidal</span>
<span id=cb7-13><a href=#cb7-13 aria-hidden=true></a>    shake</span>
<span id=cb7-14><a href=#cb7-14 aria-hidden=true></a>    rel19.haskellPackages.sws</span>
<span id=cb7-15><a href=#cb7-15 aria-hidden=true></a>    ];</span>
<span id=cb7-16><a href=#cb7-16 aria-hidden=true></a>  ghc <span class=ot>=</span> pkgs.haskellPackages.ghcWithPackages haskellDeps;</span>
<span id=cb7-17><a href=#cb7-17 aria-hidden=true></a>  ...</span>
<span id=cb7-18><a href=#cb7-18 aria-hidden=true></a>in</span>
<span id=cb7-19><a href=#cb7-19 aria-hidden=true></a>  home.packages <span class=ot>=</span> with pkgs; [</span>
<span id=cb7-20><a href=#cb7-20 aria-hidden=true></a>    ...</span>
<span id=cb7-21><a href=#cb7-21 aria-hidden=true></a>    ghc</span>
<span id=cb7-22><a href=#cb7-22 aria-hidden=true></a>    ...</span>
<span id=cb7-23><a href=#cb7-23 aria-hidden=true></a>  ]</span></code></pre></div><p>So I used the older version from 19.09.<h2 id=dev-environment>Dev environment</h2><p>When working on a project. You can produce a pretty good local environment. For example, for my blog, I only use emacs and a few shell scripts. Still I needed to fix a few binaries, like the correct <code>date</code> via <code>coreutils</code>. And also I use <code>html-xml-utils</code> to easily deal with html/xml parsing. I use it to generate my RSS xml file.<p>So I have a <code>shell.nix</code> files at the root of my project:<div class=m id=cb8><pre class="m nix"><code class="m bash"><span id=cb8-1><a href=#cb8-1 aria-hidden=true></a><span class=kw>{</span> <span class=ex>pkgs</span> ? import (fetchTarball https://github.com/NixOS/nixpkgs/archive/19.09.tar.gz) {<span class=kw>}</span> }:</span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true></a>  <span class=bu>let</span> my_aspell = pkgs.aspellWithDicts(p: with p<span class=kw>;</span> [<span class=ex>en</span> fr]);</span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true></a>  <span class=kw>in</span></span>
<span id=cb8-4><a href=#cb8-4 aria-hidden=true></a>  <span class=ex>pkgs.mkShell</span> {</span>
<span id=cb8-5><a href=#cb8-5 aria-hidden=true></a>    <span class=ex>buildInputs</span> = [ pkgs.coreutils</span>
<span id=cb8-6><a href=#cb8-6 aria-hidden=true></a>                    <span class=ex>pkgs.html-xml-utils</span></span>
<span id=cb8-7><a href=#cb8-7 aria-hidden=true></a>                    <span class=ex>pkgs.zsh</span></span>
<span id=cb8-8><a href=#cb8-8 aria-hidden=true></a>                    <span class=ex>pkgs.perl</span></span>
<span id=cb8-9><a href=#cb8-9 aria-hidden=true></a>                    <span class=ex>pkgs.perlPackages.URI</span></span>
<span id=cb8-10><a href=#cb8-10 aria-hidden=true></a>                    <span class=ex>pkgs.minify</span></span>
<span id=cb8-11><a href=#cb8-11 aria-hidden=true></a>                    <span class=ex>pkgs.haskellPackages.sws</span></span>
<span id=cb8-12><a href=#cb8-12 aria-hidden=true></a>                    <span class=ex>pkgs.cacert</span></span>
<span id=cb8-13><a href=#cb8-13 aria-hidden=true></a>                  ];</span>
<span id=cb8-14><a href=#cb8-14 aria-hidden=true></a>  }</span></code></pre></div><p>So I just need to launch <code>nix-shell</code> and I have my environment.<p>A nice addition is to use direnv<a href=#fn1 class=g id=fnref1 role=doc-noteref><sup>1</sup></a> which support <code>nix-shell</code> by putting <code>use_nix</code> inside the <code>.envrc</code> at the root of the project. But by default invoking <code>nix-shell</code> can take a few seconds everytime. But we can do even better by using lorri<a href=#fn2 class=g id=fnref2 role=doc-noteref><sup>2</sup></a>. I start the lorri daemon in my <code>StartupItems</code> mainly I simply created the file <code>~/Library/LaunchAgents/com.github.target.lorri.plist</code>:<div class=m id=cb9 data-tangle=com.github.target.lorri.plist data-mkdirp=t><pre class="m xml"><code class="m xml"><span id=cb9-1><a href=#cb9-1 aria-hidden=true></a><span class=kw>&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class=kw>?&gt;</span></span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true></a><span class=dt>&lt;!DOCTYPE </span>plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;<span class=dt>&gt;</span></span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true></a><span class=kw>&lt;plist</span><span class=ot> version=</span><span class=st>&quot;1.0&quot;</span><span class=kw>&gt;</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true></a><span class=kw>&lt;dict&gt;</span></span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true></a>    <span class=kw>&lt;key&gt;</span>Label<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-6><a href=#cb9-6 aria-hidden=true></a>    <span class=kw>&lt;string&gt;</span>com.github.target.lorri<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-7><a href=#cb9-7 aria-hidden=true></a>    <span class=kw>&lt;key&gt;</span>ProgramArguments<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-8><a href=#cb9-8 aria-hidden=true></a>    <span class=kw>&lt;array&gt;</span></span>
<span id=cb9-9><a href=#cb9-9 aria-hidden=true></a>        <span class=kw>&lt;string&gt;</span>/bin/zsh<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-10><a href=#cb9-10 aria-hidden=true></a>        <span class=kw>&lt;string&gt;</span>-i<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-11><a href=#cb9-11 aria-hidden=true></a>        <span class=kw>&lt;string&gt;</span>-c<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-12><a href=#cb9-12 aria-hidden=true></a>        <span class=kw>&lt;string&gt;</span>$HOME/.nix-profile/bin/lorri daemon<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-13><a href=#cb9-13 aria-hidden=true></a>    <span class=kw>&lt;/array&gt;</span></span>
<span id=cb9-14><a href=#cb9-14 aria-hidden=true></a>    <span class=kw>&lt;key&gt;</span>StandardOutPath<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-15><a href=#cb9-15 aria-hidden=true></a>    <span class=kw>&lt;string&gt;</span>/var/tmp/lorri.log<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-16><a href=#cb9-16 aria-hidden=true></a>    <span class=kw>&lt;key&gt;</span>StandardErrorPath<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-17><a href=#cb9-17 aria-hidden=true></a>    <span class=kw>&lt;string&gt;</span>/var/tmp/lorri.log<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-18><a href=#cb9-18 aria-hidden=true></a>    <span class=kw>&lt;key&gt;</span>RunAtLoad<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-19><a href=#cb9-19 aria-hidden=true></a>    <span class=kw>&lt;true/&gt;</span></span>
<span id=cb9-20><a href=#cb9-20 aria-hidden=true></a>    <span class=kw>&lt;key&gt;</span>KeepAlive<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-21><a href=#cb9-21 aria-hidden=true></a>    <span class=kw>&lt;true/&gt;</span></span>
<span id=cb9-22><a href=#cb9-22 aria-hidden=true></a><span class=kw>&lt;/dict&gt;</span></span>
<span id=cb9-23><a href=#cb9-23 aria-hidden=true></a><span class=kw>&lt;/plist&gt;</span></span></code></pre></div><p>And started the daemon with:<div class=m id=cb10><pre class="m bash"><code class="m bash"><span id=cb10-1><a href=#cb10-1 aria-hidden=true></a><span class=ex>launchctl</span> load ~/Library/LaunchAgents/com.github.target.lorri.plist</span></code></pre></div><p><code>lorri</code> takes care of keeping a cache and watch my configuration change by project. This makes the call to <code>direnv</code> almost instantaneous and seemless. I just changed the content of my <code>.envrc</code> with:<pre class=bd><code>eval &quot;$(lorri direnv)&quot;
</code></pre><p>And of course this would work the same way with more complex <code>shell.nix</code>. Typically for Haskell projects.<h2 id=install>Install</h2><p>So you would like to use nix too?<p>First, let's start by the bad news. Recent macOS security policy made nix a bit harder to install on a mac. See <a href=https://hydra.nixos.org/build/119559243/download/1/manual/#sect-macos-installation>macOS Installation instructions</a>.<p>Once you have nix installed you should update the nix-channel. Mainly a nix-channels is where are the definitions of all the packages. See <a href=https://hydra.nixos.org/build/119559243/download/1/manual/#sec-channels>nixOS documentation</a>.<section class=s role=doc-endnotes><hr><ol><li id=fn1 role=doc-endnote><p><a href=https://direnv.net>https://direnv.net</a><a href=#fnref1 class=c role=doc-backlink>↩︎</a><li id=fn2 role=doc-endnote><p><a href=https://github.com/target/lorri>https://github.com/target/lorri</a><a href=#fnref2 class=c role=doc-backlink>↩︎</a></ol></section></div><div id=postamble class=an><div class=ai><nav><a href=/index.html>Home</a> |
<a href=/slides.html>Slides</a> |
<a href=/about-me.html>About</a>
<span class=ag>(<a href=https://gitea.esy.fun/yogsototh>code</a>
<a href=https://espial.esy.fun/u:yogsototh>bookmarks</a>
<a href=https://espial.esy.fun/u:yogsototh/notes>notes</a>)</span> |
<a href=#preamble>↑ Top ↑</a></nav></div></div></div>