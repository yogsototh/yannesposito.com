<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>How I use nix</title><meta name=author content="Yann Esposito"><meta name=description content="In this article I explain how I use nix. As a brew replacement, as home environment manager, to have reproductible dev environment."><meta name=keywords content="nix programming"><link rel=stylesheet href=/css/y.css><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=icon href=/favicon.ico><div id=labels><div class=al><span id=logo><a href=/><svg width="5em" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" stroke="var(--b2)" stroke-width="2" fill="var(--b03)"/><circle cx="32" cy="32" r="12" stroke="var(--r)" stroke-width="2" fill="var(--o)"/><circle cx="32" cy="32" r="6" stroke-width="0" fill="var(--y)"/><ellipse cx="32" cy="14" rx="14" ry="8" stroke-width="0" fill="var(--b3)"/></svg></a></div></div><div class=cd><div id=preamble class=ar><div class=al><h1>How I use nix</h1><div class=cb><span class=yyydate>[2020-06-14 Sun]</span> on
<a href=https://her.esy.fun><span class=bd>Yann Esposito</span>'s blog</a></div><div class=ac>In this article I explain how I use nix. As a brew replacement, as home environment manager, to have reproductible dev environment.</div></div></div><div id=content><p>Have you ever written a small script and you update your system and this stop working? Have you copied your tool/script to another machine it doesn't work because some dependency is missing? Have you tried to sync your dotfiles to another env and there are a few details not working? Some missing dependency? If the answer is yes, then <a href=https://nixos.org/nix>nix</a> can help.<h2 id=scripts>Scripts</h2><p>Suppose you want to write a portable script. For example, the script I use to minify my CSS. Here it is:<pre class=bh><code>#!/usr/bin/env nix-shell
#!nix-shell --pure
#!nix-shell -i bash
#!nix-shell -I nixpkgs=&quot;https://github.com/NixOS/nixpkgs/archive/19.09.tar.gz&quot;
#!nix-shell -p bash minify

minify &quot;$1&quot; &gt; &quot;$2&quot;
</code></pre><p>So let's analyze each line of the header block:<dl><dt><code>#!/usr/bin/env nix-shell</code><dd>basic, use <code>nix-shell</code> to run the script.<dt><code>#!nix-shell --pure</code><dd>only use dependencies installed in this nix shell environment. A bit as if the PATH environment variable was emptied.<dt><code>#!nix-shell -i bash</code><dd>tell <code>nix-shell</code> to run <code>bash</code><dt><code>#!nix-shell -I nixpkgs="https://github.com/NixOS/nixpkgs/archive/19.09.tar.gz"</code><dd>pin the nixpkgs using this archive.<dt><code>#!nix-shell -p bash minify</code><dd>install <code>bash</code> and <code>minify</code> in the nix shell.</dl><p>Now if the script is run on a machine with <code>nix</code> installed you can be pretty sure it will work as expected. Even if I update my OS and I forget about this script for a few years. As long as I can install nix on the new system and I could download the tar file the script will be run the same way as the day I wrote it.<p><strong><strong>Remark</strong></strong>: You can use any shell (like <code>fish</code>, <code>zsh</code>) but also other languages <code>python</code>, <code>haskell</code>, etc…<h2 id=temporary-working-env>Temporary working env</h2><p>Quite often, I need to do something, and run a specific command that need me to install a very specific command. And I'm pretty sure I will not use this tool ever again.<p>For those cases, what I do, is generally run my command directly with a fresh <code>nix-shell</code>.<pre class=bh><code>&gt; nix-shell -p httpie
[nix-shell:~]$ ... here I can use httpie ...
</code></pre><p>If I don't use <code>httpie</code> for a while it will be garbage collected eventually.<h2 id=home-manager>Home Manager</h2><p>A few years ago I used <code class=w>brew</code> to install the tools I need. With <code class=w>nix</code> you can install a new tool with <code>nix-env -i</code> instead of <code>brew install</code>. Still recently I prefer to use <a href=https://github.com/rycee/home-manager>home-manager</a>.<p>The main advantage is that it is even more reproductible and can easily be shared accross different machines.<p>Mainly when I need a new binary I add it in a description list in the file <code class=w>~/.config/nixpkgs/home.nix</code>. It looks like this:<div class=n id=cb3><pre class="n nix"><code class="n bash"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a><span class=ex>home.packages</span> = with pkgs<span class=kw>;</span> <span class=bu>[</span></span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true tabindex=-1></a>  # emacs</span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true tabindex=-1></a>  emacsMacport</span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true tabindex=-1></a>  <span class=er>imagemagick</span></span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true tabindex=-1></a>  <span class=er>gnupg</span></span>
<span id=cb3-6><a href=#cb3-6 aria-hidden=true tabindex=-1></a>  <span class=er>#</span> <span class=er>shell</span></span>
<span id=cb3-7><a href=#cb3-7 aria-hidden=true tabindex=-1></a>  <span class=ex>direnv</span></span>
<span id=cb3-8><a href=#cb3-8 aria-hidden=true tabindex=-1></a>  <span class=ex>...</span></span>
<span id=cb3-9><a href=#cb3-9 aria-hidden=true tabindex=-1></a><span class=ex>]</span><span class=kw>;</span></span></code></pre></div><p>then I simply run <code>home-manager switch</code> and I've got all those tools in my env.<h3 id=pinning-the-packages>Pinning the packages</h3><div class=n id=cb4><pre class="n nix"><code class="n bash"><span id=cb4-1><a href=#cb4-1 aria-hidden=true tabindex=-1></a><span class=kw>{</span> <span class=ex>config,</span> pkgs, ... }:</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true tabindex=-1></a><span class=bu>let</span></span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true tabindex=-1></a>  <span class=co># ...</span></span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true tabindex=-1></a>  <span class=ex>pkgs</span> = import <span class=er>(</span><span class=ex>fetchGit</span> {</span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true tabindex=-1></a>    <span class=ex>name</span> = <span class=st>&quot;nixpkgs20&quot;</span><span class=kw>;</span></span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true tabindex=-1></a>    <span class=ex>url</span> = <span class=st>&quot;https://github.com/NixOS/nixpkgs&quot;</span><span class=kw>;</span></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true tabindex=-1></a>    <span class=co># obtained via</span></span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true tabindex=-1></a>    <span class=co># git ls-remote https://github.com/NixOS/nixpkgs nixpkgs-20.03-darwin</span></span>
<span id=cb4-9><a href=#cb4-9 aria-hidden=true tabindex=-1></a>    <span class=ex>ref</span> = <span class=st>&quot;refs/heads/nixpkgs-20.03-darwin&quot;</span><span class=kw>;</span></span>
<span id=cb4-10><a href=#cb4-10 aria-hidden=true tabindex=-1></a>    <span class=fu>rev</span> = <span class=st>&quot;58f884cd3d89f47672e649c6edfb2382d4afff6a&quot;</span><span class=kw>;</span></span>
<span id=cb4-11><a href=#cb4-11 aria-hidden=true tabindex=-1></a>  <span class=er>}</span><span class=kw>)</span> <span class=ex>{}</span><span class=kw>;</span></span>
<span id=cb4-12><a href=#cb4-12 aria-hidden=true tabindex=-1></a>  <span class=co># ...</span></span>
<span id=cb4-13><a href=#cb4-13 aria-hidden=true tabindex=-1></a><span class=er>in</span> <span class=kw>{</span></span>
<span id=cb4-14><a href=#cb4-14 aria-hidden=true tabindex=-1></a>  <span class=co># ...</span></span>
<span id=cb4-15><a href=#cb4-15 aria-hidden=true tabindex=-1></a><span class=kw>}</span></span></code></pre></div><h3 id=specific-tools>Specific tools</h3><p>There are a few noticiable artifacts here:<p>The first one is <code>weechat</code> is a very specify build of weechat with the plugin I need. For that I created a new directory <code class=w>weechat-with-weeslack</code> containing a <code class=w>default.nix</code>:<div class=n id=cb5><pre class="n nix"><code class="n bash"><span id=cb5-1><a href=#cb5-1 aria-hidden=true tabindex=-1></a><span class=kw>{</span> <span class=ex>pkgs,</span> ...}:</span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true tabindex=-1></a><span class=ex>pkgs.weechat.override</span> {</span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true tabindex=-1></a>  <span class=ex>configure</span> = { availablePlugins, ... }: {</span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true tabindex=-1></a>    <span class=co># plugins = with availablePlugins; [ python perl guile ];</span></span>
<span id=cb5-5><a href=#cb5-5 aria-hidden=true tabindex=-1></a>    <span class=ex>scripts</span> = with pkgs.weechatScripts<span class=kw>;</span> <span class=bu>[</span> wee-slack <span class=bu>]</span><span class=kw>;</span></span>
<span id=cb5-6><a href=#cb5-6 aria-hidden=true tabindex=-1></a>  <span class=kw>};</span></span>
<span id=cb5-7><a href=#cb5-7 aria-hidden=true tabindex=-1></a><span class=er>}</span></span></code></pre></div><p>And in my <code class=w>home.nix</code> I use:<div class=n id=cb6><pre class="n nix"><code class="n bash"><span id=cb6-1><a href=#cb6-1 aria-hidden=true tabindex=-1></a><span class=ex>weechat-with-weeslack</span> = import ./weechat-with-weeslack {</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true tabindex=-1></a>  <span class=ex>inherit</span> pkgs<span class=kw>;</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true tabindex=-1></a><span class=er>}</span><span class=kw>;</span></span></code></pre></div><p>Even if this looks cryptic. The important detail is just that there exists a way to say to nix I'd like to use weechat (an IRC client) with the wee-slack client (which uses python). And nix handle the rest for me without any conflict.<h3 id=another-nice-tool-is--sws->Another nice tool is <code class=w>sws</code></h3><p>I use macOS so even though I'm using a darwin focused nixpkgs sometimes a few package can be broken and can't be installed.<p>That occurred with <a href=https://hackage.haskell.org/package/sws><code class=w>sws</code></a> during the upgrade to 20.03 on darwin. This is a simple tool that need haskell to be compiled locally and installed. Here is how I could install it:<div class=n id=cb7><pre class="n nix"><code class="n bash"><span id=cb7-1><a href=#cb7-1 aria-hidden=true tabindex=-1></a><span class=bu>let</span></span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true tabindex=-1></a>  <span class=ex>...</span></span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true tabindex=-1></a>  <span class=ex>rel19</span> = import <span class=er>(</span><span class=ex>fetchGit</span> {</span>
<span id=cb7-4><a href=#cb7-4 aria-hidden=true tabindex=-1></a>    <span class=ex>name</span> = <span class=st>&quot;nixpkgs19&quot;</span><span class=kw>;</span></span>
<span id=cb7-5><a href=#cb7-5 aria-hidden=true tabindex=-1></a>    <span class=ex>url</span> = <span class=st>&quot;https://github.com/NixOS/nixpkgs&quot;</span><span class=kw>;</span></span>
<span id=cb7-6><a href=#cb7-6 aria-hidden=true tabindex=-1></a>    <span class=ex>ref</span> = <span class=st>&quot;refs/heads/nixpkgs-19.09-darwin&quot;</span><span class=kw>;</span></span>
<span id=cb7-7><a href=#cb7-7 aria-hidden=true tabindex=-1></a>    <span class=fu>rev</span> = <span class=st>&quot;2f9bafaca90acd010cccd0e79e5f27aa7537957e&quot;</span><span class=kw>;</span></span>
<span id=cb7-8><a href=#cb7-8 aria-hidden=true tabindex=-1></a>  <span class=er>}</span><span class=kw>)</span> <span class=ex>{}</span><span class=kw>;</span></span>
<span id=cb7-9><a href=#cb7-9 aria-hidden=true tabindex=-1></a>  <span class=ex>haskellDeps</span> = ps: with ps<span class=kw>;</span> <span class=bu>[</span></span>
<span id=cb7-10><a href=#cb7-10 aria-hidden=true tabindex=-1></a>    base</span>
<span id=cb7-11><a href=#cb7-11 aria-hidden=true tabindex=-1></a>    protolude</span>
<span id=cb7-12><a href=#cb7-12 aria-hidden=true tabindex=-1></a>    tidal</span>
<span id=cb7-13><a href=#cb7-13 aria-hidden=true tabindex=-1></a>    <span class=er>shake</span></span>
<span id=cb7-14><a href=#cb7-14 aria-hidden=true tabindex=-1></a>    <span class=er>rel19.haskellPackages.sws</span></span>
<span id=cb7-15><a href=#cb7-15 aria-hidden=true tabindex=-1></a>    <span class=bu>]</span><span class=er>;</span></span>
<span id=cb7-16><a href=#cb7-16 aria-hidden=true tabindex=-1></a>  <span class=er>ghc</span> <span class=er>=</span> <span class=ex>pkgs.haskellPackages.ghcWithPackages</span> haskellDeps<span class=kw>;</span></span>
<span id=cb7-17><a href=#cb7-17 aria-hidden=true tabindex=-1></a>  <span class=ex>...</span></span>
<span id=cb7-18><a href=#cb7-18 aria-hidden=true tabindex=-1></a><span class=er>in</span></span>
<span id=cb7-19><a href=#cb7-19 aria-hidden=true tabindex=-1></a>  <span class=ex>home.packages</span> = with pkgs<span class=kw>;</span> <span class=bu>[</span></span>
<span id=cb7-20><a href=#cb7-20 aria-hidden=true tabindex=-1></a>    ...</span>
<span id=cb7-21><a href=#cb7-21 aria-hidden=true tabindex=-1></a>    ghc</span>
<span id=cb7-22><a href=#cb7-22 aria-hidden=true tabindex=-1></a>    ...</span>
<span id=cb7-23><a href=#cb7-23 aria-hidden=true tabindex=-1></a>  <span class=bu>]</span></span></code></pre></div><p>So I used the older version from 19.09.<h2 id=dev-environment>Dev environment</h2><p>When working on a project. You can produce a pretty good local environment. For example, for my blog, I only use emacs and a few shell scripts. Still I needed to fix a few binaries, like the correct <code>date</code> via <code>coreutils</code>. And also I use <code>html-xml-utils</code> to easily deal with html/xml parsing. I use it to generate my RSS xml file.<p>So I have a <code>shell.nix</code> files at the root of my project:<div class=n id=cb8><pre class="n nix"><code class="n bash"><span id=cb8-1><a href=#cb8-1 aria-hidden=true tabindex=-1></a><span class=kw>{</span> <span class=ex>pkgs</span> <span class=pp>?</span> import <span class=er>(</span><span class=ex>fetchTarball</span> https://github.com/NixOS/nixpkgs/archive/19.09.tar.gz<span class=kw>)</span> <span class=ex>{}</span> }:</span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true tabindex=-1></a>  <span class=bu>let</span> my_aspell = pkgs.aspellWithDicts<span class=er>(</span><span class=ex>p:</span> with p<span class=kw>;</span> <span class=ex>[en</span> fr]<span class=kw>);</span></span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true tabindex=-1></a>  <span class=er>in</span></span>
<span id=cb8-4><a href=#cb8-4 aria-hidden=true tabindex=-1></a>  <span class=ex>pkgs.mkShell</span> {</span>
<span id=cb8-5><a href=#cb8-5 aria-hidden=true tabindex=-1></a>    <span class=ex>buildInputs</span> = [ pkgs.coreutils</span>
<span id=cb8-6><a href=#cb8-6 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.html-xml-utils</span></span>
<span id=cb8-7><a href=#cb8-7 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.zsh</span></span>
<span id=cb8-8><a href=#cb8-8 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.perl</span></span>
<span id=cb8-9><a href=#cb8-9 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.perlPackages.URI</span></span>
<span id=cb8-10><a href=#cb8-10 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.minify</span></span>
<span id=cb8-11><a href=#cb8-11 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.haskellPackages.sws</span></span>
<span id=cb8-12><a href=#cb8-12 aria-hidden=true tabindex=-1></a>                    <span class=ex>pkgs.cacert</span></span>
<span id=cb8-13><a href=#cb8-13 aria-hidden=true tabindex=-1></a>                  <span class=ex>]</span><span class=kw>;</span></span>
<span id=cb8-14><a href=#cb8-14 aria-hidden=true tabindex=-1></a>  <span class=er>}</span></span></code></pre></div><p>So I just need to launch <code>nix-shell</code> and I have my environment.<p>A nice addition is to use direnv<a href=#fn1 class=h id=fnref1 role=doc-noteref><sup>1</sup></a> which support <code>nix-shell</code> by putting <code>use_nix</code> inside the <code>.envrc</code> at the root of the project. But by default invoking <code>nix-shell</code> can take a few seconds everytime. But we can do even better by using lorri<a href=#fn2 class=h id=fnref2 role=doc-noteref><sup>2</sup></a>. I start the lorri daemon in my <code>StartupItems</code> mainly I simply created the file <code class=w>~/Library/LaunchAgents/com.github.target.lorri.plist</code>:<div class=n id=cb9 data-tangle=com.github.target.lorri.plist data-mkdirp=t><pre class="n xml"><code class="n xml"><span id=cb9-1><a href=#cb9-1 aria-hidden=true tabindex=-1></a><span class=kw>&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;<span class=kw>?&gt;</span></span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true tabindex=-1></a><span class=dt>&lt;!DOCTYPE </span>plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;<span class=dt>&gt;</span></span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true tabindex=-1></a><span class=kw>&lt;plist</span><span class=ot> version=</span><span class=st>&quot;1.0&quot;</span><span class=kw>&gt;</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true tabindex=-1></a><span class=kw>&lt;dict&gt;</span></span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;key&gt;</span>Label<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-6><a href=#cb9-6 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;string&gt;</span>com.github.target.lorri<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-7><a href=#cb9-7 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;key&gt;</span>ProgramArguments<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-8><a href=#cb9-8 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;array&gt;</span></span>
<span id=cb9-9><a href=#cb9-9 aria-hidden=true tabindex=-1></a>        <span class=kw>&lt;string&gt;</span>/bin/zsh<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-10><a href=#cb9-10 aria-hidden=true tabindex=-1></a>        <span class=kw>&lt;string&gt;</span>-i<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-11><a href=#cb9-11 aria-hidden=true tabindex=-1></a>        <span class=kw>&lt;string&gt;</span>-c<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-12><a href=#cb9-12 aria-hidden=true tabindex=-1></a>        <span class=kw>&lt;string&gt;</span>$HOME/.nix-profile/bin/lorri daemon<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-13><a href=#cb9-13 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;/array&gt;</span></span>
<span id=cb9-14><a href=#cb9-14 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;key&gt;</span>StandardOutPath<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-15><a href=#cb9-15 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;string&gt;</span>/var/tmp/lorri.log<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-16><a href=#cb9-16 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;key&gt;</span>StandardErrorPath<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-17><a href=#cb9-17 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;string&gt;</span>/var/tmp/lorri.log<span class=kw>&lt;/string&gt;</span></span>
<span id=cb9-18><a href=#cb9-18 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;key&gt;</span>RunAtLoad<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-19><a href=#cb9-19 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;true/&gt;</span></span>
<span id=cb9-20><a href=#cb9-20 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;key&gt;</span>KeepAlive<span class=kw>&lt;/key&gt;</span></span>
<span id=cb9-21><a href=#cb9-21 aria-hidden=true tabindex=-1></a>    <span class=kw>&lt;true/&gt;</span></span>
<span id=cb9-22><a href=#cb9-22 aria-hidden=true tabindex=-1></a><span class=kw>&lt;/dict&gt;</span></span>
<span id=cb9-23><a href=#cb9-23 aria-hidden=true tabindex=-1></a><span class=kw>&lt;/plist&gt;</span></span></code></pre></div><p>And started the daemon with:<div class=n id=cb10><pre class="n bash"><code class="n bash"><span id=cb10-1><a href=#cb10-1 aria-hidden=true tabindex=-1></a><span class=ex>launchctl</span> load ~/Library/LaunchAgents/com.github.target.lorri.plist</span></code></pre></div><p><code>lorri</code> takes care of keeping a cache and watch my configuration change by project. This makes the call to <code>direnv</code> almost instantaneous and seemless. I just changed the content of my <code>.envrc</code> with:<pre class=bh><code>eval &quot;$(lorri direnv)&quot;
</code></pre><p>And of course this would work the same way with more complex <code>shell.nix</code>. Typically for Haskell projects.<h2 id=install>Install</h2><p>So you would like to use nix too?<p>First, let's start by the bad news. Recent macOS security policy made nix a bit harder to install on a mac. See <a href=https://hydra.nixos.org/build/119559243/download/1/manual/#sect-macos-installation>macOS Installation instructions</a>.<p>Once you have nix installed you should update the nix-channel. Mainly a nix-channels is where are the definitions of all the packages. See <a href=https://hydra.nixos.org/build/119559243/download/1/manual/#sec-channels>nixOS documentation</a>.<section class=u role=doc-endnotes><hr><ol><li id=fn1 role=doc-endnote><p><a href=https://direnv.net>https://direnv.net</a><a href=#fnref1 class=d role=doc-backlink>↩︎</a><li id=fn2 role=doc-endnote><p><a href=https://github.com/target/lorri>https://github.com/target/lorri</a><a href=#fnref2 class=d role=doc-backlink>↩︎</a></ol></section></div><div id=postamble class=ar><div class=al><nav><a href=/index.html>Home</a> |
<a href=/slides.html>Slides</a> |
<a href=/about-me.html>About</a>
<span class=aj>(<a href=https://gitea.esy.fun/yogsototh>code</a>
<a href=https://espial.esy.fun/u:yogsototh>bookmarks</a>
<a href=https://espial.esy.fun/u:yogsototh/notes>notes</a>)</span> |
<a href=#preamble>↑ Top ↑</a></nav></div></div></div>