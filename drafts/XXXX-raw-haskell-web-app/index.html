<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Haskell Web Application from scratch</title><meta name=author content="Yann Esposito"><meta name=description content><meta name=keywords content><link rel=stylesheet href=/css/y.css><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=icon href=/favicon.ico><input name=t type=radio id=b>
<input name=t type=radio id=l>
<input name=t type=radio id=d>
<input name=t type=radio id=g><div id=labels><div class=ak><label for=b>book</label>&nbsp;
/&nbsp;
<label for=l>light</label>&nbsp;
<span id=logo><a href=/><svg width="5em" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" stroke="var(--b2)" stroke-width="2" fill="var(--b03)"/><circle cx="32" cy="32" r="12" stroke="var(--r)" stroke-width="2" fill="var(--o)"/><circle cx="32" cy="32" r="6" stroke-width="0" fill="var(--y)"/><ellipse cx="32" cy="14" rx="14" ry="8" stroke-width="0" fill="var(--b3)"/></svg></a></span>&nbsp;
<label for=d>dark</label>&nbsp;
/&nbsp;
<label for=g>geek</label></div></div><div class=cc><div id=preamble class=aq><div class=ak><h1>Haskell Web Application from scratch</h1><div class=ca><span class=am-date></span>on
<a href=https://her.esy.fun><span class=bc>Yann Esposito</span>'s blog</a> -
<a href=/drafts/XXXX-raw-haskell-web-app/index.org>source</a> -
<a href=/drafts/XXXX-raw-haskell-web-app/index.gmi>gmi</a> -
<a href=/drafts/XXXX-raw-haskell-web-app/index.pdf>pdf</a> -
<a class=q href=https://her.esy.fun/drafts/XXXX-raw-haskell-web-app/index.html>§permalink</a></div><div class=ac></div></div></div><div id=content><h1>Introduction</h1><h2>Functional Programming oriented to make a web application</h2><h2>Tooling choices</h2><ul><li>macOS Sierra<li>spacemacs<li>stack (not using ghc-8.0.1, there is a bug with macOS)</ul><h2>High quality application</h2><p>Even if an application only print "hello world" there are a lot of subtle way such an app could fail or have problems. See for example the [changelogs to GNU Hello](<a href=https://github.com/avar/gnu-hello/blob/master/ChangeLog>https://github.com/avar/gnu-hello/blob/master/ChangeLog</a>).<p>The goal of this tutorial is not to provide a "see what we can do with Haskell" but more, how could we enforce production quality development with Haskell. Unfortunately, the tooling is very important in these matters.<p>To reach such goal we should at least provide:<ul><li>Documentation<li>Unit Tests<li>Generative Tests<li>Benchmarks<li>Profiling<li>CI<li>Deployment</ul><p>It's easy to have one tutorial for each of these concepts, here that won't be a deep dive, but a first introduction on how to achieve all these goals.<h1>Tooling and preparing to code</h1><p>blog-image("stillsuit.jpg","Stillsuit")<h2>Warning</h2><p>If you never installed Haskell before, it should be a bit long to setup a correct working environment. So please follow me, don't give up because something doesn't work the first time. I made my best to make my environment work for most people.<h2>Installing Haskell Compiler</h2><p>Install Haskell etc… In my opinion the easiest way to start is to install <code class=w>stack</code>. Then you need to choose a great name for your project, why not <code class=w>shai-hulud</code>?<p>blog-image("shai-hulud.jpg","Shai Hulud")<div class=n id=cb1><pre class="n bash"><code class="n bash"><span id=cb1-1><a href=#cb1-1 aria-hidden=true tabindex=-1></a><span class=op>&gt;</span> stack <span class=ex>new</span> shai-hulud tasty-travis</span></code></pre></div><p>Yeah now you have a new directory, let use git:<div class=n id=cb2><pre class="n bash"><code class="n bash"><span id=cb2-1><a href=#cb2-1 aria-hidden=true tabindex=-1></a><span class=op>&gt;</span> cd <span class=ex>shai-hulud</span></span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true tabindex=-1></a><span class=op>&gt;</span> git <span class=ex>init</span> .</span></code></pre></div><p>Now we have some source code, let's try it[<sup>1</sup>].<p>[<sup>1</sup>]: If you are on a Mac, please, modify the line <code class=w>resolver: lts-7.18</code> by <code class=w>resolver: nightly-2017-01-25</code> to be certain to use <code class=w>ghc-8.0.2</code> because there is a bug with <code class=w>ghc-8.0.1</code>.<div class=n id=cb3><pre class="n bash"><code class="n bash"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a><span class=op>&gt;</span> stack <span class=ex>setup</span> <span class=kw>&amp;&amp;</span> <span class=ex>stack</span> build <span class=kw>&amp;&amp;</span> <span class=ex>stack</span> exec <span class=at>--</span> shai-hulud-exe</span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true tabindex=-1></a><span class=ex>42</span></span></code></pre></div><h2>Dependencies & Libraries</h2><p>As we want to make a web application let's add the needed dependencies to help us. Typically we want a web server [warp](<a href=https://hackage.haskell.org/package/warp>https://hackage.haskell.org/package/warp</a>) and also a Web Application Interface [WAI](<a href=https://hackage.haskell.org/package/wai>https://hackage.haskell.org/package/wai</a>). We'll also need to use [http-types](<a href=https://hackage.haskell.org/package/http-types>https://hackage.haskell.org/package/http-types</a>).<p>In the <code class=w>shai-hulud.cabal</code> file, in the <code class=w>shai-hulud-exe</code> section, add to the build-depends <code class=w>http-types</code>, <code class=w>wai</code> and <code class=w>warp</code> like this:<pre><code>executable shai-hulud-exe
  default-language:  Haskell2010
  ghc-options:       -Wall -Werror -O2 -threaded -rtsopts -with-rtsopts=-N
  hs-source-dirs:    src-exe
  main-is:           Main.hs
  build-depends:     base &gt;= 4.8 &amp;&amp; &lt; 5
                   , shai-hulud
                   , http-types
                   , wai
                   , warp
</code></pre><p>Then we modify the <code class=w>src-exe/Main.hs</code> file to contains:<div class=n id=cb5><pre class="n haskell"><code class="n haskell"><span id=cb5-1><a href=#cb5-1 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Network.Wai</span></span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Network.HTTP.Types</span></span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Network.Wai.Handler.Warp</span> (run)</span>
<span id=cb5-5><a href=#cb5-5 aria-hidden=true tabindex=-1></a></span>
<span id=cb5-6><a href=#cb5-6 aria-hidden=true tabindex=-1></a><span class=ot>app ::</span> <span class=dt>Application</span></span>
<span id=cb5-7><a href=#cb5-7 aria-hidden=true tabindex=-1></a>app _ respond <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb5-8><a href=#cb5-8 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;I&#39;ve done some IO here&quot;</span></span>
<span id=cb5-9><a href=#cb5-9 aria-hidden=true tabindex=-1></a>  respond <span class=op>$</span> responseLBS status200 [(<span class=st>&quot;Content-Type&quot;</span>,<span class=st>&quot;text/plain&quot;</span>)] <span class=st>&quot;Hello, Web!&quot;</span></span>
<span id=cb5-10><a href=#cb5-10 aria-hidden=true tabindex=-1></a></span>
<span id=cb5-11><a href=#cb5-11 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb5-12><a href=#cb5-12 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb5-13><a href=#cb5-13 aria-hidden=true tabindex=-1></a>  <span class=fu>putStrLn</span> <span class=st>&quot;http://localhost:8080/&quot;</span></span>
<span id=cb5-14><a href=#cb5-14 aria-hidden=true tabindex=-1></a>  run <span class=dv>8080</span> app</span></code></pre></div><p>We'll go in detail later about what everything means.<div class=n id=cb6><pre class="n bash"><code class="n bash"><span id=cb6-1><a href=#cb6-1 aria-hidden=true tabindex=-1></a><span class=op>&gt;</span> stack <span class=ex>build</span> <span class=kw>&amp;&amp;</span> <span class=ex>stack</span> exec <span class=at>--</span> shai-hulud-exe</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true tabindex=-1></a><span class=ex>...</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true tabindex=-1></a><span class=ex>...</span> Lot of building logs there</span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true tabindex=-1></a><span class=ex>...</span></span>
<span id=cb6-5><a href=#cb6-5 aria-hidden=true tabindex=-1></a><span class=ex>http://localhost:8080/</span></span></code></pre></div><p>Yeah! It appears to work, now let's try it by going on <a href=http://localhost:8080/>http://localhost:8080/</a> in a web browser. You should see <code class=w>Hello, Web!</code> in your browser and each time you reload the page a new message is printed in the console because some IO were performed.<h2>So can we start yet?</h2><p>Hmmm no sorry, not yet.<p>We should not use the default prelude.<p>While this article is a tutorial, it is not exactly a "very basic" one. I mean, once finished the environment would be good enough for production. There will be tests, ability to reproduce the build on a CI, and so, for such a program I should prevent it to have runtime errors.<p>In fact, certainly one of the main reason to use Haskell is that it helps prevent runtime errors.<p>In order to do that we'll use a prelude that doesn't contain any partial functions. So I choosed to use <code class=w>protolude</code>[<sup>2</sup>].<p>For that that's quite easy, simply add <code class=w>protolude</code> as a dependency to your cabal file. We'll modify the cabal file that way:<pre><code>library
  default-language:  Haskell2010
  ghc-options:       -Wall -Werror -O2
  hs-source-dirs:    src
  exposed-modules:   {-# higlight #-}Lib{-# /highlight #-}
                   , ShaiHulud.App
  build-depends:     base &gt;= 4.8 &amp;&amp; &lt; 5
                   , http-types
                   , protolude
                   , wai

executable shai-hulud-exe
  default-language:  Haskell2010
  ghc-options:       -Wall -Werror -O2 -threaded -rtsopts -with-rtsopts=-N
  hs-source-dirs:    src-exe
  main-is:           Main.hs
  build-depends:     shai-hulud
                   , base &gt;= 4.8 &amp;&amp; &lt; 5
                   , http-types
                   , protolude
                   , wai
                   , warp
</code></pre><p>We move the <code class=w>app</code> declaration in <code class=w>src/ShaiHulud/App.hs</code>:<div class=n id=cb8><pre class="n haskell"><code class="n haskell"><span id=cb8-1><a href=#cb8-1 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE NoImplicitPrelude #-}</span></span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true tabindex=-1></a></span>
<span id=cb8-4><a href=#cb8-4 aria-hidden=true tabindex=-1></a><span class=kw>module</span> <span class=dt>ShaiHulud.App</span></span>
<span id=cb8-5><a href=#cb8-5 aria-hidden=true tabindex=-1></a>  ( app )</span>
<span id=cb8-6><a href=#cb8-6 aria-hidden=true tabindex=-1></a><span class=kw>where</span></span>
<span id=cb8-7><a href=#cb8-7 aria-hidden=true tabindex=-1></a></span>
<span id=cb8-8><a href=#cb8-8 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Protolude</span></span>
<span id=cb8-9><a href=#cb8-9 aria-hidden=true tabindex=-1></a></span>
<span id=cb8-10><a href=#cb8-10 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Network.Wai</span></span>
<span id=cb8-11><a href=#cb8-11 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Network.HTTP.Types</span></span>
<span id=cb8-12><a href=#cb8-12 aria-hidden=true tabindex=-1></a></span>
<span id=cb8-13><a href=#cb8-13 aria-hidden=true tabindex=-1></a><span class=ot>app ::</span> <span class=dt>Application</span></span>
<span id=cb8-14><a href=#cb8-14 aria-hidden=true tabindex=-1></a>app _ respond <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb8-15><a href=#cb8-15 aria-hidden=true tabindex=-1></a>  putText <span class=st>&quot;I&#39;ve done some IO here&quot;</span></span>
<span id=cb8-16><a href=#cb8-16 aria-hidden=true tabindex=-1></a>  respond <span class=op>$</span> responseLBS status200 [(<span class=st>&quot;Content-Type&quot;</span>,<span class=st>&quot;text/plain&quot;</span>)] <span class=st>&quot;Hello, Web!&quot;</span></span></code></pre></div><p>And we remove it from <code class=w>src-exe/Main.hs</code>:<div class=n id=cb9><pre class="n haskell"><code class="n haskell"><span id=cb9-1><a href=#cb9-1 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE NoImplicitPrelude #-}</span></span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true tabindex=-1></a><span class=ot>{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Protolude</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>Network.Wai.Handler.Warp</span> (run)</span>
<span id=cb9-6><a href=#cb9-6 aria-hidden=true tabindex=-1></a></span>
<span id=cb9-7><a href=#cb9-7 aria-hidden=true tabindex=-1></a><span class=kw>import</span> <span class=dt>ShaiHulud.App</span> (app)</span>
<span id=cb9-8><a href=#cb9-8 aria-hidden=true tabindex=-1></a></span>
<span id=cb9-9><a href=#cb9-9 aria-hidden=true tabindex=-1></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb9-10><a href=#cb9-10 aria-hidden=true tabindex=-1></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb9-11><a href=#cb9-11 aria-hidden=true tabindex=-1></a>  putText <span class=st>&quot;http://localhost:8080/&quot;</span></span>
<span id=cb9-12><a href=#cb9-12 aria-hidden=true tabindex=-1></a>  run <span class=dv>8080</span> app</span></code></pre></div><p>So now the tooling around being able to start working seems done.<h2>Not yet</h2><p>Yes I talked about:<ul><li>Installation with <code class=w>stack</code> that should take care of installing Haskell<li>How to add dependencies by adding them to the cabal file<li>Sane prelude with <code class=w>protolude</code><li>Provided an overview of WAI Application type</ul><p>But I forgot to mention part of the tooling that is generally very personal. I use spacemacs and to take advantages of many of the editor niceties I also use <code class=w>intero</code> and <code class=w>haddock</code>.<p>So other things to think about:<ul><li>Install <code class=w>intero</code> with <code class=w>stack install intero</code>.<li>Also generate hoogle documentation: <code class=w>stack hoogle data</code><li>You could also check the tests and benchmark suites: <code class=w>stack test</code> and <code class=w>stack bench</code></ul><h2>So we should be done with prelimiaries</h2><p>So we should be done with preliminaries, at least, I hope so…<p>If you started from scratch it was certainly a terrible first experience. But be assured that once done, most of the step you've taken won't be needed for your next project.<h1>Web Application</h1><p>So what is a web application?<h2>WAI</h2><p>So if you look again at the code you see that your application main function simply print <code class=w>http://localhost:8080/</code> and then run the server on the port <code class=w>8080</code> using <code class=w>app</code>.<p>The type of <code class=w>app</code> is <code class=w>Application</code>, if we look at the type of Application in WAI, for example by using <code class=w>SPC-h-h</code> on the Application keyword or by going in the [WAI documentation](<a href=https://www.stackage.org/haddock/lts-7.18/wai-3.2.1.1/Network-Wai.html>https://www.stackage.org/haddock/lts-7.18/wai-3.2.1.1/Network-Wai.html</a>).<p>We see that:<div class=n id=cb10><pre class="n haskell"><code class="n haskell"><span id=cb10-1><a href=#cb10-1 aria-hidden=true tabindex=-1></a><span class=kw>type</span> <span class=dt>Application</span> <span class=ot>=</span> <span class=dt>Request</span> <span class=ot>-&gt;</span> (<span class=dt>Response</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>ResponseReceived</span>) <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>ResponseReceived</span></span></code></pre></div><p>Hmmmm…. What? So just remakr WAI is at it's third major version. So if we just take a look at WAI in its previous version we see that Application was defined as:<div class=n id=cb11><pre class="n haskell"><code class="n haskell"><span id=cb11-1><a href=#cb11-1 aria-hidden=true tabindex=-1></a><span class=kw>type</span> <span class=dt>Application</span> <span class=ot>=</span> <span class=dt>Request</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>Response</span></span></code></pre></div><p>Which look quite more intuitive. Because, what is the role of a web server if not sending response to requests? The IO here is just there to explain that in order to send a response the server might use IOs like reading in some DB or the file system.<p>So why let's take a bit to analyze the new definition of <code class=w>Application</code> in WAI 3.<div class=n id=cb12><pre class="n haskell"><code class="n haskell"><span id=cb12-1><a href=#cb12-1 aria-hidden=true tabindex=-1></a><span class=kw>type</span> <span class=dt>Application</span> <span class=ot>=</span> <span class=dt>Request</span> <span class=ot>-&gt;</span> (<span class=dt>Response</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>ResponseReceived</span>) <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>ResponseReceived</span></span></code></pre></div><p>It is explained:<blockquote><p>The WAI application.<p>Note that, since WAI 3.0, this type is structured in continuation passing style to allow for proper safe resource handling. This was handled in the past via other means (e.g., ResourceT). As a demonstration:<div class=n id=cb13><pre class="n haskell"><code class="n haskell"><span id=cb13-1><a href=#cb13-1 aria-hidden=true tabindex=-1></a><span class=ot>app ::</span> <span class=dt>Application</span></span>
<span id=cb13-2><a href=#cb13-2 aria-hidden=true tabindex=-1></a>app req respond <span class=ot>=</span> bracket_</span>
<span id=cb13-3><a href=#cb13-3 aria-hidden=true tabindex=-1></a>    (<span class=fu>putStrLn</span> <span class=st>&quot;Allocating scarce resource&quot;</span>)</span>
<span id=cb13-4><a href=#cb13-4 aria-hidden=true tabindex=-1></a>    (<span class=fu>putStrLn</span> <span class=st>&quot;Cleaning up&quot;</span>)</span>
<span id=cb13-5><a href=#cb13-5 aria-hidden=true tabindex=-1></a>    (respond <span class=op>$</span> responseLBS status200 [] <span class=st>&quot;Hello World&quot;</span>)</span></code></pre></div></blockquote><p>Great, so before it was difficult to handling some resources, now it appears to be easier to write using <code class=w>bracket_</code>. Hmm… <code class=w>bracket_</code>? What is this function? If you search it in [hoogle](<a href="https://www.haskell.org/hoogle/?hoogle=bracket_">https://www.haskell.org/hoogle/?hoogle=bracket_</a>):<p>OK that's quite easy, you see it is a function of <code class=w>Control.Exception.Base</code> that we could use like this:<div class=n id=cb14><pre class="n haskell"><code class="n haskell"><span id=cb14-1><a href=#cb14-1 aria-hidden=true tabindex=-1></a>bracket</span>
<span id=cb14-2><a href=#cb14-2 aria-hidden=true tabindex=-1></a>  (openFile <span class=st>&quot;filename&quot;</span> <span class=dt>ReadMode</span>)</span>
<span id=cb14-3><a href=#cb14-3 aria-hidden=true tabindex=-1></a>  (hClose)</span>
<span id=cb14-4><a href=#cb14-4 aria-hidden=true tabindex=-1></a>  (\fileHandle <span class=ot>-&gt;</span> <span class=kw>do</span> { <span class=op>...</span> })</span></code></pre></div><p>And <code class=w>bracket_</code> is a variation of <code class=w>bracket</code> which doesn't need the return value of the first computation to be used the the "closing" computation. (More details here)[<a href=http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception-Base.html#v:bracket_>http://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Exception-Base.html#v:bracket_</a>].<p>So ok, an <code class=w>Application</code> is "mostly" a function that take a <code class=w>Request</code> an returns an <code class=w>IO Response</code>.<p>Good, now let's take another look to the <code class=w>app</code> code:<div class=n id=cb15><pre class="n haskell"><code class="n haskell"><span id=cb15-1><a href=#cb15-1 aria-hidden=true tabindex=-1></a><span class=ot>app ::</span> <span class=dt>Application</span></span>
<span id=cb15-2><a href=#cb15-2 aria-hidden=true tabindex=-1></a>app _ respond <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb15-3><a href=#cb15-3 aria-hidden=true tabindex=-1></a>  putText <span class=st>&quot;I&#39;ve done some IO here&quot;</span></span>
<span id=cb15-4><a href=#cb15-4 aria-hidden=true tabindex=-1></a>  respond <span class=op>$</span> responseLBS status200 [(<span class=st>&quot;Content-Type&quot;</span>,<span class=st>&quot;text/plain&quot;</span>)] <span class=st>&quot;Hello, Web!&quot;</span></span></code></pre></div><p>As you see we don't use the first parameter, the <code class=w>Request</code>. So we could ask for some JSON data on <code class=w>/foo/bar/</code> with a POST, it will still respond an HTTP 200 with content-type plain text containing the body <code class=w>Hello, Web!</code>.<p>So what a web app should provide. And here we could go down the rabbit hole of the HTTP standard and all its subtleties. But the first thing to come in mind is "how to handle routing"?<p>One of the advantage of using a language with some types flexibility is to use the types as a high level specification.<h2>Routing</h2><div class=n id=cb16><pre class="n haskell"><code class="n haskell"><span id=cb16-1><a href=#cb16-1 aria-hidden=true tabindex=-1></a><span class=kw>data</span> <span class=dt>ShaiHuludApp</span> <span class=ot>=</span> <span class=dt>Routes</span> <span class=ot>-&gt;</span> <span class=dt>Application</span></span></code></pre></div><p>That's easy, provided a "Routes" representation we should be able to "generate" a WAI Application. Now how should we represent a set of <code class=w>Routes</code>?<p>We should split them by:<ul><li>HTTP Verb: <code class=w>GET</code>, <code class=w>POST</code>, <code class=w>PUT</code>, <code class=w>DELETE</code>, <code class=w>HEAD</code>, <code class=w>OPTIONS</code>, …<li>Path: <code class=w>/</code>, <code class=w>/users/:userID</code> …<li>Content-Type: <code class=w>application/json</code>, <code class=w>text/plain</code>, <code class=w>text/html</code>, <code class=w>text/css</code>, <code class=w>application/javascript</code>…</ul><p>Hmmm….<p>So it is immediately very difficult. And these are just the basic requirement, what about all subtelties about Standardized Headers (CORS, ETags, …), Custom Headers…<h2>Is that FP compatible?</h2><p>As a functional programmer, and more generally as a scientis, math lover I immediately dislike that profusion of details with a lot of ambiguities.<p>For example, REST is still ambiguous, should you use POST / PUT to update? Should you put a parameter in:<ul><li>part of the path like <code class=w>/user/foo</code><li>in the query param of the URI <code class=w>/user?userID=foo</code><li>in the body? Then what parser should we use? FORM param, JSON, XML?<li>in the headers?<li>Why not as an anchor? =/user#foo<li>How should I provide a parameter that is a list? A set? A Hash-map? Something more complex?</ul><p>The problem of web programming come from the tooling. Browsers and HTTP evolved together and some feature existed in browser before people had really the time to think corectly about them.<p>That's called real-life-production-world. And it sucks! For a better critique of web standards you should really read [the chapter «A Long digression into how standards are made» in Dive into HTML5](<a href=http://diveintohtml5.info/past.html#history-of-the-img-element>http://diveintohtml5.info/past.html#history-of-the-img-element</a>).<p>So how could we get back our laws, our composability? Our maths and proofs?<p>We have a lot of choices, but unfortunately, all the tooling evolved around the existing standards. So for example, using GET will be cached correctly while POST won't. And a lot of these details.<h3>FP Compatible Web Programming?</h3><p>Let's re-invent web programming with all we know today.<p>First, one recent trends has changed a lot of things. Now a web application is splitted between a frontend and backend development.<p>The frontend development is about writing a complete application in a browser. Not just a webpage. The difference between the two notions is blurred.<p>Once consequence is that now, backend application should only present Web API and should never send rendering informations. Only datas. So this is a simplification, the backend should simply expose "procedures", the only things to think about are the size of the parameter to send and the size of the response. As every of these objects will go through the wire.<p>But there are interresting rules:<ul><li><code class=w>GET</code> for read only functions<li><code class=w>POST</code> generic read/write functions<li><code class=w>PUT</code> idempotent read/write functions<li><code class=w>DELETE</code> like <code class=w>PUT</code> but can delete things</ul><p>But there are also HTTP code with so many different semantics.<ul><li><code class=w>1xx</code>: technical detail<li><code class=w>2xx</code>: Successful<li><code class=w>3xx</code>: Redirection<li><code class=w>4xx</code>: Client Error<li><code class=w>5xx</code>: Server Error</ul><p>So there are some similarities with the HTTP 1.1 reference and the control on functions we try to achieve with Haskell.<p>One thing I'd like to imagine is simply that a Web API should simply be like a library. We could simplify everything <u>a lot</u> by removig most accidental complexity.<p>If we consider a web application to be split between a frontend application and a backend application it changes a lot of things. For example, we could mostly get rid of urls, we can consider to use the backend as a way to expose procedures.<p>Let's for example decide to use only POST, and send parameters only in the body.<p>In Haskell we could write:<div class=n id=cb17><pre class="n haskell"><code class="n haskell"><span id=cb17-1><a href=#cb17-1 aria-hidden=true tabindex=-1></a><span class=ot>foo ::</span> <span class=dt>IO</span> <span class=dt>X</span> <span class=co>-- ⇒ POST on /foo</span></span>
<span id=cb17-2><a href=#cb17-2 aria-hidden=true tabindex=-1></a><span class=ot>bar ::</span> <span class=dt>A</span> <span class=ot>-&gt;</span> <span class=dt>IO</span> <span class=dt>X</span> <span class=co>-- ⇒ POST on /foo with a body containing an A</span></span></code></pre></div><p>And that's it.<h1>Appendix</h1><h2>Haskell Fragmentation vs Di</h2><p>There are many other prelude, one of my personal problem with Haskell is fragmentation.<p>Someone could see "diversity" another one "fragmentation".<p>Diversity is perceived as positive while fragmentation isn't.<p>So is diversity imply necessarily fragmentation? Could we cure fragmentation by making it hard for people to compete?<p>I don't think so. I believe we could have the best of both world.<p>Then fragmentation occurs. And fragmentation is bad, because if you have an issue with your choice, the number of people that could help you is by nature reduced.<p>I would say that there is fragmentation when there is no one obvious choice. But having an obvious choice for a library for example doesn't really prevent diversity. Fragmentation:<ul><li>NixOS, raw cabal + Linux, stack<li>preludes<li>editor<li>stream library<li>orientation of the language "entreprisy ready, production oriented" make it work being dirty, add dirty choices for research people working in the language, "research oriented" make it beautiful or don't make it, block entreprisy people.</ul><h2><code class=w>bracket_</code></h2><p>[<sup>3</sup>]: Also if you are curious and look at its implementation it's quite short and at least for me, easy to inuit.<div class=n id=cb18><pre class="n haskell"><code class="n haskell"><span id=cb18-1><a href=#cb18-1 aria-hidden=true tabindex=-1></a><span class=ot>bracket ::</span> <span class=dt>IO</span> a         <span class=co>-- ^ computation to run first (\&quot;acquire resource\&quot;)</span></span>
<span id=cb18-2><a href=#cb18-2 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>IO</span> b)  <span class=co>-- ^ computation to run last (\&quot;release resource\&quot;)</span></span>
<span id=cb18-3><a href=#cb18-3 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> (a <span class=ot>-&gt;</span> <span class=dt>IO</span> c)  <span class=co>-- ^ computation to run in-between</span></span>
<span id=cb18-4><a href=#cb18-4 aria-hidden=true tabindex=-1></a>        <span class=ot>-&gt;</span> <span class=dt>IO</span> c         <span class=co>-- returns the value from the in-between computation</span></span>
<span id=cb18-5><a href=#cb18-5 aria-hidden=true tabindex=-1></a>bracket before after thing <span class=ot>=</span></span>
<span id=cb18-6><a href=#cb18-6 aria-hidden=true tabindex=-1></a>  mask <span class=op>$</span> \restore <span class=ot>-&gt;</span> <span class=kw>do</span></span>
<span id=cb18-7><a href=#cb18-7 aria-hidden=true tabindex=-1></a>    a <span class=ot>&lt;-</span> before</span>
<span id=cb18-8><a href=#cb18-8 aria-hidden=true tabindex=-1></a>    r <span class=ot>&lt;-</span> restore (thing a) <span class=ot>`onException`</span> after a</span>
<span id=cb18-9><a href=#cb18-9 aria-hidden=true tabindex=-1></a>    _ <span class=ot>&lt;-</span> after a</span>
<span id=cb18-10><a href=#cb18-10 aria-hidden=true tabindex=-1></a>    <span class=fu>return</span> r</span>
<span id=cb18-11><a href=#cb18-11 aria-hidden=true tabindex=-1></a></span>
<span id=cb18-12><a href=#cb18-12 aria-hidden=true tabindex=-1></a><span class=ot>bracket_ ::</span> <span class=dt>IO</span> a <span class=ot>-&gt;</span> <span class=dt>IO</span> b <span class=ot>-&gt;</span> <span class=dt>IO</span> c <span class=ot>-&gt;</span> <span class=dt>IO</span> c</span>
<span id=cb18-13><a href=#cb18-13 aria-hidden=true tabindex=-1></a>bracket_ before after thing <span class=ot>=</span> bracket before (<span class=fu>const</span> after) (<span class=fu>const</span> thing)</span></code></pre></div><p>Very nice<p><footer><i>Any comment? Click on my email below and I'll add it.</i><table><tbody><tr class=ct><td>author<td><span class=bc><a href="mailto:Yann Esposito <yann@esposito.host>?subject=yblog: Haskell Web Application from scratch" class=bo>Yann Esposito &lt;yann@esposito.host></a></span><tr class=cg><td>gpg<td><a href=files/publickey.txt>CB420F8005F1A662</a><tr class=ct><td>tags<td><tr class=cg><td>date<td><tr class=ct><td>rss<td><a href=/rss.xml>RSS</a> (<a href="https://validator.w3.org/feed/check.cgi?url=https%3A%2F%2Fher.esy.fun%2Frss.xml">validate</a>)<tr class=cg><td>size<td><span class=web-file-size> 38K (html 32K, css 5.9K)</span><tr class=ct><td>gz<td><span class=gzweb-file-size> 11K (html 8.8K, css 2.0K)</span><tr class=cg><td>generated<td>2021-04-18T10:16:08.572842Z</table><p></footer></p><br><a href=gemini://her.esy.fun/drafts/XXXX-raw-haskell-web-app/index.gmi><code>=> This article is also available on gemini</code></a></div><div id=postamble class=aq><div class=ak><nav><a href=/index.html>Home</a> |
<a href=/slides.html>Slides</a> |
<a href=/about-me.html>About</a>
<span class=ai>(<a href=https://gitea.esy.fun/yogsototh>code</a>
<a href=https://espial.esy.fun/u:yogsototh>bookmarks</a>
<a href=https://espial.esy.fun/u:yogsototh/notes>notes</a>)</span> |
<a href=#preamble>↑ Top ↑</a></nav></div></div></div>