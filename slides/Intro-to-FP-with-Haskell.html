<!doctype html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Introduction à la Programmation Fonctionnelle avec Haskell</title><meta name=author content="Yann Esposito"><meta name=description content><meta name=keywords content><link rel=stylesheet href=/css/y.css><link rel=alternate type=application/rss+xml href=/rss.xml><link rel=icon href=/favicon.ico><link rel=stylesheet href=/css/slides.css><div class=main><div id=preamble class=status><div class=content><div id=logo><a href=/><svg width="5em" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" stroke="var(--b2)" stroke-width="2" fill="var(--b03)"/><circle cx="32" cy="32" r="12" stroke="var(--r)" stroke-width="2" fill="var(--o)"/><circle cx="32" cy="32" r="6" stroke-width="0" fill="var(--y)"/><ellipse cx="32" cy="14" rx="14" ry="8" stroke-width="0" fill="var(--b3)"/></svg></a></div><h1>Introduction à la Programmation Fonctionnelle avec Haskell</h1><div class=meta><span class=yyydate>&lt;2018-03-15 Thu></span> on
<a href=https://her.esy.fun><span class=author>Yann Esposito</span>'s blog</a></div><div class=abstract></div></div></div><div id=content><h1 id=introduction-à-la-programmation-fonctionnelle-avec-haskell-1>Introduction à la Programmation Fonctionnelle avec Haskell</h1><h3 id=main-io>main :: IO ()</h3><pre><code>████████████████████████████████████████████████████████████████████████████████████
█                                                                                  █
█                        Initialiser l&#39;env de dev                                  █
█                                                                                  █
████████████████████████████████████████████████████████████████████████████████████
</code></pre><p>Install <strong><strong>stack</strong></strong>:<div class=sourceCode id=cb2><pre class="sourceCode bash"><code class="sourceCode bash"><span id=cb2-1><a href=#cb2-1 aria-hidden=true></a><span class=ex>curl</span> -sSL https://get.haskellstack.org/ <span class=kw>|</span> <span class=fu>sh</span></span></code></pre></div><p>Install <strong><strong>nix</strong></strong>:<div class=sourceCode id=cb3><pre class="sourceCode bash"><code class="sourceCode bash"><span id=cb3-1><a href=#cb3-1 aria-hidden=true></a><span class=ex>curl</span> https://nixos.org/nix/install <span class=kw>|</span> <span class=fu>sh</span></span></code></pre></div><h2 id=programmation-fonctionnelle>Programmation Fonctionnelle?</h2><h3 id=von-neumann-architecture-1945>Von Neumann Architecture (1945)</h3><pre><code>           +--------------------------------+
           | +----------------------------+ |
           | | central processing unit    | |
           | | +------------------------+ | |
           | | |     Control Unit       | | |
+------+   | | +------------------------+ | |  +--------+
|input +---&gt; | +------------------------+ | +--&gt; output |
+------+   | | |  Arithmetic/Logic Unit | | |  +--------+
           | | +------------------------+ | |
           | +-------+---^----------------+ |
           |         |   |                  |
           | +-------v---+----------------+ |
           | |     Memory Unit            | |
           | +----------------------------+ |
           +--------------------------------+
</code></pre><p>made with <a href=http://asciiflow.com>http://asciiflow.com</a><h3 id=von-neumann-vs-church>Von Neumann vs Church</h3><ul><li>programmer à partir de la machine (Von Neumann)<ul><li>tire vers l'optimisation<li>mots de bits, caches, détails de bas niveau<li>actions séquentielles<li><strong>1 siècle d'expérience</strong></ul></ul><div class=incremental><ul><li>programmer comme manipulation de symbole (Alonzo Church)<ul><li>tire vers l'abstraction<li>plus proche des représentations mathématiques<li>ordre d'évaluation non imposé<li><strong>4000 ans d'expérience</strong></ul></ul></div><h3 id=histoire>Histoire</h3><ul><li>λ-Calculus, Alonzo Church & Rosser 1936<ul><li>Foundation, explicit side effect no implicit state</ul></ul><div class=incremental><ul><li>LISP (McCarthy 1960)<ul><li>Garbage collection, higher order functions, dynamic typing</ul></ul></div><div class=incremental><ul><li>ML (1969-80)<ul><li>Static typing, Algebraic Datatypes, Pattern matching</ul></ul></div><div class=incremental><ul><li>Miranda (1986) → Haskell (1992‥)<ul><li>Lazy evaluation, pure</ul></ul></div><h2 id=pourquoi-haskell>Pourquoi Haskell?</h2><h3 id=simplicité-par-labstraction>Simplicité par l'abstraction</h3><p><strong><code>/!\</code> SIMPLICITÉ ≠ FACILITÉ <code>/!\</code></strong><ul><li>mémoire (garbage collection)<li>ordre d'évaluation (non strict / lazy)<li>effets de bords (pur)<li>manipulation de code (referential transparency)</ul><div class=incremental><p>Simplicité: Probablement le meilleur indicateur de réussite de projet.</div><h3 id=production-ready>Production Ready™</h3><ul><li>rapide<ul><li>équivalent à Java (~ x2 du C)<li>parfois plus rapide que C<li>bien plus rapide que python et ruby</ul></ul><div class=incremental><ul><li>communauté solide<ul><li>3k comptes sur Haskellers<li>>30k sur reddit <em>(35k rust, 45k go, 50k nodejs, 4k ocaml, 13k clojure)</em><li>libs >12k sur hackage</ul></ul></div><div class=incremental><ul><li>entreprises<ul><li>Facebook (fighting spam, HAXL, …)<li>beaucoup de startups, finance en général</ul></ul></div><div class=incremental><ul><li>milieu académique<ul><li>fondations mathématiques<li>fortes influences des chercheurs<li>tire le langage vers le haut</ul></ul></div><h3 id=tooling>Tooling</h3><ul><li>compilateur (GHC)<li>gestion de projets ; cabal, stack, hpack, etc…<li>IDE / hlint ; rapidité des erreurs en cours de frappe<li>frameworks hors catégorie (servant, yesod)<li>ecosystèmes très matures et inovant<ul><li>Elm (⇒ frontend)<li>Purescript (⇒ frontend)<li>GHCJS (⇒ frontend)<li>Idris (types dépendants)<li>Hackett (typed LISP avec macros)<li>Eta (⇒ JVM)</ul></ul><h3 id=qualité>Qualité</h3><blockquote><p><em>Si ça compile alors il probable que ça marche</em></blockquote><div class=incremental><ul><li>tests unitaires : chercher quelques erreurs manuellements</ul></div><div class=incremental><ul><li><em>test génératifs</em> : chercher des erreurs sur beaucoups de cas générés aléatoirements & aide pour trouver l'erreur sur l'objet le plus simple</ul></div><div class=incremental><ul><li><em>finite state machine generative testing</em> : chercher des erreurs sur le déroulement des actions entre différents agents indépendants</ul></div><div class=incremental><ul><li><strong>preuves</strong>: chercher des erreur sur <strong>TOUTES</strong> les entrées possibles possible à l'aide du système de typage</ul></div><h1 id=premiers-pas-en-haskell>Premiers Pas en Haskell</h1><h3 id=dont-panic>DON'T PANIC</h3><pre><code>██████╗  ██████╗ ███╗   ██╗████████╗    ██████╗  █████╗ ███╗   ██╗██╗ ██████╗██╗
██╔══██╗██╔═══██╗████╗  ██║╚══██╔══╝    ██╔══██╗██╔══██╗████╗  ██║██║██╔════╝██║
██║  ██║██║   ██║██╔██╗ ██║   ██║       ██████╔╝███████║██╔██╗ ██║██║██║     ██║
██║  ██║██║   ██║██║╚██╗██║   ██║       ██╔═══╝ ██╔══██║██║╚██╗██║██║██║     ╚═╝
██████╔╝╚██████╔╝██║ ╚████║   ██║       ██║     ██║  ██║██║ ╚████║██║╚██████╗██╗
╚═════╝  ╚═════╝ ╚═╝  ╚═══╝   ╚═╝       ╚═╝     ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝ ╚═════╝╚═╝
</code></pre><ul><li>Haskell peut être difficile à vraiment maîtriser<li>Trois languages en un:<ul><li>Fonctionnel<li>Imperatif<li>Types</ul><li>Polymorphisme:<ul><li>contexte souvent semi-implicite change le comportement du code.</ul></ul><h3 id=fichier-de-script-isolé>Fichier de script isolé</h3><p>Avec Stack: <a href=https://haskellstack.org>https://haskellstack.org</a><div class=sourceCode id=cb6><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb6-1><a href=#cb6-1 aria-hidden=true></a><span class=pp>#!/usr/bin/env stack</span></span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true></a><span class=co>{- stack script</span></span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true></a><span class=co>   --resolver lts-12.10</span></span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true></a><span class=co>   --install-ghc</span></span>
<span id=cb6-5><a href=#cb6-5 aria-hidden=true></a><span class=co>   --package protolude</span></span>
<span id=cb6-6><a href=#cb6-6 aria-hidden=true></a><span class=co>-}</span></span></code></pre></div><p>Avec Nix: <a href=https://nixos.org/nix/>https://nixos.org/nix/</a><pre class=shell><code>#! /usr/bin/env nix-shell
#! nix-shell -i runghc
#! nix-shell -p &quot;ghc.withPackages (ps: [ ps.protolude ])&quot;
#! nix-shell -I nixpkgs=&quot;https://github.com/NixOS/nixpkgs/archive/18.09.tar.gz&quot;
</code></pre><h3 id=hello-world-13>Hello World! (1/3)</h3><div class=sourceCode id=cb8><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb8-1><a href=#cb8-1 aria-hidden=true></a><span class=co>-- hello.hs</span></span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb8-3><a href=#cb8-3 aria-hidden=true></a>main <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=st>&quot;Hello World!&quot;</span></span></code></pre></div><pre><code>&gt; chmod +x hello.hs
&gt; ./hello.hs
Hello World!
</code></pre><pre><code>&gt; stack ghc -- hello.hs
&gt; ./hello
Hello World!
</code></pre><h3 id=hello-world-23>Hello World! (2/3)</h3><div class=sourceCode id=cb11><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb11-1><a href=#cb11-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb11-2><a href=#cb11-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=st>&quot;Hello World!&quot;</span></span></code></pre></div><ul><li><code>::</code> de type ;<li>le type de <code>main</code> est <code>IO ()</code>.<li><code>=</code> égalité (la vrai, on peut interchanger ce qu'il y a des deux cotés) ;<li>le type de <code>putStrLn</code> est <code>String -> IO ()</code> ;<li>application de fonction <code>f x</code> pas <code>f(x)</code>, pas de parenthèse nécessaire ;</ul><h3 id=hello-world-33>Hello World! (3/3)</h3><div class=sourceCode id=cb12><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb12-1><a href=#cb12-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb12-2><a href=#cb12-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=fu>putStrLn</span> <span class=st>&quot;Hello World!&quot;</span></span></code></pre></div><ul><li>Le type <code>IO a</code> signifie: C'est une description d'une procédure qui quand elle est évaluée peut faire des actions d'IO qui retournera une valeur de type <code>a</code> ;<li><code>main</code> est le nom du point d'entrée du programme ;<li>Haskell runtime va chercher pour <code>main</code> et l'exécute.</ul><h2 id=what-is-your-name>What is your name?</h2><h3 id=what-is-your-name-12>What is your name? (1/2)</h3><div class=sourceCode id=cb13><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb13-1><a href=#cb13-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb13-2><a href=#cb13-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb13-3><a href=#cb13-3 aria-hidden=true></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Hello! What is your name?&quot;</span></span>
<span id=cb13-4><a href=#cb13-4 aria-hidden=true></a>  name <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb13-5><a href=#cb13-5 aria-hidden=true></a>  <span class=kw>let</span> output <span class=ot>=</span> <span class=st>&quot;Nice to meet you, &quot;</span> <span class=op>++</span> name <span class=op>++</span> <span class=st>&quot;!&quot;</span></span>
<span id=cb13-6><a href=#cb13-6 aria-hidden=true></a>  <span class=fu>putStrLn</span> output</span></code></pre></div><div class=incremental><ul><li>l'indentation est importante !<li><code>do</code> commence une syntaxe spéciale qui permet de séquencer des actions <code>IO</code> ;<li>le type de <code>getLine</code> est <code>IO String</code> ;<li><code>IO String</code> signifie: Ceci est la description d'une procédure qui lorsqu'elle est évaluée peut faire des actions IO et retourne une valeur de type <code>String</code>.</ul></div><h3 id=what-is-your-name-22>What is your name? (2/2)</h3><div class=sourceCode id=cb14><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb14-1><a href=#cb14-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb14-2><a href=#cb14-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb14-3><a href=#cb14-3 aria-hidden=true></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Hello! What is your name?&quot;</span></span>
<span id=cb14-4><a href=#cb14-4 aria-hidden=true></a>  name <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb14-5><a href=#cb14-5 aria-hidden=true></a>  <span class=kw>let</span> output <span class=ot>=</span> <span class=st>&quot;Nice to meet you, &quot;</span> <span class=op>++</span> name <span class=op>++</span> <span class=st>&quot;!&quot;</span></span>
<span id=cb14-6><a href=#cb14-6 aria-hidden=true></a>  <span class=fu>putStrLn</span> output</span></code></pre></div><ul><li>le type de <code>getLine</code> est <code>IO String</code><li>le type de <code>name</code> est <code>String</code><li><code>&lt;-</code> est une syntaxe spéciale qui n'apparait que dans la notation <code>do</code><li><code>&lt;-</code> signifie: évalue la procédure et attache la valeur renvoyée dans le nom à gauche de <code>&lt;-</code><li><code>let &lt;name> = &lt;expr></code> signifie que <code>name</code> est interchangeable avec <code>expr</code> pour le reste du bloc <code>do</code>.<li>dans un bloc <code>do</code>, <code>let</code> n'a pas besoin d'être accompagné par <code>in</code> à la fin.</ul><h2 id=erreurs-classiques>Erreurs classiques</h2><h3 id=erreur-classique-1>Erreur classique #1</h3><div class=sourceCode id=cb15><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb15-1><a href=#cb15-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb15-2><a href=#cb15-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb15-3><a href=#cb15-3 aria-hidden=true></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Hello! What is your name?&quot;</span></span>
<span id=cb15-4><a href=#cb15-4 aria-hidden=true></a>  <span class=kw>let</span> output <span class=ot>=</span> <span class=st>&quot;Nice to meet you, &quot;</span> <span class=op>++</span> <span class=fu>getLine</span> <span class=op>++</span> <span class=st>&quot;!&quot;</span></span>
<span id=cb15-5><a href=#cb15-5 aria-hidden=true></a>  <span class=fu>putStrLn</span> output</span></code></pre></div><pre><code>/Users/yaesposi/.deft/pres-haskell/name.hs:6:40: warning: [-Wdeferred-type-errors]
    • Couldn&#39;t match expected type ‘[Char]’
                  with actual type ‘IO String’
    • In the first argument of ‘(++)’, namely ‘getLine’
      In the second argument of ‘(++)’, namely ‘getLine ++ &quot;!&quot;’
      In the expression: &quot;Nice to meet you, &quot; ++ getLine ++ &quot;!&quot;
  |
6 |   let output = &quot;Nice to meet you, &quot; ++ getLine ++ &quot;!&quot;
  |                                        ^^^^^^^
Ok, one module loaded.
</code></pre><h3 id=erreur-classique-1-1>Erreur classique #1</h3><ul><li><code>String</code> est <code>[Char]</code><li>Haskell n'arrive pas à faire matcher le type <code>String</code> avec <code>IO String</code>.<li><code>IO a</code> et <code>a</code> sont différents</ul><h3 id=erreur-classique-2>Erreur classique #2</h3><div class=sourceCode id=cb17><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb17-1><a href=#cb17-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb17-2><a href=#cb17-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb17-3><a href=#cb17-3 aria-hidden=true></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Hello! What is your name?&quot;</span></span>
<span id=cb17-4><a href=#cb17-4 aria-hidden=true></a>  name <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb17-5><a href=#cb17-5 aria-hidden=true></a>  <span class=fu>putStrLn</span>  <span class=st>&quot;Nice to meet you, &quot;</span> <span class=op>++</span> name <span class=op>++</span> <span class=st>&quot;!&quot;</span></span></code></pre></div><pre><code>/Users/yaesposi/.deft/pres-haskell/name.hs:7:3: warning: [-Wdeferred-type-errors]
    • Couldn&#39;t match expected type ‘[Char]’ with actual type ‘IO ()’
    • In the first argument of ‘(++)’, namely
        ‘putStrLn &quot;Nice to meet you, &quot;’
      In a stmt of a &#39;do&#39; block:
        putStrLn &quot;Nice to meet you, &quot; ++ name ++ &quot;!&quot;
      In the expression:
        do putStrLn &quot;Hello! What is your name?&quot;
           name &lt;- getLine
           putStrLn &quot;Nice to meet you, &quot; ++ name ++ &quot;!&quot;
  |
7 |   putStrLn &quot;Nice to meet you, &quot; ++ name ++ &quot;!&quot;
</code></pre><h3 id=erreur-classique-2-fix>Erreur classique #2 (fix)</h3><ul><li>Des parenthèses sont nécessaires<li>L'application de fonction se fait de gauche à droite</ul><div class=sourceCode id=cb19><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb19-1><a href=#cb19-1 aria-hidden=true></a><span class=ot>main ::</span> <span class=dt>IO</span> ()</span>
<span id=cb19-2><a href=#cb19-2 aria-hidden=true></a>main <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb19-3><a href=#cb19-3 aria-hidden=true></a>  <span class=fu>putStrLn</span> <span class=st>&quot;Hello! What is your name?&quot;</span></span>
<span id=cb19-4><a href=#cb19-4 aria-hidden=true></a>  name <span class=ot>&lt;-</span> <span class=fu>getLine</span></span>
<span id=cb19-5><a href=#cb19-5 aria-hidden=true></a>  <span class=fu>putStrLn</span> (<span class=st>&quot;Nice to meet you, &quot;</span> <span class=op>++</span> name <span class=op>++</span> <span class=st>&quot;!&quot;</span>)</span></code></pre></div><h1 id=concepts-avec-exemples>Concepts avec exemples</h1><h3 id=concepts>Concepts</h3><ul><li><em>style déclaratif & récursif</em><li><em>immutabilité</em><li><em>pureté</em> (par défaut)<li><em>evaluation paraisseuse</em> (par défaut)<li><em>ADT & typage polymorphique</em></ul><h3 id=style-déclaratif-récursif><em>Style déclaratif & récursif</em></h3><div class=sourceCode id=cb20><pre class="sourceCode python"><code class="sourceCode python"><span id=cb20-1><a href=#cb20-1 aria-hidden=true></a><span class=op>&gt;&gt;&gt;</span> x<span class=op>=</span><span class=dv>0</span></span>
<span id=cb20-2><a href=#cb20-2 aria-hidden=true></a>... <span class=cf>for</span> i <span class=kw>in</span> <span class=bu>range</span>(<span class=dv>1</span>,<span class=dv>11</span>):</span>
<span id=cb20-3><a href=#cb20-3 aria-hidden=true></a>...     tmp <span class=op>=</span> i<span class=op>*</span>i</span>
<span id=cb20-4><a href=#cb20-4 aria-hidden=true></a>...     <span class=cf>if</span> tmp<span class=op>%</span><span class=dv>2</span> <span class=op>==</span> <span class=dv>0</span>:</span>
<span id=cb20-5><a href=#cb20-5 aria-hidden=true></a>...       x <span class=op>+=</span> tmp</span>
<span id=cb20-6><a href=#cb20-6 aria-hidden=true></a><span class=op>&gt;&gt;&gt;</span> x</span>
<span id=cb20-7><a href=#cb20-7 aria-hidden=true></a><span class=dv>220</span></span></code></pre></div><div class=sourceCode id=cb21><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb21-1><a href=#cb21-1 aria-hidden=true></a><span class=co>-- (.) composition (de droite à gauche)</span></span>
<span id=cb21-2><a href=#cb21-2 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=fu>sum</span> <span class=op>.</span> <span class=fu>filter</span> <span class=fu>even</span> <span class=op>.</span> <span class=fu>map</span> (<span class=op>^</span><span class=dv>2</span>) <span class=op>$</span> [<span class=dv>1</span><span class=op>..</span><span class=dv>10</span>]</span>
<span id=cb21-3><a href=#cb21-3 aria-hidden=true></a><span class=dv>220</span></span>
<span id=cb21-4><a href=#cb21-4 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=op>:</span>set <span class=op>-</span><span class=dt>XNoImplicitPrelude</span></span>
<span id=cb21-5><a href=#cb21-5 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=kw>import</span> <span class=dt>Protolude</span></span>
<span id=cb21-6><a href=#cb21-6 aria-hidden=true></a><span class=co>-- (&amp;) flipped fn application (de gauche à droite)</span></span>
<span id=cb21-7><a href=#cb21-7 aria-hidden=true></a><span class=dt>Protolude</span><span class=op>&gt;</span> [<span class=dv>1</span><span class=op>..</span><span class=dv>10</span>] <span class=op>&amp;</span> <span class=fu>map</span> (<span class=op>^</span><span class=dv>2</span>) <span class=op>&amp;</span> <span class=fu>filter</span> <span class=fu>even</span> <span class=op>&amp;</span> <span class=fu>sum</span></span>
<span id=cb21-8><a href=#cb21-8 aria-hidden=true></a><span class=dv>220</span></span></code></pre></div><h3 id=style-déclaratif-récursif-1><em>Style déclaratif & récursif</em></h3><div class=sourceCode id=cb22><pre class="sourceCode python"><code class="sourceCode python"><span id=cb22-1><a href=#cb22-1 aria-hidden=true></a><span class=op>&gt;&gt;&gt;</span> x<span class=op>=</span><span class=dv>0</span></span>
<span id=cb22-2><a href=#cb22-2 aria-hidden=true></a>... <span class=cf>for</span> i <span class=kw>in</span> <span class=bu>range</span>(<span class=dv>1</span>,<span class=dv>11</span>):</span>
<span id=cb22-3><a href=#cb22-3 aria-hidden=true></a>...     j <span class=op>=</span> i<span class=op>*</span><span class=dv>3</span></span>
<span id=cb22-4><a href=#cb22-4 aria-hidden=true></a>...     tmp <span class=op>=</span> j<span class=op>*</span>j</span>
<span id=cb22-5><a href=#cb22-5 aria-hidden=true></a>...     <span class=cf>if</span> tmp<span class=op>%</span><span class=dv>2</span> <span class=op>==</span> <span class=dv>0</span>:</span>
<span id=cb22-6><a href=#cb22-6 aria-hidden=true></a>...       x <span class=op>+=</span> tmp</span></code></pre></div><div class=sourceCode id=cb23><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb23-1><a href=#cb23-1 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=fu>sum</span> <span class=op>.</span> <span class=fu>filter</span> <span class=fu>even</span> <span class=op>.</span> <span class=fu>map</span> (<span class=op>^</span><span class=dv>2</span>) <span class=op>.</span> <span class=fu>map</span> (<span class=op>*</span><span class=dv>3</span>) <span class=op>$</span> [<span class=dv>1</span><span class=op>..</span><span class=dv>10</span>]</span>
<span id=cb23-2><a href=#cb23-2 aria-hidden=true></a><span class=dt>Protolude</span><span class=op>&gt;</span> [<span class=dv>1</span><span class=op>..</span><span class=dv>10</span>] <span class=op>&amp;</span> <span class=fu>map</span> (<span class=op>*</span><span class=dv>3</span>) <span class=op>&amp;</span> <span class=fu>map</span> (<span class=op>^</span><span class=dv>2</span>) <span class=op>&amp;</span> <span class=fu>filter</span> <span class=fu>even</span> <span class=op>&amp;</span> <span class=fu>sum</span></span></code></pre></div><h3 id=style-déclaratif-récursif-2><em>Style déclaratif & récursif</em></h3><ul><li>Contrairement aux languages impératifs la récursion n'est généralement pas chère.<li>tail recursive function, mais aussi à l'aide de la lazyness</ul><h3 id=imutabilité><em>Imutabilité</em></h3><div class=sourceCode id=cb24><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb24-1><a href=#cb24-1 aria-hidden=true></a><span class=co>-- | explicit recursivity</span></span>
<span id=cb24-2><a href=#cb24-2 aria-hidden=true></a><span class=ot>incrementAllEvenNumbers ::</span> [<span class=dt>Int</span>] <span class=ot>-&gt;</span> [<span class=dt>Int</span>]</span>
<span id=cb24-3><a href=#cb24-3 aria-hidden=true></a>incrementAllEvenNumbers (x<span class=op>:</span>xs) <span class=ot>=</span> y<span class=op>:</span>incrementAllEvenNumbers xs</span>
<span id=cb24-4><a href=#cb24-4 aria-hidden=true></a>  <span class=kw>where</span> y <span class=ot>=</span> <span class=kw>if</span> <span class=fu>even</span> x <span class=kw>then</span> x<span class=op>+</span><span class=dv>1</span> <span class=kw>else</span> x</span>
<span id=cb24-5><a href=#cb24-5 aria-hidden=true></a></span>
<span id=cb24-6><a href=#cb24-6 aria-hidden=true></a><span class=co>-- | better with use of higher order functions</span></span>
<span id=cb24-7><a href=#cb24-7 aria-hidden=true></a><span class=ot>incrementAllEvenNumbers&#39; ::</span> [<span class=dt>Int</span>] <span class=ot>-&gt;</span> [<span class=dt>Int</span>]</span>
<span id=cb24-8><a href=#cb24-8 aria-hidden=true></a>incrementAllEvenNumbers&#39; ls <span class=ot>=</span> <span class=fu>map</span> incrementIfEven ls</span>
<span id=cb24-9><a href=#cb24-9 aria-hidden=true></a>  <span class=kw>where</span></span>
<span id=cb24-10><a href=#cb24-10 aria-hidden=true></a><span class=ot>   incrementIfEven ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span></span>
<span id=cb24-11><a href=#cb24-11 aria-hidden=true></a>   incrementIfEven x <span class=ot>=</span> <span class=kw>if</span> <span class=fu>even</span> x <span class=kw>then</span> x<span class=op>+</span><span class=dv>1</span> <span class=kw>else</span> x</span></code></pre></div><h3 id=pureté-function-vs-proceduresubroutines><em>Pureté</em>: Function vs Procedure/Subroutines</h3><ul><li>Une <em>fonction</em> n'a pas d'effet de bord<li>Une <em>Procedure</em> ou <em>subroutine</em> but engendrer des effets de bords lors de son évaluation</ul><h3 id=pureté-function-vs-proceduresubroutines-exemple><em>Pureté</em>: Function vs Procedure/Subroutines (exemple)</h3><div class=sourceCode id=cb25><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb25-1><a href=#cb25-1 aria-hidden=true></a><span class=ot>dist ::</span> <span class=dt>Double</span> <span class=ot>-&gt;</span> <span class=dt>Double</span> <span class=ot>-&gt;</span> <span class=dt>Double</span></span>
<span id=cb25-2><a href=#cb25-2 aria-hidden=true></a>dist x y <span class=ot>=</span> <span class=fu>sqrt</span> (x<span class=op>**</span><span class=dv>2</span> <span class=op>+</span> y<span class=op>**</span><span class=dv>2</span>)</span></code></pre></div><div class=sourceCode id=cb26><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb26-1><a href=#cb26-1 aria-hidden=true></a><span class=ot>getName ::</span> <span class=dt>IO</span> <span class=dt>String</span></span>
<span id=cb26-2><a href=#cb26-2 aria-hidden=true></a>getName <span class=ot>=</span> readLine</span></code></pre></div><ul><li><strong>IO a</strong> ⇒ <strong>IMPUR</strong> ; effets de bords hors evaluation :<ul><li>lire un fichier ;<li>écrire sur le terminal ;<li>changer la valeur d'une variable en RAM est impur.</ul></ul><h3 id=pureté-gain-paralellisation-gratuite><em>Pureté</em>: Gain, paralellisation gratuite</h3><div class=sourceCode id=cb27><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb27-1><a href=#cb27-1 aria-hidden=true></a><span class=kw>import</span> <span class=dt>Foreign.Lib</span> (f)</span>
<span id=cb27-2><a href=#cb27-2 aria-hidden=true></a><span class=co>--  f :: Int -&gt; Int</span></span>
<span id=cb27-3><a href=#cb27-3 aria-hidden=true></a><span class=co>--  f = ???</span></span>
<span id=cb27-4><a href=#cb27-4 aria-hidden=true></a></span>
<span id=cb27-5><a href=#cb27-5 aria-hidden=true></a>foo <span class=ot>=</span> <span class=fu>sum</span> results</span>
<span id=cb27-6><a href=#cb27-6 aria-hidden=true></a>  <span class=kw>where</span> results <span class=ot>=</span> <span class=fu>map</span> f [<span class=dv>1</span><span class=op>..</span><span class=dv>100</span>]</span></code></pre></div><div class=incremental><p><strong><code>pmap</code> FTW!!!!! Assurance d'avoir le même résultat avec 32 cœurs</strong><div class=sourceCode id=cb28><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb28-1><a href=#cb28-1 aria-hidden=true></a><span class=kw>import</span> <span class=dt>Foreign.Lib</span> (f)</span>
<span id=cb28-2><a href=#cb28-2 aria-hidden=true></a><span class=co>--  f :: Int -&gt; Int</span></span>
<span id=cb28-3><a href=#cb28-3 aria-hidden=true></a><span class=co>--  f = ???</span></span>
<span id=cb28-4><a href=#cb28-4 aria-hidden=true></a></span>
<span id=cb28-5><a href=#cb28-5 aria-hidden=true></a>foo <span class=ot>=</span> <span class=fu>sum</span> results</span>
<span id=cb28-6><a href=#cb28-6 aria-hidden=true></a>  <span class=kw>where</span> results <span class=ot>=</span> pmap f [<span class=dv>1</span><span class=op>..</span><span class=dv>100</span>]</span></code></pre></div></div><h3 id=pureté-structures-de-données-immuable><em>Pureté</em>: Structures de données immuable</h3><p>Purely functional data structures, <em>Chris Okasaki</em><p>Thèse en 1996, et un livre.<p>Opérations sur les listes, tableaux, arbres de complexité amortie equivalent ou proche (pire des cas facteur log(n)) de celle des structures de données muables.<h3 id=évaluation-parraisseuse-stratégies-dévaluations><em>Évaluation parraisseuse</em>: Stratégies d'évaluations</h3><p><code>(h (f a) (g b))</code> peut s'évaluer:<ul><li><code>a</code> → <code>(f a)</code> → <code>b</code> → <code>(g b)</code> → <code>(h (f a) (g b))</code><li><code>b</code> → <code>a</code> → <code>(g b)</code> → <code>(f a)</code> → <code>(h (f a) (g b))</code><li><code>a</code> et <code>b</code> en parallèle puis <code>(f a)</code> et <code>(g b)</code> en parallèle et finallement <code>(h (f a) (g b))</code><li><code>h</code> → <code>(f a)</code> seulement si nécessaire et puis <code>(g b)</code> seulement si nécessaire</ul><p>Par exemple: <code>(def h (λx.λy.(+ x x)))</code> il n'est pas nécessaire d'évaluer <code>y</code>, dans notre cas <code>(g b)</code><h3 id=évaluation-parraisseuse-exemple><em>Évaluation parraisseuse</em>: Exemple</h3><div class=sourceCode id=cb29><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb29-1><a href=#cb29-1 aria-hidden=true></a>quickSort [] <span class=ot>=</span> []</span>
<span id=cb29-2><a href=#cb29-2 aria-hidden=true></a>quickSort (x<span class=op>:</span>xs) <span class=ot>=</span> quickSort (<span class=fu>filter</span> (<span class=op>&lt;</span>x) xs)</span>
<span id=cb29-3><a href=#cb29-3 aria-hidden=true></a>                   <span class=op>++</span> [x]</span>
<span id=cb29-4><a href=#cb29-4 aria-hidden=true></a>                   <span class=op>++</span> quickSort (<span class=fu>filter</span> (<span class=op>&gt;=</span>x) xs)</span>
<span id=cb29-5><a href=#cb29-5 aria-hidden=true></a></span>
<span id=cb29-6><a href=#cb29-6 aria-hidden=true></a><span class=fu>minimum</span> list <span class=ot>=</span> <span class=fu>head</span> (quickSort list)</span></code></pre></div><p>Un appel à <code>minimum longList</code> ne vas pas ordonner toute la liste. Le travail s'arrêtera dès que le premier élément de la liste ordonnée sera trouvé.<p><code>take k (quickSort list)</code> est en <code>O(n + k log k)</code> où <code>n = length list</code>. Alors qu'avec une évaluation stricte: <code>O(n log n)</code>.<h3 id=évaluation-parraisseuse-structures-de-données-infinies-zip><em>Évaluation parraisseuse</em>: Structures de données infinies (zip)</h3><div class=sourceCode id=cb30><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb30-1><a href=#cb30-1 aria-hidden=true></a><span class=fu>zip</span><span class=ot> ::</span> [a] <span class=ot>-&gt;</span> [b] <span class=ot>-&gt;</span> [(a,b)]</span>
<span id=cb30-2><a href=#cb30-2 aria-hidden=true></a><span class=fu>zip</span> [] _  <span class=ot>=</span> []</span>
<span id=cb30-3><a href=#cb30-3 aria-hidden=true></a><span class=fu>zip</span> _  [] <span class=ot>=</span> []</span>
<span id=cb30-4><a href=#cb30-4 aria-hidden=true></a><span class=fu>zip</span> (x<span class=op>:</span>xs) (y<span class=op>:</span>ys) <span class=ot>=</span> (x,y)<span class=op>:</span><span class=fu>zip</span> xs ys</span></code></pre></div><div class=sourceCode id=cb31><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb31-1><a href=#cb31-1 aria-hidden=true></a><span class=fu>zip</span> [<span class=dv>1</span><span class=op>..</span>] [<span class=ch>&#39;a&#39;</span>,<span class=ch>&#39;b&#39;</span>,<span class=ch>&#39;c&#39;</span>]</span></code></pre></div><p>s'arrête et renvoie :<div class=sourceCode id=cb32><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb32-1><a href=#cb32-1 aria-hidden=true></a>[(<span class=dv>1</span>,<span class=ch>&#39;a&#39;</span>), (<span class=dv>2</span>,<span class=ch>&#39;b&#39;</span>), (<span class=dv>3</span>, <span class=ch>&#39;c&#39;</span>)]</span></code></pre></div><h3 id=évaluation-parraisseuse-structures-de-données-infinies-2><em>Évaluation parraisseuse</em>: Structures de données infinies (2)</h3><div class=sourceCode id=cb33><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb33-1><a href=#cb33-1 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=fu>zipWith</span> (<span class=op>+</span>) [<span class=dv>0</span>,<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>] [<span class=dv>10</span>,<span class=dv>100</span>,<span class=dv>1000</span>]</span>
<span id=cb33-2><a href=#cb33-2 aria-hidden=true></a>[<span class=dv>10</span>,<span class=dv>101</span>,<span class=dv>1002</span>]</span>
<span id=cb33-3><a href=#cb33-3 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=fu>take</span> <span class=dv>3</span> [<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>4</span>,<span class=dv>5</span>,<span class=dv>6</span>,<span class=dv>7</span>,<span class=dv>8</span>,<span class=dv>9</span>]</span>
<span id=cb33-4><a href=#cb33-4 aria-hidden=true></a>[<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>]</span></code></pre></div><div class=sourceCode id=cb34><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb34-1><a href=#cb34-1 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> fib <span class=ot>=</span> <span class=dv>0</span><span class=op>:</span><span class=dv>1</span><span class=op>:</span>(<span class=fu>zipWith</span> (<span class=op>+</span>) fib (<span class=fu>tail</span> fib))</span>
<span id=cb34-2><a href=#cb34-2 aria-hidden=true></a><span class=dt>Prelude</span><span class=op>&gt;</span> <span class=fu>take</span> <span class=dv>10</span> fib</span>
<span id=cb34-3><a href=#cb34-3 aria-hidden=true></a>[<span class=dv>0</span>,<span class=dv>1</span>,<span class=dv>1</span>,<span class=dv>2</span>,<span class=dv>3</span>,<span class=dv>5</span>,<span class=dv>8</span>,<span class=dv>13</span>,<span class=dv>21</span>,<span class=dv>34</span>]</span></code></pre></div><h3 id=adt-typage-polymorphique><em>ADT & Typage polymorphique</em></h3><p>Algebraic Data Types.<div class=sourceCode id=cb35><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb35-1><a href=#cb35-1 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Void</span> <span class=ot>=</span> <span class=dt>Void</span> <span class=dt>Void</span> <span class=co>-- 0 valeur possible!</span></span>
<span id=cb35-2><a href=#cb35-2 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Unit</span> <span class=ot>=</span> ()        <span class=co>-- 1 seule valeur possible</span></span>
<span id=cb35-3><a href=#cb35-3 aria-hidden=true></a></span>
<span id=cb35-4><a href=#cb35-4 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Product</span> x y <span class=ot>=</span> <span class=dt>P</span> x y</span>
<span id=cb35-5><a href=#cb35-5 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Sum</span> x y <span class=ot>=</span> <span class=dt>S1</span> x <span class=op>|</span> <span class=dt>S2</span> y</span></code></pre></div><p>Soit <code>#x</code> le nombre de valeurs possibles pour le type <code>x</code> alors:<ul><li><code>#(Product x y) = #x * #y</code><li><code>#(Sum x y) = #x + #y</code></ul><h3 id=adt-typage-polymorphique-inférence-de-type><em>ADT & Typage polymorphique</em>: Inférence de type</h3><p>À partir de :<div class=sourceCode id=cb36><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb36-1><a href=#cb36-1 aria-hidden=true></a><span class=fu>zip</span> [] _  <span class=ot>=</span> []</span>
<span id=cb36-2><a href=#cb36-2 aria-hidden=true></a><span class=fu>zip</span> _  [] <span class=ot>=</span> []</span>
<span id=cb36-3><a href=#cb36-3 aria-hidden=true></a><span class=fu>zip</span> (x<span class=op>:</span>xs) (y<span class=op>:</span>ys) <span class=ot>=</span> (x,y)<span class=op>:</span><span class=fu>zip</span> xs ys</span></code></pre></div><p>le compilateur peut déduire:<div class=sourceCode id=cb37><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb37-1><a href=#cb37-1 aria-hidden=true></a><span class=fu>zip</span><span class=ot> ::</span> [a] <span class=ot>-&gt;</span> [b] <span class=ot>-&gt;</span> [(a,b)]</span></code></pre></div><h2 id=composabilité>Composabilité</h2><h3 id=composabilité-vs-modularité>Composabilité vs Modularité</h3><p>Modularité: soit un <code>a</code> et un <code>b</code>, je peux faire un <code>c</code>. ex: x un graphique, y une barre de menu => une page <code>let page = mkPage ( graphique, menu )</code><p>Composabilité: soit deux <code>a</code> je peux faire un autre <code>a</code>. ex: x un widget, y un widget => un widget <code>let page = x &lt;+> y</code><p>Gain d'abstraction, moindre coût.<p><strong>Hypothèses fortes sur les <code>a</code></strong><h3 id=exemples>Exemples</h3><ul><li><p><strong>Semi-groupes</strong> 〈+〉<li><p><strong>Monoides</strong> 〈0,+〉<li><p><strong>Catégories</strong> 〈obj(C),hom(C),∘〉<li><p>Foncteurs <code>fmap</code> (<code>(&lt;$>)</code>)<li><p>Foncteurs Applicatifs <code>ap</code> (<code>(&lt;*>)</code>)<li><p>Monades <code>join</code><li><p>Traversables <code>map</code><li><p>Foldables <code>reduce</code></ul><h1 id=catégories-de-bugs-évités-avec-haskell>Catégories de bugs évités avec Haskell</h1><h3 id=real-productions-bugs>Real Productions Bugs™</h3><p>Bug vu des dizaines de fois en prod malgré:<ol><li>specifications fonctionnelles<li>spécifications techniques<li>tests unitaires<li>3 envs, dev, recette/staging/pre-prod, prod<li>Équipe de QA qui teste en recette</ol><p>Solutions simples.<h3 id=null-pointer-exception-erreur-classique-1><strong><strong>Null Pointer Exception</strong></strong>: Erreur classique (1)</h3><p>Au début du projet :<div class=sourceCode id=cb38><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id=cb38-1><a href=#cb38-1 aria-hidden=true></a>int <span class=fu>foo</span>( x ) {</span>
<span id=cb38-2><a href=#cb38-2 aria-hidden=true></a>  <span class=cf>return</span> x <span class=op>+</span> <span class=dv>1</span><span class=op>;</span></span>
<span id=cb38-3><a href=#cb38-3 aria-hidden=true></a>}</span></code></pre></div><h3 id=null-pointer-exception-erreur-classique-2><strong><strong>Null Pointer Exception</strong></strong>: Erreur classique (2)</h3><p>Après quelques semaines/mois/années :<div class=sourceCode id=cb39><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id=cb39-1><a href=#cb39-1 aria-hidden=true></a><span class=im>import</span> do_shit_1 <span class=im>from</span> <span class=st>&quot;foreign-module&quot;</span><span class=op>;</span></span>
<span id=cb39-2><a href=#cb39-2 aria-hidden=true></a>int <span class=fu>foo</span>( x ) {</span>
<span id=cb39-3><a href=#cb39-3 aria-hidden=true></a>  <span class=op>...</span></span>
<span id=cb39-4><a href=#cb39-4 aria-hidden=true></a>  <span class=kw>var</span> y <span class=op>=</span> <span class=fu>do_shit_1</span>(x)<span class=op>;</span></span>
<span id=cb39-5><a href=#cb39-5 aria-hidden=true></a>  <span class=op>...</span></span>
<span id=cb39-6><a href=#cb39-6 aria-hidden=true></a>  <span class=cf>return</span> <span class=fu>do_shit_20</span>(y)</span>
<span id=cb39-7><a href=#cb39-7 aria-hidden=true></a>}</span>
<span id=cb39-8><a href=#cb39-8 aria-hidden=true></a><span class=op>...</span></span>
<span id=cb39-9><a href=#cb39-9 aria-hidden=true></a><span class=kw>var</span> val <span class=op>=</span> <span class=fu>foo</span>(<span class=dv>26</span><span class=op>/</span><span class=dv>2334</span> <span class=op>-</span> <span class=bu>Math</span><span class=op>.</span><span class=fu>sqrt</span>(<span class=dv>2</span>))<span class=op>;</span></span></code></pre></div><div class=incremental><pre><code>███████       █████    ███     ███ ███       ███ ███ ███ ███ ███ ███
███   ██    ███   ███  ███     ███ ████     ████ ███ ███ ███ ███ ███
███   ██   ███     ███ ███     ███ █████   █████ ███ ███ ███ ███ ███
███████    ███     ███ ███     ███ ███ █████ ███ ███ ███ ███ ███ ███
███   ███  ███     ███ ███     ███ ███  ███  ███ ███ ███ ███ ███ ███
███    ███ ███     ███ ███     ███ ███   █   ███  █   █   █   █   █
███   ███   ███   ███   ███   ███  ███       ███
███████       █████       █████    ███       ███ ███ ███ ███ ███ ███
</code></pre><table><tbody><tr class=odd><td><strong>Null Pointer Exception</strong></table></div><h3 id=null-pointer-exception-data-type-maybe>Null Pointer Exception: Data type <code>Maybe</code></h3><div class=sourceCode id=cb41><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb41-1><a href=#cb41-1 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Maybe</span> a <span class=ot>=</span> <span class=dt>Just</span> a <span class=op>|</span> <span class=dt>Nothing</span></span>
<span id=cb41-2><a href=#cb41-2 aria-hidden=true></a><span class=op>...</span></span>
<span id=cb41-3><a href=#cb41-3 aria-hidden=true></a><span class=ot>foo ::</span> <span class=dt>Maybe</span> a</span>
<span id=cb41-4><a href=#cb41-4 aria-hidden=true></a><span class=op>...</span></span>
<span id=cb41-5><a href=#cb41-5 aria-hidden=true></a>myFunc x <span class=ot>=</span> <span class=kw>let</span> t <span class=ot>=</span> foo x <span class=kw>in</span></span>
<span id=cb41-6><a href=#cb41-6 aria-hidden=true></a>  <span class=kw>case</span> t <span class=kw>of</span></span>
<span id=cb41-7><a href=#cb41-7 aria-hidden=true></a>    <span class=dt>Just</span> someValue <span class=ot>-&gt;</span> doThingsWith someValue</span>
<span id=cb41-8><a href=#cb41-8 aria-hidden=true></a>    <span class=dt>Nothing</span> <span class=ot>-&gt;</span> doThingWhenNothingIsReturned</span></code></pre></div><p>Le compilateur oblige à tenir compte des cas particuliers! Impossible d'oublier.<h3 id=null-pointer-exception-etat>Null Pointer Exception: Etat</h3><ul><li>Rendre impossibe de fabriquer un état qui devrait être impossible d'avoir.<li>Pour aller plus loin voir, FRP, CQRS/ES, Elm-architecture, etc…</ul><h3 id=erreur-due-à-une-typo>Erreur due à une typo</h3><div class=sourceCode id=cb42><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb42-1><a href=#cb42-1 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Foo</span> x <span class=ot>=</span> <span class=dt>LongNameWithPossibleError</span> x</span>
<span id=cb42-2><a href=#cb42-2 aria-hidden=true></a><span class=op>...</span></span>
<span id=cb42-3><a href=#cb42-3 aria-hidden=true></a>foo (<span class=dt>LongNameWithPosibleError</span> x) <span class=ot>=</span> <span class=op>...</span></span></code></pre></div><p><strong>Erreur à la compilation</strong>: Le nom d'un champ n'est pas une string (voir les objets JSON).<h3 id=echange-de-parameters>Echange de parameters</h3><div class=sourceCode id=cb43><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb43-1><a href=#cb43-1 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Personne</span> <span class=ot>=</span> <span class=dt>Personne</span> {<span class=ot> uid ::</span> <span class=dt>Int</span>,<span class=ot> age ::</span> <span class=dt>Int</span> }</span>
<span id=cb43-2><a href=#cb43-2 aria-hidden=true></a><span class=ot>foo ::</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Personne</span> <span class=co>-- ??? uid ou age?</span></span></code></pre></div><div class=sourceCode id=cb44><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb44-1><a href=#cb44-1 aria-hidden=true></a><span class=kw>newtype</span> <span class=dt>UID</span> <span class=ot>=</span> <span class=dt>UID</span> <span class=dt>Int</span> <span class=kw>deriving</span> (<span class=dt>Eq</span>)</span>
<span id=cb44-2><a href=#cb44-2 aria-hidden=true></a><span class=kw>data</span> <span class=dt>Personne</span> <span class=ot>=</span> <span class=dt>Personne</span> {<span class=ot> uid ::</span> <span class=dt>UID</span>,<span class=ot> age ::</span> <span class=dt>Int</span> }</span>
<span id=cb44-3><a href=#cb44-3 aria-hidden=true></a><span class=ot>foo ::</span> <span class=dt>UDI</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Personne</span> <span class=co>-- Impossible de confondre</span></span></code></pre></div><h3 id=changement-intempestif-dun-etat-global>Changement intempestif d'un Etat Global</h3><div class=sourceCode id=cb45><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb45-1><a href=#cb45-1 aria-hidden=true></a><span class=ot>foo ::</span> <span class=dt>GlobalState</span> <span class=ot>-&gt;</span> x</span></code></pre></div><p><strong><code>foo</code> ne peut pas changer <code>GlobalState</code></strong><h1 id=organisation-du-code>Organisation du Code</h1><h3 id=grands-concepts>Grands Concepts</h3><p>Procedure vs Functions:<table><tbody><tr class=odd><td>Gestion d'une configuration globale<tr class=even><td>Gestion d'un état global<tr class=odd><td>Gestion des Erreurs<tr class=even><td>Gestion des IO</table><h3 id=monades>Monades</h3><p>Pour chacun de ces <em>problèmes</em> il existe une monade:<table><tbody><tr class=odd><td>Gestion d'une configuration globale<td><code>Reader</code><tr class=even><td>Gestion d'un état global<td><code>State</code><tr class=odd><td>Gestion des Erreurs<td><code>Either</code><tr class=even><td>Gestion des IO<td><code>IO</code></table><h3 id=effets>Effets</h3><p>Gestion de plusieurs Effets dans la même fonction:<ul><li>MTL<li>Free Monad<li>Freer Monad</ul><p>Idée: donner à certaines sous-fonction accès à une partie des effets seulement.<p>Par exemple:<ul><li>limiter une fonction à la lecture de la DB mais pas l'écriture.<li>limiter l'écriture à une seule table<li>interdire l'écriture de logs<li>interdire l'écriture sur le disque dur<li>etc…</ul><h3 id=exemple-dans-un-code-réel-1>Exemple dans un code réel (1)</h3><div class=sourceCode id=cb46><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb46-1><a href=#cb46-1 aria-hidden=true></a><span class=co>-- | ConsumerBot type, the main monad in which the bot code is written with.</span></span>
<span id=cb46-2><a href=#cb46-2 aria-hidden=true></a><span class=co>-- Provide config, state, logs and IO</span></span>
<span id=cb46-3><a href=#cb46-3 aria-hidden=true></a><span class=kw>type</span> <span class=dt>ConsumerBot</span> m a <span class=ot>=</span></span>
<span id=cb46-4><a href=#cb46-4 aria-hidden=true></a>  ( <span class=dt>MonadState</span> <span class=dt>ConsumerState</span> m</span>
<span id=cb46-5><a href=#cb46-5 aria-hidden=true></a>  , <span class=dt>MonadReader</span> <span class=dt>ConsumerConf</span> m</span>
<span id=cb46-6><a href=#cb46-6 aria-hidden=true></a>  , <span class=dt>MonadLog</span> (<span class=dt>WithSeverity</span> <span class=dt>Doc</span>) m</span>
<span id=cb46-7><a href=#cb46-7 aria-hidden=true></a>  , <span class=dt>MonadBaseControl</span> <span class=dt>IO</span> m</span>
<span id=cb46-8><a href=#cb46-8 aria-hidden=true></a>  , <span class=dt>MonadSleep</span> m</span>
<span id=cb46-9><a href=#cb46-9 aria-hidden=true></a>  , <span class=dt>MonadPubSub</span> m</span>
<span id=cb46-10><a href=#cb46-10 aria-hidden=true></a>  , <span class=dt>MonadIO</span> m</span>
<span id=cb46-11><a href=#cb46-11 aria-hidden=true></a>  ) <span class=ot>=&gt;</span> m a</span></code></pre></div><h3 id=exemple-dans-un-code-réel-2>Exemple dans un code réel (2)</h3><div class=sourceCode id=cb47><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb47-1><a href=#cb47-1 aria-hidden=true></a><span class=ot>bot ::</span> <span class=dt>Manager</span></span>
<span id=cb47-2><a href=#cb47-2 aria-hidden=true></a>    <span class=ot>-&gt;</span> <span class=dt>RotatingLog</span></span>
<span id=cb47-3><a href=#cb47-3 aria-hidden=true></a>    <span class=ot>-&gt;</span> <span class=dt>Chan</span> <span class=dt>RedditComment</span></span>
<span id=cb47-4><a href=#cb47-4 aria-hidden=true></a>    <span class=ot>-&gt;</span> <span class=dt>TVar</span> <span class=dt>RedbotConfs</span></span>
<span id=cb47-5><a href=#cb47-5 aria-hidden=true></a>    <span class=ot>-&gt;</span> <span class=dt>Severity</span></span>
<span id=cb47-6><a href=#cb47-6 aria-hidden=true></a>    <span class=ot>-&gt;</span> <span class=dt>IO</span> ()</span>
<span id=cb47-7><a href=#cb47-7 aria-hidden=true></a>bot manager rotLog pubsub redbots minSeverity <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb47-8><a href=#cb47-8 aria-hidden=true></a>  TC.setDefaultPersist TC.filePersist</span>
<span id=cb47-9><a href=#cb47-9 aria-hidden=true></a>  <span class=kw>let</span> conf <span class=ot>=</span> <span class=dt>ConsumerConf</span></span>
<span id=cb47-10><a href=#cb47-10 aria-hidden=true></a>             { rhconf <span class=ot>=</span> <span class=dt>RedditHttpConf</span> { _connMgr <span class=ot>=</span> manager }</span>
<span id=cb47-11><a href=#cb47-11 aria-hidden=true></a>             , commentStream <span class=ot>=</span> pubsub</span>
<span id=cb47-12><a href=#cb47-12 aria-hidden=true></a>             }</span>
<span id=cb47-13><a href=#cb47-13 aria-hidden=true></a>  void <span class=op>$</span> autobot</span>
<span id=cb47-14><a href=#cb47-14 aria-hidden=true></a>       <span class=op>&amp;</span> <span class=fu>flip</span> runReaderT conf</span>
<span id=cb47-15><a href=#cb47-15 aria-hidden=true></a>       <span class=op>&amp;</span> <span class=fu>flip</span> runStateT (initState redbots)</span>
<span id=cb47-16><a href=#cb47-16 aria-hidden=true></a>       <span class=op>&amp;</span> <span class=fu>flip</span> runLoggingT (renderLog minSeverity rotLog)</span></code></pre></div><h2 id=règles-pragmatiques>Règles <strong>pragmatiques</strong></h2><h3 id=organisation-en-fonction-de-la-complexité>Organisation en fonction de la complexité</h3><blockquote><p>Make it work, make it right, make it fast</blockquote><ul><li>Simple: directement IO (YOLO!)<li>Medium: Haskell Design Patterns: The Handle Pattern: <a href=https://jaspervdj.be/posts/2018-03-08-handle-pattern.html>https://jaspervdj.be/posts/2018-03-08-handle-pattern.html</a><li>Medium (bis): MTL / Free / Freeer / Effects…<li>Gros: Three Layer Haskell Cake: <a href=http://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html>http://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html</a><ul><li>Layer 1: Imperatif<li>Orienté Objet (Level 2 / 2')<li>Fonctionnel</ul></ul><h3 id=couches>3 couches</h3><ul><li><strong>Imperatif</strong>: ReaderT IO<ul><li>Insérer l'état dans une <code>TVar</code>, <code>MVar</code> ou <code>IORef</code> (concurrence)</ul><li><strong>Orienté Objet</strong>:<ul><li>Handle / MTL / Free…<li>donner des access <code>UserDB</code>, <code>AccessTime</code>, <code>APIHTTP</code>…</ul><li><strong>Fonctionnel</strong>: Business Logic <code>f : Handlers -> Inputs -> Command</code></ul><h3 id=services-lib>Services / Lib</h3><p>Service: <code>init</code> / <code>start</code> / <code>close</code> + methodes… Lib: methodes sans état interne.<h1 id=conclusion>Conclusion</h1><h3 id=pourquoi-haskell-1>Pourquoi Haskell?</h3><ul><li>avantage compétitif: qualité & productivité hors norme<li>change son approche de la programmation<li>les concepts appris sont utilisables dans tous les languages<li>permet d'aller là où aucun autre langage ne peut vous amener<li>Approfondissement sans fin:<ul><li>Théorie: théorie des catégories, théorie des types homotopiques, etc…<li>Optim: compilateur<li>Qualité: tests, preuves<li>Organisation: capacité de contraindre de très haut vers très bas</ul></ul><h3 id=avantage-compétitif>Avantage compétitif</h3><ul><li>France, Europe du sud & Functional Programming<li>Coût Maintenance >> production d'un nouveau produit<li>Coût de la refactorisation<li>"Make it work, Make it right, Make it fast" moins cher.</ul><h3 id=pour-la-suite>Pour la suite</h3><p>A chacun de choisir, livres, tutoriels, videos, chat, etc…<ul><li>Voici une liste de resources : <a href=https://www.haskell.org/documentation>https://www.haskell.org/documentation</a><li>Mon tuto rapide : <a href=http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/>Haskell the Hard Way</a><li>Moteurs de recherche par type : <a href=http://hayoo.fh-wedel.de>hayoo</a> & <a href=http://haskell.org/hoogle>hoogle</a><li>Communauté & News : <a href=http://haskell.org/news>http://haskell.org/news</a> & <code>#haskell-fr</code> sur freenode<li>Libs: <a href=https://hackage.haskell.org>https://hackage.haskell.org</a> & <a href=https://stackage.org>https://stackage.org</a></ul><h1 id=appendix>Appendix</h1><h3 id=stm-exemple-concurrence-12>STM: Exemple (Concurrence) (1/2)</h3><div class=sourceCode id=cb48><pre class="sourceCode java"><code class="sourceCode java"><span id=cb48-1><a href=#cb48-1 aria-hidden=true></a><span class=kw>class</span> Account {</span>
<span id=cb48-2><a href=#cb48-2 aria-hidden=true></a>  <span class=dt>float</span> balance;</span>
<span id=cb48-3><a href=#cb48-3 aria-hidden=true></a>  <span class=kw>synchronized</span> <span class=dt>void</span> <span class=fu>deposit</span>(<span class=dt>float</span> amount){</span>
<span id=cb48-4><a href=#cb48-4 aria-hidden=true></a>    balance += amount; }</span>
<span id=cb48-5><a href=#cb48-5 aria-hidden=true></a>  <span class=kw>synchronized</span> <span class=dt>void</span> <span class=fu>withdraw</span>(<span class=dt>float</span> amount){</span>
<span id=cb48-6><a href=#cb48-6 aria-hidden=true></a>    <span class=kw>if</span> (balance &lt; amount) <span class=kw>throw</span> <span class=kw>new</span> <span class=fu>OutOfMoneyError</span>();</span>
<span id=cb48-7><a href=#cb48-7 aria-hidden=true></a>    balance -= amount; }</span>
<span id=cb48-8><a href=#cb48-8 aria-hidden=true></a>  <span class=kw>synchronized</span> <span class=dt>void</span> <span class=fu>transfert</span>(Account other, <span class=dt>float</span> amount){</span>
<span id=cb48-9><a href=#cb48-9 aria-hidden=true></a>    other.<span class=fu>withdraw</span>(amount);</span>
<span id=cb48-10><a href=#cb48-10 aria-hidden=true></a>    <span class=kw>this</span>.<span class=fu>deposit</span>(amount); }</span>
<span id=cb48-11><a href=#cb48-11 aria-hidden=true></a>}</span></code></pre></div><p>Situation d'interblocage typique. (A transfert vers B et B vers A).<h3 id=stm-exemple-concurrence-22>STM: Exemple (Concurrence) (2/2)</h3><div class=sourceCode id=cb49><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id=cb49-1><a href=#cb49-1 aria-hidden=true></a><span class=ot>deposit ::</span> <span class=dt>TVar</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>STM</span> ()</span>
<span id=cb49-2><a href=#cb49-2 aria-hidden=true></a>deposit acc n <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb49-3><a href=#cb49-3 aria-hidden=true></a>  bal <span class=ot>&lt;-</span> readTVar acc</span>
<span id=cb49-4><a href=#cb49-4 aria-hidden=true></a>  writeTVar acc (bal <span class=op>+</span> n)</span>
<span id=cb49-5><a href=#cb49-5 aria-hidden=true></a><span class=ot>withdraw ::</span> <span class=dt>TVar</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>STM</span> ()</span>
<span id=cb49-6><a href=#cb49-6 aria-hidden=true></a>withdraw acc n <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb49-7><a href=#cb49-7 aria-hidden=true></a>  bal <span class=ot>&lt;-</span> readTVar acc</span>
<span id=cb49-8><a href=#cb49-8 aria-hidden=true></a>  <span class=kw>if</span> bal <span class=op>&lt;</span> n <span class=kw>then</span> retry</span>
<span id=cb49-9><a href=#cb49-9 aria-hidden=true></a>  writeTVar acc (bal <span class=op>-</span> n)</span>
<span id=cb49-10><a href=#cb49-10 aria-hidden=true></a><span class=ot>transfer ::</span> <span class=dt>TVar</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>TVar</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>Int</span> <span class=ot>-&gt;</span> <span class=dt>STM</span> ()</span>
<span id=cb49-11><a href=#cb49-11 aria-hidden=true></a>transfer from to n <span class=ot>=</span> <span class=kw>do</span></span>
<span id=cb49-12><a href=#cb49-12 aria-hidden=true></a>  withdraw from n</span>
<span id=cb49-13><a href=#cb49-13 aria-hidden=true></a>  deposit to n</span></code></pre></div><ul><li>pas de lock explicite, composition naturelle dans <code>transfer</code>.<li>si une des deux opération échoue toute la transaction échoue<li>le système de type force cette opération a être atomique: <code>atomically :: STM a -> IO a</code></ul></div><div id=postamble class=status><div class=content><nav><a href=/index.html>Home</a> |
<a href=/slides.html>Slides</a> |
<a href=/about-me.html>About</a>
<span class=details>(<a href=https://gitea.esy.fun/yogsototh>code</a>
<a href=https://espial.esy.fun/u:yogsototh>bookmarks</a>
<a href=https://espial.esy.fun/u:yogsototh/notes>notes</a>)</span> |
<a href=#preamble>↑ Top ↑</a></nav></div></div></div>